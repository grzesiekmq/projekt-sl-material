<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>materialize.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: materialize.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*!
 * Materialize v0.98.0 (http://materializecss.com)
 * Copyright 2014-2015 Materialize
 * MIT License (https://raw.githubusercontent.com/Dogfalo/materialize/master/LICENSE)
 */
// Check for jQuery.
if (typeof(jQuery) === &#x27;undefined&#x27;) {
  var jQuery;
  // Check if require is a defined function.
  if (typeof(require) === &#x27;function&#x27;) {
    jQuery = $ = require(&#x27;jquery&#x27;);
  // Else use the dollar sign alias.
  } else {
    jQuery = $;
  }
}
;/*
 * jQuery Easing v1.3 - http://gsgd.co.uk/sandbox/jquery/easing/
 *
 * Uses the built in easing capabilities added In jQuery 1.1
 * to offer multiple easing options
 *
 * TERMS OF USE - jQuery Easing
 *
 * Open source under the BSD License.
 *
 * Copyright © 2008 George McGinley Smith
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this list of
 * conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this list
 * of conditions and the following disclaimer in the documentation and/or other materials
 * provided with the distribution.
 *
 * Neither the name of the author nor the names of contributors may be used to endorse
 * or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

// t: current time, b: begInnIng value, c: change In value, d: duration
jQuery.easing[&#x27;jswing&#x27;] = jQuery.easing[&#x27;swing&#x27;];

jQuery.extend( jQuery.easing,
{
	def: &#x27;easeOutQuad&#x27;,
	swing: function (x, t, b, c, d) {
		//alert(jQuery.easing.default);
		return jQuery.easing[jQuery.easing.def](x, t, b, c, d);
	},
	easeInQuad: function (x, t, b, c, d) {
		return c*(t/=d)*t + b;
	},
	easeOutQuad: function (x, t, b, c, d) {
		return -c *(t/=d)*(t-2) + b;
	},
	easeInOutQuad: function (x, t, b, c, d) {
		if ((t/=d/2) &lt; 1) return c/2*t*t + b;
		return -c/2 * ((--t)*(t-2) - 1) + b;
	},
	easeInCubic: function (x, t, b, c, d) {
		return c*(t/=d)*t*t + b;
	},
	easeOutCubic: function (x, t, b, c, d) {
		return c*((t=t/d-1)*t*t + 1) + b;
	},
	easeInOutCubic: function (x, t, b, c, d) {
		if ((t/=d/2) &lt; 1) return c/2*t*t*t + b;
		return c/2*((t-=2)*t*t + 2) + b;
	},
	easeInQuart: function (x, t, b, c, d) {
		return c*(t/=d)*t*t*t + b;
	},
	easeOutQuart: function (x, t, b, c, d) {
		return -c * ((t=t/d-1)*t*t*t - 1) + b;
	},
	easeInOutQuart: function (x, t, b, c, d) {
		if ((t/=d/2) &lt; 1) return c/2*t*t*t*t + b;
		return -c/2 * ((t-=2)*t*t*t - 2) + b;
	},
	easeInQuint: function (x, t, b, c, d) {
		return c*(t/=d)*t*t*t*t + b;
	},
	easeOutQuint: function (x, t, b, c, d) {
		return c*((t=t/d-1)*t*t*t*t + 1) + b;
	},
	easeInOutQuint: function (x, t, b, c, d) {
		if ((t/=d/2) &lt; 1) return c/2*t*t*t*t*t + b;
		return c/2*((t-=2)*t*t*t*t + 2) + b;
	},
	easeInSine: function (x, t, b, c, d) {
		return -c * Math.cos(t/d * (Math.PI/2)) + c + b;
	},
	easeOutSine: function (x, t, b, c, d) {
		return c * Math.sin(t/d * (Math.PI/2)) + b;
	},
	easeInOutSine: function (x, t, b, c, d) {
		return -c/2 * (Math.cos(Math.PI*t/d) - 1) + b;
	},
	easeInExpo: function (x, t, b, c, d) {
		return (t==0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b;
	},
	easeOutExpo: function (x, t, b, c, d) {
		return (t==d) ? b+c : c * (-Math.pow(2, -10 * t/d) + 1) + b;
	},
	easeInOutExpo: function (x, t, b, c, d) {
		if (t==0) return b;
		if (t==d) return b+c;
		if ((t/=d/2) &lt; 1) return c/2 * Math.pow(2, 10 * (t - 1)) + b;
		return c/2 * (-Math.pow(2, -10 * --t) + 2) + b;
	},
	easeInCirc: function (x, t, b, c, d) {
		return -c * (Math.sqrt(1 - (t/=d)*t) - 1) + b;
	},
	easeOutCirc: function (x, t, b, c, d) {
		return c * Math.sqrt(1 - (t=t/d-1)*t) + b;
	},
	easeInOutCirc: function (x, t, b, c, d) {
		if ((t/=d/2) &lt; 1) return -c/2 * (Math.sqrt(1 - t*t) - 1) + b;
		return c/2 * (Math.sqrt(1 - (t-=2)*t) + 1) + b;
	},
	easeInElastic: function (x, t, b, c, d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;
		if (a &lt; Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		return -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
	},
	easeOutElastic: function (x, t, b, c, d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;
		if (a &lt; Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		return a*Math.pow(2,-10*t) * Math.sin( (t*d-s)*(2*Math.PI)/p ) + c + b;
	},
	easeInOutElastic: function (x, t, b, c, d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b;  if ((t/=d/2)==2) return b+c;  if (!p) p=d*(.3*1.5);
		if (a &lt; Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		if (t &lt; 1) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
		return a*Math.pow(2,-10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )*.5 + c + b;
	},
	easeInBack: function (x, t, b, c, d, s) {
		if (s == undefined) s = 1.70158;
		return c*(t/=d)*t*((s+1)*t - s) + b;
	},
	easeOutBack: function (x, t, b, c, d, s) {
		if (s == undefined) s = 1.70158;
		return c*((t=t/d-1)*t*((s+1)*t + s) + 1) + b;
	},
	easeInOutBack: function (x, t, b, c, d, s) {
		if (s == undefined) s = 1.70158;
		if ((t/=d/2) &lt; 1) return c/2*(t*t*(((s*=(1.525))+1)*t - s)) + b;
		return c/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2) + b;
	},
	easeInBounce: function (x, t, b, c, d) {
		return c - jQuery.easing.easeOutBounce (x, d-t, 0, c, d) + b;
	},
	easeOutBounce: function (x, t, b, c, d) {
		if ((t/=d) &lt; (1/2.75)) {
			return c*(7.5625*t*t) + b;
		} else if (t &lt; (2/2.75)) {
			return c*(7.5625*(t-=(1.5/2.75))*t + .75) + b;
		} else if (t &lt; (2.5/2.75)) {
			return c*(7.5625*(t-=(2.25/2.75))*t + .9375) + b;
		} else {
			return c*(7.5625*(t-=(2.625/2.75))*t + .984375) + b;
		}
	},
	easeInOutBounce: function (x, t, b, c, d) {
		if (t &lt; d/2) return jQuery.easing.easeInBounce (x, t*2, 0, c, d) * .5 + b;
		return jQuery.easing.easeOutBounce (x, t*2-d, 0, c, d) * .5 + c*.5 + b;
	}
});

/*
 *
 * TERMS OF USE - EASING EQUATIONS
 *
 * Open source under the BSD License.
 *
 * Copyright © 2001 Robert Penner
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this list of
 * conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this list
 * of conditions and the following disclaimer in the documentation and/or other materials
 * provided with the distribution.
 *
 * Neither the name of the author nor the names of contributors may be used to endorse
 * or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */;// Custom Easing
jQuery.extend( jQuery.easing,
{
  easeInOutMaterial: function (x, t, b, c, d) {
    if ((t/=d/2) &lt; 1) return c/2*t*t + b;
    return c/4*((t-=2)*t*t + 2) + b;
  }
});;/*! VelocityJS.org (1.2.3). (C) 2014 Julian Shapiro. MIT @license: en.wikipedia.org/wiki/MIT_License */
/*! VelocityJS.org jQuery Shim (1.0.1). (C) 2014 The jQuery Foundation. MIT @license: en.wikipedia.org/wiki/MIT_License. */
/*! Note that this has been modified by Materialize to confirm that Velocity is not already being imported. */
jQuery.Velocity?console.log(&quot;Velocity is already loaded. You may be needlessly importing Velocity again; note that Materialize includes Velocity.&quot;):(!function(e){function t(e){var t=e.length,a=r.type(e);return&quot;function&quot;===a||r.isWindow(e)?!1:1===e.nodeType&amp;&amp;t?!0:&quot;array&quot;===a||0===t||&quot;number&quot;==typeof t&amp;&amp;t&gt;0&amp;&amp;t-1 in e}if(!e.jQuery){var r=function(e,t){return new r.fn.init(e,t)};r.isWindow=function(e){return null!=e&amp;&amp;e==e.window},r.type=function(e){return null==e?e+&quot;&quot;:&quot;object&quot;==typeof e||&quot;function&quot;==typeof e?n[i.call(e)]||&quot;object&quot;:typeof e},r.isArray=Array.isArray||function(e){return&quot;array&quot;===r.type(e)},r.isPlainObject=function(e){var t;if(!e||&quot;object&quot;!==r.type(e)||e.nodeType||r.isWindow(e))return!1;try{if(e.constructor&amp;&amp;!o.call(e,&quot;constructor&quot;)&amp;&amp;!o.call(e.constructor.prototype,&quot;isPrototypeOf&quot;))return!1}catch(a){return!1}for(t in e);return void 0===t||o.call(e,t)},r.each=function(e,r,a){var n,o=0,i=e.length,s=t(e);if(a){if(s)for(;i&gt;o&amp;&amp;(n=r.apply(e[o],a),n!==!1);o++);else for(o in e)if(n=r.apply(e[o],a),n===!1)break}else if(s)for(;i&gt;o&amp;&amp;(n=r.call(e[o],o,e[o]),n!==!1);o++);else for(o in e)if(n=r.call(e[o],o,e[o]),n===!1)break;return e},r.data=function(e,t,n){if(void 0===n){var o=e[r.expando],i=o&amp;&amp;a[o];if(void 0===t)return i;if(i&amp;&amp;t in i)return i[t]}else if(void 0!==t){var o=e[r.expando]||(e[r.expando]=++r.uuid);return a[o]=a[o]||{},a[o][t]=n,n}},r.removeData=function(e,t){var n=e[r.expando],o=n&amp;&amp;a[n];o&amp;&amp;r.each(t,function(e,t){delete o[t]})},r.extend=function(){var e,t,a,n,o,i,s=arguments[0]||{},l=1,u=arguments.length,c=!1;for(&quot;boolean&quot;==typeof s&amp;&amp;(c=s,s=arguments[l]||{},l++),&quot;object&quot;!=typeof s&amp;&amp;&quot;function&quot;!==r.type(s)&amp;&amp;(s={}),l===u&amp;&amp;(s=this,l--);u&gt;l;l++)if(null!=(o=arguments[l]))for(n in o)e=s[n],a=o[n],s!==a&amp;&amp;(c&amp;&amp;a&amp;&amp;(r.isPlainObject(a)||(t=r.isArray(a)))?(t?(t=!1,i=e&amp;&amp;r.isArray(e)?e:[]):i=e&amp;&amp;r.isPlainObject(e)?e:{},s[n]=r.extend(c,i,a)):void 0!==a&amp;&amp;(s[n]=a));return s},r.queue=function(e,a,n){function o(e,r){var a=r||[];return null!=e&amp;&amp;(t(Object(e))?!function(e,t){for(var r=+t.length,a=0,n=e.length;r&gt;a;)e[n++]=t[a++];if(r!==r)for(;void 0!==t[a];)e[n++]=t[a++];return e.length=n,e}(a,&quot;string&quot;==typeof e?[e]:e):[].push.call(a,e)),a}if(e){a=(a||&quot;fx&quot;)+&quot;queue&quot;;var i=r.data(e,a);return n?(!i||r.isArray(n)?i=r.data(e,a,o(n)):i.push(n),i):i||[]}},r.dequeue=function(e,t){r.each(e.nodeType?[e]:e,function(e,a){t=t||&quot;fx&quot;;var n=r.queue(a,t),o=n.shift();&quot;inprogress&quot;===o&amp;&amp;(o=n.shift()),o&amp;&amp;(&quot;fx&quot;===t&amp;&amp;n.unshift(&quot;inprogress&quot;),o.call(a,function(){r.dequeue(a,t)}))})},r.fn=r.prototype={init:function(e){if(e.nodeType)return this[0]=e,this;throw new Error(&quot;Not a DOM node.&quot;)},offset:function(){var t=this[0].getBoundingClientRect?this[0].getBoundingClientRect():{top:0,left:0};return{top:t.top+(e.pageYOffset||document.scrollTop||0)-(document.clientTop||0),left:t.left+(e.pageXOffset||document.scrollLeft||0)-(document.clientLeft||0)}},position:function(){function e(){for(var e=this.offsetParent||document;e&amp;&amp;&quot;html&quot;===!e.nodeType.toLowerCase&amp;&amp;&quot;static&quot;===e.style.position;)e=e.offsetParent;return e||document}var t=this[0],e=e.apply(t),a=this.offset(),n=/^(?:body|html)$/i.test(e.nodeName)?{top:0,left:0}:r(e).offset();return a.top-=parseFloat(t.style.marginTop)||0,a.left-=parseFloat(t.style.marginLeft)||0,e.style&amp;&amp;(n.top+=parseFloat(e.style.borderTopWidth)||0,n.left+=parseFloat(e.style.borderLeftWidth)||0),{top:a.top-n.top,left:a.left-n.left}}};var a={};r.expando=&quot;velocity&quot;+(new Date).getTime(),r.uuid=0;for(var n={},o=n.hasOwnProperty,i=n.toString,s=&quot;Boolean Number String Function Array Date RegExp Object Error&quot;.split(&quot; &quot;),l=0;l&lt;s.length;l++)n[&quot;[object &quot;+s[l]+&quot;]&quot;]=s[l].toLowerCase();r.fn.init.prototype=r.fn,e.Velocity={Utilities:r}}}(window),function(e){&quot;object&quot;==typeof module&amp;&amp;&quot;object&quot;==typeof module.exports?module.exports=e():&quot;function&quot;==typeof define&amp;&amp;define.amd?define(e):e()}(function(){return function(e,t,r,a){function n(e){for(var t=-1,r=e?e.length:0,a=[];++t&lt;r;){var n=e[t];n&amp;&amp;a.push(n)}return a}function o(e){return m.isWrapped(e)?e=[].slice.call(e):m.isNode(e)&amp;&amp;(e=[e]),e}function i(e){var t=f.data(e,&quot;velocity&quot;);return null===t?a:t}function s(e){return function(t){return Math.round(t*e)*(1/e)}}function l(e,r,a,n){function o(e,t){return 1-3*t+3*e}function i(e,t){return 3*t-6*e}function s(e){return 3*e}function l(e,t,r){return((o(t,r)*e+i(t,r))*e+s(t))*e}function u(e,t,r){return 3*o(t,r)*e*e+2*i(t,r)*e+s(t)}function c(t,r){for(var n=0;m&gt;n;++n){var o=u(r,e,a);if(0===o)return r;var i=l(r,e,a)-t;r-=i/o}return r}function p(){for(var t=0;b&gt;t;++t)w[t]=l(t*x,e,a)}function f(t,r,n){var o,i,s=0;do i=r+(n-r)/2,o=l(i,e,a)-t,o&gt;0?n=i:r=i;while(Math.abs(o)&gt;h&amp;&amp;++s&lt;v);return i}function d(t){for(var r=0,n=1,o=b-1;n!=o&amp;&amp;w[n]&lt;=t;++n)r+=x;--n;var i=(t-w[n])/(w[n+1]-w[n]),s=r+i*x,l=u(s,e,a);return l&gt;=y?c(t,s):0==l?s:f(t,r,r+x)}function g(){V=!0,(e!=r||a!=n)&amp;&amp;p()}var m=4,y=.001,h=1e-7,v=10,b=11,x=1/(b-1),S=&quot;Float32Array&quot;in t;if(4!==arguments.length)return!1;for(var P=0;4&gt;P;++P)if(&quot;number&quot;!=typeof arguments[P]||isNaN(arguments[P])||!isFinite(arguments[P]))return!1;e=Math.min(e,1),a=Math.min(a,1),e=Math.max(e,0),a=Math.max(a,0);var w=S?new Float32Array(b):new Array(b),V=!1,C=function(t){return V||g(),e===r&amp;&amp;a===n?t:0===t?0:1===t?1:l(d(t),r,n)};C.getControlPoints=function(){return[{x:e,y:r},{x:a,y:n}]};var T=&quot;generateBezier(&quot;+[e,r,a,n]+&quot;)&quot;;return C.toString=function(){return T},C}function u(e,t){var r=e;return m.isString(e)?b.Easings[e]||(r=!1):r=m.isArray(e)&amp;&amp;1===e.length?s.apply(null,e):m.isArray(e)&amp;&amp;2===e.length?x.apply(null,e.concat([t])):m.isArray(e)&amp;&amp;4===e.length?l.apply(null,e):!1,r===!1&amp;&amp;(r=b.Easings[b.defaults.easing]?b.defaults.easing:v),r}function c(e){if(e){var t=(new Date).getTime(),r=b.State.calls.length;r&gt;1e4&amp;&amp;(b.State.calls=n(b.State.calls));for(var o=0;r&gt;o;o++)if(b.State.calls[o]){var s=b.State.calls[o],l=s[0],u=s[2],d=s[3],g=!!d,y=null;d||(d=b.State.calls[o][3]=t-16);for(var h=Math.min((t-d)/u.duration,1),v=0,x=l.length;x&gt;v;v++){var P=l[v],V=P.element;if(i(V)){var C=!1;if(u.display!==a&amp;&amp;null!==u.display&amp;&amp;&quot;none&quot;!==u.display){if(&quot;flex&quot;===u.display){var T=[&quot;-webkit-box&quot;,&quot;-moz-box&quot;,&quot;-ms-flexbox&quot;,&quot;-webkit-flex&quot;];f.each(T,function(e,t){S.setPropertyValue(V,&quot;display&quot;,t)})}S.setPropertyValue(V,&quot;display&quot;,u.display)}u.visibility!==a&amp;&amp;&quot;hidden&quot;!==u.visibility&amp;&amp;S.setPropertyValue(V,&quot;visibility&quot;,u.visibility);for(var k in P)if(&quot;element&quot;!==k){var A,F=P[k],j=m.isString(F.easing)?b.Easings[F.easing]:F.easing;if(1===h)A=F.endValue;else{var E=F.endValue-F.startValue;if(A=F.startValue+E*j(h,u,E),!g&amp;&amp;A===F.currentValue)continue}if(F.currentValue=A,&quot;tween&quot;===k)y=A;else{if(S.Hooks.registered[k]){var H=S.Hooks.getRoot(k),N=i(V).rootPropertyValueCache[H];N&amp;&amp;(F.rootPropertyValue=N)}var L=S.setPropertyValue(V,k,F.currentValue+(0===parseFloat(A)?&quot;&quot;:F.unitType),F.rootPropertyValue,F.scrollData);S.Hooks.registered[k]&amp;&amp;(i(V).rootPropertyValueCache[H]=S.Normalizations.registered[H]?S.Normalizations.registered[H](&quot;extract&quot;,null,L[1]):L[1]),&quot;transform&quot;===L[0]&amp;&amp;(C=!0)}}u.mobileHA&amp;&amp;i(V).transformCache.translate3d===a&amp;&amp;(i(V).transformCache.translate3d=&quot;(0px, 0px, 0px)&quot;,C=!0),C&amp;&amp;S.flushTransformCache(V)}}u.display!==a&amp;&amp;&quot;none&quot;!==u.display&amp;&amp;(b.State.calls[o][2].display=!1),u.visibility!==a&amp;&amp;&quot;hidden&quot;!==u.visibility&amp;&amp;(b.State.calls[o][2].visibility=!1),u.progress&amp;&amp;u.progress.call(s[1],s[1],h,Math.max(0,d+u.duration-t),d,y),1===h&amp;&amp;p(o)}}b.State.isTicking&amp;&amp;w(c)}function p(e,t){if(!b.State.calls[e])return!1;for(var r=b.State.calls[e][0],n=b.State.calls[e][1],o=b.State.calls[e][2],s=b.State.calls[e][4],l=!1,u=0,c=r.length;c&gt;u;u++){var p=r[u].element;if(t||o.loop||(&quot;none&quot;===o.display&amp;&amp;S.setPropertyValue(p,&quot;display&quot;,o.display),&quot;hidden&quot;===o.visibility&amp;&amp;S.setPropertyValue(p,&quot;visibility&quot;,o.visibility)),o.loop!==!0&amp;&amp;(f.queue(p)[1]===a||!/\.velocityQueueEntryFlag/i.test(f.queue(p)[1]))&amp;&amp;i(p)){i(p).isAnimating=!1,i(p).rootPropertyValueCache={};var d=!1;f.each(S.Lists.transforms3D,function(e,t){var r=/^scale/.test(t)?1:0,n=i(p).transformCache[t];i(p).transformCache[t]!==a&amp;&amp;new RegExp(&quot;^\\(&quot;+r+&quot;[^.]&quot;).test(n)&amp;&amp;(d=!0,delete i(p).transformCache[t])}),o.mobileHA&amp;&amp;(d=!0,delete i(p).transformCache.translate3d),d&amp;&amp;S.flushTransformCache(p),S.Values.removeClass(p,&quot;velocity-animating&quot;)}if(!t&amp;&amp;o.complete&amp;&amp;!o.loop&amp;&amp;u===c-1)try{o.complete.call(n,n)}catch(g){setTimeout(function(){throw g},1)}s&amp;&amp;o.loop!==!0&amp;&amp;s(n),i(p)&amp;&amp;o.loop===!0&amp;&amp;!t&amp;&amp;(f.each(i(p).tweensContainer,function(e,t){/^rotate/.test(e)&amp;&amp;360===parseFloat(t.endValue)&amp;&amp;(t.endValue=0,t.startValue=360),/^backgroundPosition/.test(e)&amp;&amp;100===parseFloat(t.endValue)&amp;&amp;&quot;%&quot;===t.unitType&amp;&amp;(t.endValue=0,t.startValue=100)}),b(p,&quot;reverse&quot;,{loop:!0,delay:o.delay})),o.queue!==!1&amp;&amp;f.dequeue(p,o.queue)}b.State.calls[e]=!1;for(var m=0,y=b.State.calls.length;y&gt;m;m++)if(b.State.calls[m]!==!1){l=!0;break}l===!1&amp;&amp;(b.State.isTicking=!1,delete b.State.calls,b.State.calls=[])}var f,d=function(){if(r.documentMode)return r.documentMode;for(var e=7;e&gt;4;e--){var t=r.createElement(&quot;div&quot;);if(t.innerHTML=&quot;&lt;!--[if IE &quot;+e+&quot;]&gt;&lt;span&gt;&lt;/span&gt;&lt;![endif]--&gt;&quot;,t.getElementsByTagName(&quot;span&quot;).length)return t=null,e}return a}(),g=function(){var e=0;return t.webkitRequestAnimationFrame||t.mozRequestAnimationFrame||function(t){var r,a=(new Date).getTime();return r=Math.max(0,16-(a-e)),e=a+r,setTimeout(function(){t(a+r)},r)}}(),m={isString:function(e){return&quot;string&quot;==typeof e},isArray:Array.isArray||function(e){return&quot;[object Array]&quot;===Object.prototype.toString.call(e)},isFunction:function(e){return&quot;[object Function]&quot;===Object.prototype.toString.call(e)},isNode:function(e){return e&amp;&amp;e.nodeType},isNodeList:function(e){return&quot;object&quot;==typeof e&amp;&amp;/^\[object (HTMLCollection|NodeList|Object)\]$/.test(Object.prototype.toString.call(e))&amp;&amp;e.length!==a&amp;&amp;(0===e.length||&quot;object&quot;==typeof e[0]&amp;&amp;e[0].nodeType&gt;0)},isWrapped:function(e){return e&amp;&amp;(e.jquery||t.Zepto&amp;&amp;t.Zepto.zepto.isZ(e))},isSVG:function(e){return t.SVGElement&amp;&amp;e instanceof t.SVGElement},isEmptyObject:function(e){for(var t in e)return!1;return!0}},y=!1;if(e.fn&amp;&amp;e.fn.jquery?(f=e,y=!0):f=t.Velocity.Utilities,8&gt;=d&amp;&amp;!y)throw new Error(&quot;Velocity: IE8 and below require jQuery to be loaded before Velocity.&quot;);if(7&gt;=d)return void(jQuery.fn.velocity=jQuery.fn.animate);var h=400,v=&quot;swing&quot;,b={State:{isMobile:/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),isAndroid:/Android/i.test(navigator.userAgent),isGingerbread:/Android 2\.3\.[3-7]/i.test(navigator.userAgent),isChrome:t.chrome,isFirefox:/Firefox/i.test(navigator.userAgent),prefixElement:r.createElement(&quot;div&quot;),prefixMatches:{},scrollAnchor:null,scrollPropertyLeft:null,scrollPropertyTop:null,isTicking:!1,calls:[]},CSS:{},Utilities:f,Redirects:{},Easings:{},Promise:t.Promise,defaults:{queue:&quot;&quot;,duration:h,easing:v,begin:a,complete:a,progress:a,display:a,visibility:a,loop:!1,delay:!1,mobileHA:!0,_cacheValues:!0},init:function(e){f.data(e,&quot;velocity&quot;,{isSVG:m.isSVG(e),isAnimating:!1,computedStyle:null,tweensContainer:null,rootPropertyValueCache:{},transformCache:{}})},hook:null,mock:!1,version:{major:1,minor:2,patch:2},debug:!1};t.pageYOffset!==a?(b.State.scrollAnchor=t,b.State.scrollPropertyLeft=&quot;pageXOffset&quot;,b.State.scrollPropertyTop=&quot;pageYOffset&quot;):(b.State.scrollAnchor=r.documentElement||r.body.parentNode||r.body,b.State.scrollPropertyLeft=&quot;scrollLeft&quot;,b.State.scrollPropertyTop=&quot;scrollTop&quot;);var x=function(){function e(e){return-e.tension*e.x-e.friction*e.v}function t(t,r,a){var n={x:t.x+a.dx*r,v:t.v+a.dv*r,tension:t.tension,friction:t.friction};return{dx:n.v,dv:e(n)}}function r(r,a){var n={dx:r.v,dv:e(r)},o=t(r,.5*a,n),i=t(r,.5*a,o),s=t(r,a,i),l=1/6*(n.dx+2*(o.dx+i.dx)+s.dx),u=1/6*(n.dv+2*(o.dv+i.dv)+s.dv);return r.x=r.x+l*a,r.v=r.v+u*a,r}return function a(e,t,n){var o,i,s,l={x:-1,v:0,tension:null,friction:null},u=[0],c=0,p=1e-4,f=.016;for(e=parseFloat(e)||500,t=parseFloat(t)||20,n=n||null,l.tension=e,l.friction=t,o=null!==n,o?(c=a(e,t),i=c/n*f):i=f;s=r(s||l,i),u.push(1+s.x),c+=16,Math.abs(s.x)&gt;p&amp;&amp;Math.abs(s.v)&gt;p;);return o?function(e){return u[e*(u.length-1)|0]}:c}}();b.Easings={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2},spring:function(e){return 1-Math.cos(4.5*e*Math.PI)*Math.exp(6*-e)}},f.each([[&quot;ease&quot;,[.25,.1,.25,1]],[&quot;ease-in&quot;,[.42,0,1,1]],[&quot;ease-out&quot;,[0,0,.58,1]],[&quot;ease-in-out&quot;,[.42,0,.58,1]],[&quot;easeInSine&quot;,[.47,0,.745,.715]],[&quot;easeOutSine&quot;,[.39,.575,.565,1]],[&quot;easeInOutSine&quot;,[.445,.05,.55,.95]],[&quot;easeInQuad&quot;,[.55,.085,.68,.53]],[&quot;easeOutQuad&quot;,[.25,.46,.45,.94]],[&quot;easeInOutQuad&quot;,[.455,.03,.515,.955]],[&quot;easeInCubic&quot;,[.55,.055,.675,.19]],[&quot;easeOutCubic&quot;,[.215,.61,.355,1]],[&quot;easeInOutCubic&quot;,[.645,.045,.355,1]],[&quot;easeInQuart&quot;,[.895,.03,.685,.22]],[&quot;easeOutQuart&quot;,[.165,.84,.44,1]],[&quot;easeInOutQuart&quot;,[.77,0,.175,1]],[&quot;easeInQuint&quot;,[.755,.05,.855,.06]],[&quot;easeOutQuint&quot;,[.23,1,.32,1]],[&quot;easeInOutQuint&quot;,[.86,0,.07,1]],[&quot;easeInExpo&quot;,[.95,.05,.795,.035]],[&quot;easeOutExpo&quot;,[.19,1,.22,1]],[&quot;easeInOutExpo&quot;,[1,0,0,1]],[&quot;easeInCirc&quot;,[.6,.04,.98,.335]],[&quot;easeOutCirc&quot;,[.075,.82,.165,1]],[&quot;easeInOutCirc&quot;,[.785,.135,.15,.86]]],function(e,t){b.Easings[t[0]]=l.apply(null,t[1])});var S=b.CSS={RegEx:{isHex:/^#([A-f\d]{3}){1,2}$/i,valueUnwrap:/^[A-z]+\((.*)\)$/i,wrappedValueAlreadyExtracted:/[0-9.]+ [0-9.]+ [0-9.]+( [0-9.]+)?/,valueSplit:/([A-z]+\(.+\))|(([A-z0-9#-.]+?)(?=\s|$))/gi},Lists:{colors:[&quot;fill&quot;,&quot;stroke&quot;,&quot;stopColor&quot;,&quot;color&quot;,&quot;backgroundColor&quot;,&quot;borderColor&quot;,&quot;borderTopColor&quot;,&quot;borderRightColor&quot;,&quot;borderBottomColor&quot;,&quot;borderLeftColor&quot;,&quot;outlineColor&quot;],transformsBase:[&quot;translateX&quot;,&quot;translateY&quot;,&quot;scale&quot;,&quot;scaleX&quot;,&quot;scaleY&quot;,&quot;skewX&quot;,&quot;skewY&quot;,&quot;rotateZ&quot;],transforms3D:[&quot;transformPerspective&quot;,&quot;translateZ&quot;,&quot;scaleZ&quot;,&quot;rotateX&quot;,&quot;rotateY&quot;]},Hooks:{templates:{textShadow:[&quot;Color X Y Blur&quot;,&quot;black 0px 0px 0px&quot;],boxShadow:[&quot;Color X Y Blur Spread&quot;,&quot;black 0px 0px 0px 0px&quot;],clip:[&quot;Top Right Bottom Left&quot;,&quot;0px 0px 0px 0px&quot;],backgroundPosition:[&quot;X Y&quot;,&quot;0% 0%&quot;],transformOrigin:[&quot;X Y Z&quot;,&quot;50% 50% 0px&quot;],perspectiveOrigin:[&quot;X Y&quot;,&quot;50% 50%&quot;]},registered:{},register:function(){for(var e=0;e&lt;S.Lists.colors.length;e++){var t=&quot;color&quot;===S.Lists.colors[e]?&quot;0 0 0 1&quot;:&quot;255 255 255 1&quot;;S.Hooks.templates[S.Lists.colors[e]]=[&quot;Red Green Blue Alpha&quot;,t]}var r,a,n;if(d)for(r in S.Hooks.templates){a=S.Hooks.templates[r],n=a[0].split(&quot; &quot;);var o=a[1].match(S.RegEx.valueSplit);&quot;Color&quot;===n[0]&amp;&amp;(n.push(n.shift()),o.push(o.shift()),S.Hooks.templates[r]=[n.join(&quot; &quot;),o.join(&quot; &quot;)])}for(r in S.Hooks.templates){a=S.Hooks.templates[r],n=a[0].split(&quot; &quot;);for(var e in n){var i=r+n[e],s=e;S.Hooks.registered[i]=[r,s]}}},getRoot:function(e){var t=S.Hooks.registered[e];return t?t[0]:e},cleanRootPropertyValue:function(e,t){return S.RegEx.valueUnwrap.test(t)&amp;&amp;(t=t.match(S.RegEx.valueUnwrap)[1]),S.Values.isCSSNullValue(t)&amp;&amp;(t=S.Hooks.templates[e][1]),t},extractValue:function(e,t){var r=S.Hooks.registered[e];if(r){var a=r[0],n=r[1];return t=S.Hooks.cleanRootPropertyValue(a,t),t.toString().match(S.RegEx.valueSplit)[n]}return t},injectValue:function(e,t,r){var a=S.Hooks.registered[e];if(a){var n,o,i=a[0],s=a[1];return r=S.Hooks.cleanRootPropertyValue(i,r),n=r.toString().match(S.RegEx.valueSplit),n[s]=t,o=n.join(&quot; &quot;)}return r}},Normalizations:{registered:{clip:function(e,t,r){switch(e){case&quot;name&quot;:return&quot;clip&quot;;case&quot;extract&quot;:var a;return S.RegEx.wrappedValueAlreadyExtracted.test(r)?a=r:(a=r.toString().match(S.RegEx.valueUnwrap),a=a?a[1].replace(/,(\s+)?/g,&quot; &quot;):r),a;case&quot;inject&quot;:return&quot;rect(&quot;+r+&quot;)&quot;}},blur:function(e,t,r){switch(e){case&quot;name&quot;:return b.State.isFirefox?&quot;filter&quot;:&quot;-webkit-filter&quot;;case&quot;extract&quot;:var a=parseFloat(r);if(!a&amp;&amp;0!==a){var n=r.toString().match(/blur\(([0-9]+[A-z]+)\)/i);a=n?n[1]:0}return a;case&quot;inject&quot;:return parseFloat(r)?&quot;blur(&quot;+r+&quot;)&quot;:&quot;none&quot;}},opacity:function(e,t,r){if(8&gt;=d)switch(e){case&quot;name&quot;:return&quot;filter&quot;;case&quot;extract&quot;:var a=r.toString().match(/alpha\(opacity=(.*)\)/i);return r=a?a[1]/100:1;case&quot;inject&quot;:return t.style.zoom=1,parseFloat(r)&gt;=1?&quot;&quot;:&quot;alpha(opacity=&quot;+parseInt(100*parseFloat(r),10)+&quot;)&quot;}else switch(e){case&quot;name&quot;:return&quot;opacity&quot;;case&quot;extract&quot;:return r;case&quot;inject&quot;:return r}}},register:function(){9&gt;=d||b.State.isGingerbread||(S.Lists.transformsBase=S.Lists.transformsBase.concat(S.Lists.transforms3D));for(var e=0;e&lt;S.Lists.transformsBase.length;e++)!function(){var t=S.Lists.transformsBase[e];S.Normalizations.registered[t]=function(e,r,n){switch(e){case&quot;name&quot;:return&quot;transform&quot;;case&quot;extract&quot;:return i(r)===a||i(r).transformCache[t]===a?/^scale/i.test(t)?1:0:i(r).transformCache[t].replace(/[()]/g,&quot;&quot;);case&quot;inject&quot;:var o=!1;switch(t.substr(0,t.length-1)){case&quot;translate&quot;:o=!/(%|px|em|rem|vw|vh|\d)$/i.test(n);break;case&quot;scal&quot;:case&quot;scale&quot;:b.State.isAndroid&amp;&amp;i(r).transformCache[t]===a&amp;&amp;1&gt;n&amp;&amp;(n=1),o=!/(\d)$/i.test(n);break;case&quot;skew&quot;:o=!/(deg|\d)$/i.test(n);break;case&quot;rotate&quot;:o=!/(deg|\d)$/i.test(n)}return o||(i(r).transformCache[t]=&quot;(&quot;+n+&quot;)&quot;),i(r).transformCache[t]}}}();for(var e=0;e&lt;S.Lists.colors.length;e++)!function(){var t=S.Lists.colors[e];S.Normalizations.registered[t]=function(e,r,n){switch(e){case&quot;name&quot;:return t;case&quot;extract&quot;:var o;if(S.RegEx.wrappedValueAlreadyExtracted.test(n))o=n;else{var i,s={black:&quot;rgb(0, 0, 0)&quot;,blue:&quot;rgb(0, 0, 255)&quot;,gray:&quot;rgb(128, 128, 128)&quot;,green:&quot;rgb(0, 128, 0)&quot;,red:&quot;rgb(255, 0, 0)&quot;,white:&quot;rgb(255, 255, 255)&quot;};/^[A-z]+$/i.test(n)?i=s[n]!==a?s[n]:s.black:S.RegEx.isHex.test(n)?i=&quot;rgb(&quot;+S.Values.hexToRgb(n).join(&quot; &quot;)+&quot;)&quot;:/^rgba?\(/i.test(n)||(i=s.black),o=(i||n).toString().match(S.RegEx.valueUnwrap)[1].replace(/,(\s+)?/g,&quot; &quot;)}return 8&gt;=d||3!==o.split(&quot; &quot;).length||(o+=&quot; 1&quot;),o;case&quot;inject&quot;:return 8&gt;=d?4===n.split(&quot; &quot;).length&amp;&amp;(n=n.split(/\s+/).slice(0,3).join(&quot; &quot;)):3===n.split(&quot; &quot;).length&amp;&amp;(n+=&quot; 1&quot;),(8&gt;=d?&quot;rgb&quot;:&quot;rgba&quot;)+&quot;(&quot;+n.replace(/\s+/g,&quot;,&quot;).replace(/\.(\d)+(?=,)/g,&quot;&quot;)+&quot;)&quot;}}}()}},Names:{camelCase:function(e){return e.replace(/-(\w)/g,function(e,t){return t.toUpperCase()})},SVGAttribute:function(e){var t=&quot;width|height|x|y|cx|cy|r|rx|ry|x1|x2|y1|y2&quot;;return(d||b.State.isAndroid&amp;&amp;!b.State.isChrome)&amp;&amp;(t+=&quot;|transform&quot;),new RegExp(&quot;^(&quot;+t+&quot;)$&quot;,&quot;i&quot;).test(e)},prefixCheck:function(e){if(b.State.prefixMatches[e])return[b.State.prefixMatches[e],!0];for(var t=[&quot;&quot;,&quot;Webkit&quot;,&quot;Moz&quot;,&quot;ms&quot;,&quot;O&quot;],r=0,a=t.length;a&gt;r;r++){var n;if(n=0===r?e:t[r]+e.replace(/^\w/,function(e){return e.toUpperCase()}),m.isString(b.State.prefixElement.style[n]))return b.State.prefixMatches[e]=n,[n,!0]}return[e,!1]}},Values:{hexToRgb:function(e){var t,r=/^#?([a-f\d])([a-f\d])([a-f\d])$/i,a=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;return e=e.replace(r,function(e,t,r,a){return t+t+r+r+a+a}),t=a.exec(e),t?[parseInt(t[1],16),parseInt(t[2],16),parseInt(t[3],16)]:[0,0,0]},isCSSNullValue:function(e){return 0==e||/^(none|auto|transparent|(rgba\(0, ?0, ?0, ?0\)))$/i.test(e)},getUnitType:function(e){return/^(rotate|skew)/i.test(e)?&quot;deg&quot;:/(^(scale|scaleX|scaleY|scaleZ|alpha|flexGrow|flexHeight|zIndex|fontWeight)$)|((opacity|red|green|blue|alpha)$)/i.test(e)?&quot;&quot;:&quot;px&quot;},getDisplayType:function(e){var t=e&amp;&amp;e.tagName.toString().toLowerCase();return/^(b|big|i|small|tt|abbr|acronym|cite|code|dfn|em|kbd|strong|samp|var|a|bdo|br|img|map|object|q|script|span|sub|sup|button|input|label|select|textarea)$/i.test(t)?&quot;inline&quot;:/^(li)$/i.test(t)?&quot;list-item&quot;:/^(tr)$/i.test(t)?&quot;table-row&quot;:/^(table)$/i.test(t)?&quot;table&quot;:/^(tbody)$/i.test(t)?&quot;table-row-group&quot;:&quot;block&quot;},addClass:function(e,t){e.classList?e.classList.add(t):e.className+=(e.className.length?&quot; &quot;:&quot;&quot;)+t},removeClass:function(e,t){e.classList?e.classList.remove(t):e.className=e.className.toString().replace(new RegExp(&quot;(^|\\s)&quot;+t.split(&quot; &quot;).join(&quot;|&quot;)+&quot;(\\s|$)&quot;,&quot;gi&quot;),&quot; &quot;)}},getPropertyValue:function(e,r,n,o){function s(e,r){function n(){u&amp;&amp;S.setPropertyValue(e,&quot;display&quot;,&quot;none&quot;)}var l=0;if(8&gt;=d)l=f.css(e,r);else{var u=!1;if(/^(width|height)$/.test(r)&amp;&amp;0===S.getPropertyValue(e,&quot;display&quot;)&amp;&amp;(u=!0,S.setPropertyValue(e,&quot;display&quot;,S.Values.getDisplayType(e))),!o){if(&quot;height&quot;===r&amp;&amp;&quot;border-box&quot;!==S.getPropertyValue(e,&quot;boxSizing&quot;).toString().toLowerCase()){var c=e.offsetHeight-(parseFloat(S.getPropertyValue(e,&quot;borderTopWidth&quot;))||0)-(parseFloat(S.getPropertyValue(e,&quot;borderBottomWidth&quot;))||0)-(parseFloat(S.getPropertyValue(e,&quot;paddingTop&quot;))||0)-(parseFloat(S.getPropertyValue(e,&quot;paddingBottom&quot;))||0);return n(),c}if(&quot;width&quot;===r&amp;&amp;&quot;border-box&quot;!==S.getPropertyValue(e,&quot;boxSizing&quot;).toString().toLowerCase()){var p=e.offsetWidth-(parseFloat(S.getPropertyValue(e,&quot;borderLeftWidth&quot;))||0)-(parseFloat(S.getPropertyValue(e,&quot;borderRightWidth&quot;))||0)-(parseFloat(S.getPropertyValue(e,&quot;paddingLeft&quot;))||0)-(parseFloat(S.getPropertyValue(e,&quot;paddingRight&quot;))||0);return n(),p}}var g;g=i(e)===a?t.getComputedStyle(e,null):i(e).computedStyle?i(e).computedStyle:i(e).computedStyle=t.getComputedStyle(e,null),&quot;borderColor&quot;===r&amp;&amp;(r=&quot;borderTopColor&quot;),l=9===d&amp;&amp;&quot;filter&quot;===r?g.getPropertyValue(r):g[r],(&quot;&quot;===l||null===l)&amp;&amp;(l=e.style[r]),n()}if(&quot;auto&quot;===l&amp;&amp;/^(top|right|bottom|left)$/i.test(r)){var m=s(e,&quot;position&quot;);(&quot;fixed&quot;===m||&quot;absolute&quot;===m&amp;&amp;/top|left/i.test(r))&amp;&amp;(l=f(e).position()[r]+&quot;px&quot;)}return l}var l;if(S.Hooks.registered[r]){var u=r,c=S.Hooks.getRoot(u);n===a&amp;&amp;(n=S.getPropertyValue(e,S.Names.prefixCheck(c)[0])),S.Normalizations.registered[c]&amp;&amp;(n=S.Normalizations.registered[c](&quot;extract&quot;,e,n)),l=S.Hooks.extractValue(u,n)}else if(S.Normalizations.registered[r]){var p,g;p=S.Normalizations.registered[r](&quot;name&quot;,e),&quot;transform&quot;!==p&amp;&amp;(g=s(e,S.Names.prefixCheck(p)[0]),S.Values.isCSSNullValue(g)&amp;&amp;S.Hooks.templates[r]&amp;&amp;(g=S.Hooks.templates[r][1])),l=S.Normalizations.registered[r](&quot;extract&quot;,e,g)}if(!/^[\d-]/.test(l))if(i(e)&amp;&amp;i(e).isSVG&amp;&amp;S.Names.SVGAttribute(r))if(/^(height|width)$/i.test(r))try{l=e.getBBox()[r]}catch(m){l=0}else l=e.getAttribute(r);else l=s(e,S.Names.prefixCheck(r)[0]);return S.Values.isCSSNullValue(l)&amp;&amp;(l=0),b.debug&gt;=2&amp;&amp;console.log(&quot;Get &quot;+r+&quot;: &quot;+l),l},setPropertyValue:function(e,r,a,n,o){var s=r;if(&quot;scroll&quot;===r)o.container?o.container[&quot;scroll&quot;+o.direction]=a:&quot;Left&quot;===o.direction?t.scrollTo(a,o.alternateValue):t.scrollTo(o.alternateValue,a);else if(S.Normalizations.registered[r]&amp;&amp;&quot;transform&quot;===S.Normalizations.registered[r](&quot;name&quot;,e))S.Normalizations.registered[r](&quot;inject&quot;,e,a),s=&quot;transform&quot;,a=i(e).transformCache[r];else{if(S.Hooks.registered[r]){var l=r,u=S.Hooks.getRoot(r);n=n||S.getPropertyValue(e,u),a=S.Hooks.injectValue(l,a,n),r=u}if(S.Normalizations.registered[r]&amp;&amp;(a=S.Normalizations.registered[r](&quot;inject&quot;,e,a),r=S.Normalizations.registered[r](&quot;name&quot;,e)),s=S.Names.prefixCheck(r)[0],8&gt;=d)try{e.style[s]=a}catch(c){b.debug&amp;&amp;console.log(&quot;Browser does not support [&quot;+a+&quot;] for [&quot;+s+&quot;]&quot;)}else i(e)&amp;&amp;i(e).isSVG&amp;&amp;S.Names.SVGAttribute(r)?e.setAttribute(r,a):e.style[s]=a;b.debug&gt;=2&amp;&amp;console.log(&quot;Set &quot;+r+&quot; (&quot;+s+&quot;): &quot;+a)}return[s,a]},flushTransformCache:function(e){function t(t){return parseFloat(S.getPropertyValue(e,t))}var r=&quot;&quot;;if((d||b.State.isAndroid&amp;&amp;!b.State.isChrome)&amp;&amp;i(e).isSVG){var a={translate:[t(&quot;translateX&quot;),t(&quot;translateY&quot;)],skewX:[t(&quot;skewX&quot;)],skewY:[t(&quot;skewY&quot;)],scale:1!==t(&quot;scale&quot;)?[t(&quot;scale&quot;),t(&quot;scale&quot;)]:[t(&quot;scaleX&quot;),t(&quot;scaleY&quot;)],rotate:[t(&quot;rotateZ&quot;),0,0]};f.each(i(e).transformCache,function(e){/^translate/i.test(e)?e=&quot;translate&quot;:/^scale/i.test(e)?e=&quot;scale&quot;:/^rotate/i.test(e)&amp;&amp;(e=&quot;rotate&quot;),a[e]&amp;&amp;(r+=e+&quot;(&quot;+a[e].join(&quot; &quot;)+&quot;) &quot;,delete a[e])})}else{var n,o;f.each(i(e).transformCache,function(t){return n=i(e).transformCache[t],&quot;transformPerspective&quot;===t?(o=n,!0):(9===d&amp;&amp;&quot;rotateZ&quot;===t&amp;&amp;(t=&quot;rotate&quot;),void(r+=t+n+&quot; &quot;))}),o&amp;&amp;(r=&quot;perspective&quot;+o+&quot; &quot;+r)}S.setPropertyValue(e,&quot;transform&quot;,r)}};S.Hooks.register(),S.Normalizations.register(),b.hook=function(e,t,r){var n=a;return e=o(e),f.each(e,function(e,o){if(i(o)===a&amp;&amp;b.init(o),r===a)n===a&amp;&amp;(n=b.CSS.getPropertyValue(o,t));else{var s=b.CSS.setPropertyValue(o,t,r);&quot;transform&quot;===s[0]&amp;&amp;b.CSS.flushTransformCache(o),n=s}}),n};var P=function(){function e(){return s?k.promise||null:l}function n(){function e(e){function p(e,t){var r=a,n=a,i=a;return m.isArray(e)?(r=e[0],!m.isArray(e[1])&amp;&amp;/^[\d-]/.test(e[1])||m.isFunction(e[1])||S.RegEx.isHex.test(e[1])?i=e[1]:(m.isString(e[1])&amp;&amp;!S.RegEx.isHex.test(e[1])||m.isArray(e[1]))&amp;&amp;(n=t?e[1]:u(e[1],s.duration),e[2]!==a&amp;&amp;(i=e[2]))):r=e,t||(n=n||s.easing),m.isFunction(r)&amp;&amp;(r=r.call(o,V,w)),m.isFunction(i)&amp;&amp;(i=i.call(o,V,w)),[r||0,n,i]}function d(e,t){var r,a;return a=(t||&quot;0&quot;).toString().toLowerCase().replace(/[%A-z]+$/,function(e){return r=e,&quot;&quot;}),r||(r=S.Values.getUnitType(e)),[a,r]}function h(){var e={myParent:o.parentNode||r.body,position:S.getPropertyValue(o,&quot;position&quot;),fontSize:S.getPropertyValue(o,&quot;fontSize&quot;)},a=e.position===L.lastPosition&amp;&amp;e.myParent===L.lastParent,n=e.fontSize===L.lastFontSize;L.lastParent=e.myParent,L.lastPosition=e.position,L.lastFontSize=e.fontSize;var s=100,l={};if(n&amp;&amp;a)l.emToPx=L.lastEmToPx,l.percentToPxWidth=L.lastPercentToPxWidth,l.percentToPxHeight=L.lastPercentToPxHeight;else{var u=i(o).isSVG?r.createElementNS(&quot;http://www.w3.org/2000/svg&quot;,&quot;rect&quot;):r.createElement(&quot;div&quot;);b.init(u),e.myParent.appendChild(u),f.each([&quot;overflow&quot;,&quot;overflowX&quot;,&quot;overflowY&quot;],function(e,t){b.CSS.setPropertyValue(u,t,&quot;hidden&quot;)}),b.CSS.setPropertyValue(u,&quot;position&quot;,e.position),b.CSS.setPropertyValue(u,&quot;fontSize&quot;,e.fontSize),b.CSS.setPropertyValue(u,&quot;boxSizing&quot;,&quot;content-box&quot;),f.each([&quot;minWidth&quot;,&quot;maxWidth&quot;,&quot;width&quot;,&quot;minHeight&quot;,&quot;maxHeight&quot;,&quot;height&quot;],function(e,t){b.CSS.setPropertyValue(u,t,s+&quot;%&quot;)}),b.CSS.setPropertyValue(u,&quot;paddingLeft&quot;,s+&quot;em&quot;),l.percentToPxWidth=L.lastPercentToPxWidth=(parseFloat(S.getPropertyValue(u,&quot;width&quot;,null,!0))||1)/s,l.percentToPxHeight=L.lastPercentToPxHeight=(parseFloat(S.getPropertyValue(u,&quot;height&quot;,null,!0))||1)/s,l.emToPx=L.lastEmToPx=(parseFloat(S.getPropertyValue(u,&quot;paddingLeft&quot;))||1)/s,e.myParent.removeChild(u)}return null===L.remToPx&amp;&amp;(L.remToPx=parseFloat(S.getPropertyValue(r.body,&quot;fontSize&quot;))||16),null===L.vwToPx&amp;&amp;(L.vwToPx=parseFloat(t.innerWidth)/100,L.vhToPx=parseFloat(t.innerHeight)/100),l.remToPx=L.remToPx,l.vwToPx=L.vwToPx,l.vhToPx=L.vhToPx,b.debug&gt;=1&amp;&amp;console.log(&quot;Unit ratios: &quot;+JSON.stringify(l),o),l}if(s.begin&amp;&amp;0===V)try{s.begin.call(g,g)}catch(x){setTimeout(function(){throw x},1)}if(&quot;scroll&quot;===A){var P,C,T,F=/^x$/i.test(s.axis)?&quot;Left&quot;:&quot;Top&quot;,j=parseFloat(s.offset)||0;s.container?m.isWrapped(s.container)||m.isNode(s.container)?(s.container=s.container[0]||s.container,P=s.container[&quot;scroll&quot;+F],T=P+f(o).position()[F.toLowerCase()]+j):s.container=null:(P=b.State.scrollAnchor[b.State[&quot;scrollProperty&quot;+F]],C=b.State.scrollAnchor[b.State[&quot;scrollProperty&quot;+(&quot;Left&quot;===F?&quot;Top&quot;:&quot;Left&quot;)]],T=f(o).offset()[F.toLowerCase()]+j),l={scroll:{rootPropertyValue:!1,startValue:P,currentValue:P,endValue:T,unitType:&quot;&quot;,easing:s.easing,scrollData:{container:s.container,direction:F,alternateValue:C}},element:o},b.debug&amp;&amp;console.log(&quot;tweensContainer (scroll): &quot;,l.scroll,o)}else if(&quot;reverse&quot;===A){if(!i(o).tweensContainer)return void f.dequeue(o,s.queue);&quot;none&quot;===i(o).opts.display&amp;&amp;(i(o).opts.display=&quot;auto&quot;),&quot;hidden&quot;===i(o).opts.visibility&amp;&amp;(i(o).opts.visibility=&quot;visible&quot;),i(o).opts.loop=!1,i(o).opts.begin=null,i(o).opts.complete=null,v.easing||delete s.easing,v.duration||delete s.duration,s=f.extend({},i(o).opts,s);var E=f.extend(!0,{},i(o).tweensContainer);for(var H in E)if(&quot;element&quot;!==H){var N=E[H].startValue;E[H].startValue=E[H].currentValue=E[H].endValue,E[H].endValue=N,m.isEmptyObject(v)||(E[H].easing=s.easing),b.debug&amp;&amp;console.log(&quot;reverse tweensContainer (&quot;+H+&quot;): &quot;+JSON.stringify(E[H]),o)}l=E}else if(&quot;start&quot;===A){var E;i(o).tweensContainer&amp;&amp;i(o).isAnimating===!0&amp;&amp;(E=i(o).tweensContainer),f.each(y,function(e,t){if(RegExp(&quot;^&quot;+S.Lists.colors.join(&quot;$|^&quot;)+&quot;$&quot;).test(e)){var r=p(t,!0),n=r[0],o=r[1],i=r[2];if(S.RegEx.isHex.test(n)){for(var s=[&quot;Red&quot;,&quot;Green&quot;,&quot;Blue&quot;],l=S.Values.hexToRgb(n),u=i?S.Values.hexToRgb(i):a,c=0;c&lt;s.length;c++){var f=[l[c]];o&amp;&amp;f.push(o),u!==a&amp;&amp;f.push(u[c]),y[e+s[c]]=f}delete y[e]}}});for(var z in y){var O=p(y[z]),q=O[0],$=O[1],M=O[2];z=S.Names.camelCase(z);var I=S.Hooks.getRoot(z),B=!1;if(i(o).isSVG||&quot;tween&quot;===I||S.Names.prefixCheck(I)[1]!==!1||S.Normalizations.registered[I]!==a){(s.display!==a&amp;&amp;null!==s.display&amp;&amp;&quot;none&quot;!==s.display||s.visibility!==a&amp;&amp;&quot;hidden&quot;!==s.visibility)&amp;&amp;/opacity|filter/.test(z)&amp;&amp;!M&amp;&amp;0!==q&amp;&amp;(M=0),s._cacheValues&amp;&amp;E&amp;&amp;E[z]?(M===a&amp;&amp;(M=E[z].endValue+E[z].unitType),B=i(o).rootPropertyValueCache[I]):S.Hooks.registered[z]?M===a?(B=S.getPropertyValue(o,I),M=S.getPropertyValue(o,z,B)):B=S.Hooks.templates[I][1]:M===a&amp;&amp;(M=S.getPropertyValue(o,z));var W,G,Y,D=!1;if(W=d(z,M),M=W[0],Y=W[1],W=d(z,q),q=W[0].replace(/^([+-\/*])=/,function(e,t){return D=t,&quot;&quot;}),G=W[1],M=parseFloat(M)||0,q=parseFloat(q)||0,&quot;%&quot;===G&amp;&amp;(/^(fontSize|lineHeight)$/.test(z)?(q/=100,G=&quot;em&quot;):/^scale/.test(z)?(q/=100,G=&quot;&quot;):/(Red|Green|Blue)$/i.test(z)&amp;&amp;(q=q/100*255,G=&quot;&quot;)),/[\/*]/.test(D))G=Y;else if(Y!==G&amp;&amp;0!==M)if(0===q)G=Y;else{n=n||h();var Q=/margin|padding|left|right|width|text|word|letter/i.test(z)||/X$/.test(z)||&quot;x&quot;===z?&quot;x&quot;:&quot;y&quot;;switch(Y){case&quot;%&quot;:M*=&quot;x&quot;===Q?n.percentToPxWidth:n.percentToPxHeight;break;case&quot;px&quot;:break;default:M*=n[Y+&quot;ToPx&quot;]}switch(G){case&quot;%&quot;:M*=1/(&quot;x&quot;===Q?n.percentToPxWidth:n.percentToPxHeight);break;case&quot;px&quot;:break;default:M*=1/n[G+&quot;ToPx&quot;]}}switch(D){case&quot;+&quot;:q=M+q;break;case&quot;-&quot;:q=M-q;break;case&quot;*&quot;:q=M*q;break;case&quot;/&quot;:q=M/q}l[z]={rootPropertyValue:B,startValue:M,currentValue:M,endValue:q,unitType:G,easing:$},b.debug&amp;&amp;console.log(&quot;tweensContainer (&quot;+z+&quot;): &quot;+JSON.stringify(l[z]),o)}else b.debug&amp;&amp;console.log(&quot;Skipping [&quot;+I+&quot;] due to a lack of browser support.&quot;)}l.element=o}l.element&amp;&amp;(S.Values.addClass(o,&quot;velocity-animating&quot;),R.push(l),&quot;&quot;===s.queue&amp;&amp;(i(o).tweensContainer=l,i(o).opts=s),i(o).isAnimating=!0,V===w-1?(b.State.calls.push([R,g,s,null,k.resolver]),b.State.isTicking===!1&amp;&amp;(b.State.isTicking=!0,c())):V++)}var n,o=this,s=f.extend({},b.defaults,v),l={};switch(i(o)===a&amp;&amp;b.init(o),parseFloat(s.delay)&amp;&amp;s.queue!==!1&amp;&amp;f.queue(o,s.queue,function(e){b.velocityQueueEntryFlag=!0,i(o).delayTimer={setTimeout:setTimeout(e,parseFloat(s.delay)),next:e}}),s.duration.toString().toLowerCase()){case&quot;fast&quot;:s.duration=200;break;case&quot;normal&quot;:s.duration=h;break;case&quot;slow&quot;:s.duration=600;break;default:s.duration=parseFloat(s.duration)||1}b.mock!==!1&amp;&amp;(b.mock===!0?s.duration=s.delay=1:(s.duration*=parseFloat(b.mock)||1,s.delay*=parseFloat(b.mock)||1)),s.easing=u(s.easing,s.duration),s.begin&amp;&amp;!m.isFunction(s.begin)&amp;&amp;(s.begin=null),s.progress&amp;&amp;!m.isFunction(s.progress)&amp;&amp;(s.progress=null),s.complete&amp;&amp;!m.isFunction(s.complete)&amp;&amp;(s.complete=null),s.display!==a&amp;&amp;null!==s.display&amp;&amp;(s.display=s.display.toString().toLowerCase(),&quot;auto&quot;===s.display&amp;&amp;(s.display=b.CSS.Values.getDisplayType(o))),s.visibility!==a&amp;&amp;null!==s.visibility&amp;&amp;(s.visibility=s.visibility.toString().toLowerCase()),s.mobileHA=s.mobileHA&amp;&amp;b.State.isMobile&amp;&amp;!b.State.isGingerbread,s.queue===!1?s.delay?setTimeout(e,s.delay):e():f.queue(o,s.queue,function(t,r){return r===!0?(k.promise&amp;&amp;k.resolver(g),!0):(b.velocityQueueEntryFlag=!0,void e(t))}),&quot;&quot;!==s.queue&amp;&amp;&quot;fx&quot;!==s.queue||&quot;inprogress&quot;===f.queue(o)[0]||f.dequeue(o)}var s,l,d,g,y,v,x=arguments[0]&amp;&amp;(arguments[0].p||f.isPlainObject(arguments[0].properties)&amp;&amp;!arguments[0].properties.names||m.isString(arguments[0].properties));if(m.isWrapped(this)?(s=!1,d=0,g=this,l=this):(s=!0,d=1,g=x?arguments[0].elements||arguments[0].e:arguments[0]),g=o(g)){x?(y=arguments[0].properties||arguments[0].p,v=arguments[0].options||arguments[0].o):(y=arguments[d],v=arguments[d+1]);var w=g.length,V=0;if(!/^(stop|finish)$/i.test(y)&amp;&amp;!f.isPlainObject(v)){var C=d+1;v={};for(var T=C;T&lt;arguments.length;T++)m.isArray(arguments[T])||!/^(fast|normal|slow)$/i.test(arguments[T])&amp;&amp;!/^\d/.test(arguments[T])?m.isString(arguments[T])||m.isArray(arguments[T])?v.easing=arguments[T]:m.isFunction(arguments[T])&amp;&amp;(v.complete=arguments[T]):v.duration=arguments[T]}var k={promise:null,resolver:null,rejecter:null};s&amp;&amp;b.Promise&amp;&amp;(k.promise=new b.Promise(function(e,t){k.resolver=e,k.rejecter=t}));var A;switch(y){case&quot;scroll&quot;:A=&quot;scroll&quot;;break;case&quot;reverse&quot;:A=&quot;reverse&quot;;break;case&quot;finish&quot;:case&quot;stop&quot;:f.each(g,function(e,t){i(t)&amp;&amp;i(t).delayTimer&amp;&amp;(clearTimeout(i(t).delayTimer.setTimeout),i(t).delayTimer.next&amp;&amp;i(t).delayTimer.next(),delete i(t).delayTimer)});var F=[];return f.each(b.State.calls,function(e,t){t&amp;&amp;f.each(t[1],function(r,n){var o=v===a?&quot;&quot;:v;return o===!0||t[2].queue===o||v===a&amp;&amp;t[2].queue===!1?void f.each(g,function(r,a){a===n&amp;&amp;((v===!0||m.isString(v))&amp;&amp;(f.each(f.queue(a,m.isString(v)?v:&quot;&quot;),function(e,t){
m.isFunction(t)&amp;&amp;t(null,!0)}),f.queue(a,m.isString(v)?v:&quot;&quot;,[])),&quot;stop&quot;===y?(i(a)&amp;&amp;i(a).tweensContainer&amp;&amp;o!==!1&amp;&amp;f.each(i(a).tweensContainer,function(e,t){t.endValue=t.currentValue}),F.push(e)):&quot;finish&quot;===y&amp;&amp;(t[2].duration=1))}):!0})}),&quot;stop&quot;===y&amp;&amp;(f.each(F,function(e,t){p(t,!0)}),k.promise&amp;&amp;k.resolver(g)),e();default:if(!f.isPlainObject(y)||m.isEmptyObject(y)){if(m.isString(y)&amp;&amp;b.Redirects[y]){var j=f.extend({},v),E=j.duration,H=j.delay||0;return j.backwards===!0&amp;&amp;(g=f.extend(!0,[],g).reverse()),f.each(g,function(e,t){parseFloat(j.stagger)?j.delay=H+parseFloat(j.stagger)*e:m.isFunction(j.stagger)&amp;&amp;(j.delay=H+j.stagger.call(t,e,w)),j.drag&amp;&amp;(j.duration=parseFloat(E)||(/^(callout|transition)/.test(y)?1e3:h),j.duration=Math.max(j.duration*(j.backwards?1-e/w:(e+1)/w),.75*j.duration,200)),b.Redirects[y].call(t,t,j||{},e,w,g,k.promise?k:a)}),e()}var N=&quot;Velocity: First argument (&quot;+y+&quot;) was not a property map, a known action, or a registered redirect. Aborting.&quot;;return k.promise?k.rejecter(new Error(N)):console.log(N),e()}A=&quot;start&quot;}var L={lastParent:null,lastPosition:null,lastFontSize:null,lastPercentToPxWidth:null,lastPercentToPxHeight:null,lastEmToPx:null,remToPx:null,vwToPx:null,vhToPx:null},R=[];f.each(g,function(e,t){m.isNode(t)&amp;&amp;n.call(t)});var z,j=f.extend({},b.defaults,v);if(j.loop=parseInt(j.loop),z=2*j.loop-1,j.loop)for(var O=0;z&gt;O;O++){var q={delay:j.delay,progress:j.progress};O===z-1&amp;&amp;(q.display=j.display,q.visibility=j.visibility,q.complete=j.complete),P(g,&quot;reverse&quot;,q)}return e()}};b=f.extend(P,b),b.animate=P;var w=t.requestAnimationFrame||g;return b.State.isMobile||r.hidden===a||r.addEventListener(&quot;visibilitychange&quot;,function(){r.hidden?(w=function(e){return setTimeout(function(){e(!0)},16)},c()):w=t.requestAnimationFrame||g}),e.Velocity=b,e!==t&amp;&amp;(e.fn.velocity=P,e.fn.velocity.defaults=b.defaults),f.each([&quot;Down&quot;,&quot;Up&quot;],function(e,t){b.Redirects[&quot;slide&quot;+t]=function(e,r,n,o,i,s){var l=f.extend({},r),u=l.begin,c=l.complete,p={height:&quot;&quot;,marginTop:&quot;&quot;,marginBottom:&quot;&quot;,paddingTop:&quot;&quot;,paddingBottom:&quot;&quot;},d={};l.display===a&amp;&amp;(l.display=&quot;Down&quot;===t?&quot;inline&quot;===b.CSS.Values.getDisplayType(e)?&quot;inline-block&quot;:&quot;block&quot;:&quot;none&quot;),l.begin=function(){u&amp;&amp;u.call(i,i);for(var r in p){d[r]=e.style[r];var a=b.CSS.getPropertyValue(e,r);p[r]=&quot;Down&quot;===t?[a,0]:[0,a]}d.overflow=e.style.overflow,e.style.overflow=&quot;hidden&quot;},l.complete=function(){for(var t in d)e.style[t]=d[t];c&amp;&amp;c.call(i,i),s&amp;&amp;s.resolver(i)},b(e,p,l)}}),f.each([&quot;In&quot;,&quot;Out&quot;],function(e,t){b.Redirects[&quot;fade&quot;+t]=function(e,r,n,o,i,s){var l=f.extend({},r),u={opacity:&quot;In&quot;===t?1:0},c=l.complete;l.complete=n!==o-1?l.begin=null:function(){c&amp;&amp;c.call(i,i),s&amp;&amp;s.resolver(i)},l.display===a&amp;&amp;(l.display=&quot;In&quot;===t?&quot;auto&quot;:&quot;none&quot;),b(this,u,l)}}),b}(window.jQuery||window.Zepto||window,window,document)}));
;!function(a,b,c,d){&quot;use strict&quot;;function k(a,b,c){return setTimeout(q(a,c),b)}function l(a,b,c){return Array.isArray(a)?(m(a,c[b],c),!0):!1}function m(a,b,c){var e;if(a)if(a.forEach)a.forEach(b,c);else if(a.length!==d)for(e=0;e&lt;a.length;)b.call(c,a[e],e,a),e++;else for(e in a)a.hasOwnProperty(e)&amp;&amp;b.call(c,a[e],e,a)}function n(a,b,c){for(var e=Object.keys(b),f=0;f&lt;e.length;)(!c||c&amp;&amp;a[e[f]]===d)&amp;&amp;(a[e[f]]=b[e[f]]),f++;return a}function o(a,b){return n(a,b,!0)}function p(a,b,c){var e,d=b.prototype;e=a.prototype=Object.create(d),e.constructor=a,e._super=d,c&amp;&amp;n(e,c)}function q(a,b){return function(){return a.apply(b,arguments)}}function r(a,b){return typeof a==g?a.apply(b?b[0]||d:d,b):a}function s(a,b){return a===d?b:a}function t(a,b,c){m(x(b),function(b){a.addEventListener(b,c,!1)})}function u(a,b,c){m(x(b),function(b){a.removeEventListener(b,c,!1)})}function v(a,b){for(;a;){if(a==b)return!0;a=a.parentNode}return!1}function w(a,b){return a.indexOf(b)&gt;-1}function x(a){return a.trim().split(/\s+/g)}function y(a,b,c){if(a.indexOf&amp;&amp;!c)return a.indexOf(b);for(var d=0;d&lt;a.length;){if(c&amp;&amp;a[d][c]==b||!c&amp;&amp;a[d]===b)return d;d++}return-1}function z(a){return Array.prototype.slice.call(a,0)}function A(a,b,c){for(var d=[],e=[],f=0;f&lt;a.length;){var g=b?a[f][b]:a[f];y(e,g)&lt;0&amp;&amp;d.push(a[f]),e[f]=g,f++}return c&amp;&amp;(d=b?d.sort(function(a,c){return a[b]&gt;c[b]}):d.sort()),d}function B(a,b){for(var c,f,g=b[0].toUpperCase()+b.slice(1),h=0;h&lt;e.length;){if(c=e[h],f=c?c+g:b,f in a)return f;h++}return d}function D(){return C++}function E(a){var b=a.ownerDocument;return b.defaultView||b.parentWindow}function ab(a,b){var c=this;this.manager=a,this.callback=b,this.element=a.element,this.target=a.options.inputTarget,this.domHandler=function(b){r(a.options.enable,[a])&amp;&amp;c.handler(b)},this.init()}function bb(a){var b,c=a.options.inputClass;return b=c?c:H?wb:I?Eb:G?Gb:rb,new b(a,cb)}function cb(a,b,c){var d=c.pointers.length,e=c.changedPointers.length,f=b&amp;O&amp;&amp;0===d-e,g=b&amp;(Q|R)&amp;&amp;0===d-e;c.isFirst=!!f,c.isFinal=!!g,f&amp;&amp;(a.session={}),c.eventType=b,db(a,c),a.emit(&quot;hammer.input&quot;,c),a.recognize(c),a.session.prevInput=c}function db(a,b){var c=a.session,d=b.pointers,e=d.length;c.firstInput||(c.firstInput=gb(b)),e&gt;1&amp;&amp;!c.firstMultiple?c.firstMultiple=gb(b):1===e&amp;&amp;(c.firstMultiple=!1);var f=c.firstInput,g=c.firstMultiple,h=g?g.center:f.center,i=b.center=hb(d);b.timeStamp=j(),b.deltaTime=b.timeStamp-f.timeStamp,b.angle=lb(h,i),b.distance=kb(h,i),eb(c,b),b.offsetDirection=jb(b.deltaX,b.deltaY),b.scale=g?nb(g.pointers,d):1,b.rotation=g?mb(g.pointers,d):0,fb(c,b);var k=a.element;v(b.srcEvent.target,k)&amp;&amp;(k=b.srcEvent.target),b.target=k}function eb(a,b){var c=b.center,d=a.offsetDelta||{},e=a.prevDelta||{},f=a.prevInput||{};(b.eventType===O||f.eventType===Q)&amp;&amp;(e=a.prevDelta={x:f.deltaX||0,y:f.deltaY||0},d=a.offsetDelta={x:c.x,y:c.y}),b.deltaX=e.x+(c.x-d.x),b.deltaY=e.y+(c.y-d.y)}function fb(a,b){var f,g,h,j,c=a.lastInterval||b,e=b.timeStamp-c.timeStamp;if(b.eventType!=R&amp;&amp;(e&gt;N||c.velocity===d)){var k=c.deltaX-b.deltaX,l=c.deltaY-b.deltaY,m=ib(e,k,l);g=m.x,h=m.y,f=i(m.x)&gt;i(m.y)?m.x:m.y,j=jb(k,l),a.lastInterval=b}else f=c.velocity,g=c.velocityX,h=c.velocityY,j=c.direction;b.velocity=f,b.velocityX=g,b.velocityY=h,b.direction=j}function gb(a){for(var b=[],c=0;c&lt;a.pointers.length;)b[c]={clientX:h(a.pointers[c].clientX),clientY:h(a.pointers[c].clientY)},c++;return{timeStamp:j(),pointers:b,center:hb(b),deltaX:a.deltaX,deltaY:a.deltaY}}function hb(a){var b=a.length;if(1===b)return{x:h(a[0].clientX),y:h(a[0].clientY)};for(var c=0,d=0,e=0;b&gt;e;)c+=a[e].clientX,d+=a[e].clientY,e++;return{x:h(c/b),y:h(d/b)}}function ib(a,b,c){return{x:b/a||0,y:c/a||0}}function jb(a,b){return a===b?S:i(a)&gt;=i(b)?a&gt;0?T:U:b&gt;0?V:W}function kb(a,b,c){c||(c=$);var d=b[c[0]]-a[c[0]],e=b[c[1]]-a[c[1]];return Math.sqrt(d*d+e*e)}function lb(a,b,c){c||(c=$);var d=b[c[0]]-a[c[0]],e=b[c[1]]-a[c[1]];return 180*Math.atan2(e,d)/Math.PI}function mb(a,b){return lb(b[1],b[0],_)-lb(a[1],a[0],_)}function nb(a,b){return kb(b[0],b[1],_)/kb(a[0],a[1],_)}function rb(){this.evEl=pb,this.evWin=qb,this.allow=!0,this.pressed=!1,ab.apply(this,arguments)}function wb(){this.evEl=ub,this.evWin=vb,ab.apply(this,arguments),this.store=this.manager.session.pointerEvents=[]}function Ab(){this.evTarget=yb,this.evWin=zb,this.started=!1,ab.apply(this,arguments)}function Bb(a,b){var c=z(a.touches),d=z(a.changedTouches);return b&amp;(Q|R)&amp;&amp;(c=A(c.concat(d),&quot;identifier&quot;,!0)),[c,d]}function Eb(){this.evTarget=Db,this.targetIds={},ab.apply(this,arguments)}function Fb(a,b){var c=z(a.touches),d=this.targetIds;if(b&amp;(O|P)&amp;&amp;1===c.length)return d[c[0].identifier]=!0,[c,c];var e,f,g=z(a.changedTouches),h=[],i=this.target;if(f=c.filter(function(a){return v(a.target,i)}),b===O)for(e=0;e&lt;f.length;)d[f[e].identifier]=!0,e++;for(e=0;e&lt;g.length;)d[g[e].identifier]&amp;&amp;h.push(g[e]),b&amp;(Q|R)&amp;&amp;delete d[g[e].identifier],e++;return h.length?[A(f.concat(h),&quot;identifier&quot;,!0),h]:void 0}function Gb(){ab.apply(this,arguments);var a=q(this.handler,this);this.touch=new Eb(this.manager,a),this.mouse=new rb(this.manager,a)}function Pb(a,b){this.manager=a,this.set(b)}function Qb(a){if(w(a,Mb))return Mb;var b=w(a,Nb),c=w(a,Ob);return b&amp;&amp;c?Nb+&quot; &quot;+Ob:b||c?b?Nb:Ob:w(a,Lb)?Lb:Kb}function Yb(a){this.id=D(),this.manager=null,this.options=o(a||{},this.defaults),this.options.enable=s(this.options.enable,!0),this.state=Rb,this.simultaneous={},this.requireFail=[]}function Zb(a){return a&amp;Wb?&quot;cancel&quot;:a&amp;Ub?&quot;end&quot;:a&amp;Tb?&quot;move&quot;:a&amp;Sb?&quot;start&quot;:&quot;&quot;}function $b(a){return a==W?&quot;down&quot;:a==V?&quot;up&quot;:a==T?&quot;left&quot;:a==U?&quot;right&quot;:&quot;&quot;}function _b(a,b){var c=b.manager;return c?c.get(a):a}function ac(){Yb.apply(this,arguments)}function bc(){ac.apply(this,arguments),this.pX=null,this.pY=null}function cc(){ac.apply(this,arguments)}function dc(){Yb.apply(this,arguments),this._timer=null,this._input=null}function ec(){ac.apply(this,arguments)}function fc(){ac.apply(this,arguments)}function gc(){Yb.apply(this,arguments),this.pTime=!1,this.pCenter=!1,this._timer=null,this._input=null,this.count=0}function hc(a,b){return b=b||{},b.recognizers=s(b.recognizers,hc.defaults.preset),new kc(a,b)}function kc(a,b){b=b||{},this.options=o(b,hc.defaults),this.options.inputTarget=this.options.inputTarget||a,this.handlers={},this.session={},this.recognizers=[],this.element=a,this.input=bb(this),this.touchAction=new Pb(this,this.options.touchAction),lc(this,!0),m(b.recognizers,function(a){var b=this.add(new a[0](a[1]));a[2]&amp;&amp;b.recognizeWith(a[2]),a[3]&amp;&amp;b.requireFailure(a[3])},this)}function lc(a,b){var c=a.element;m(a.options.cssProps,function(a,d){c.style[B(c.style,d)]=b?a:&quot;&quot;})}function mc(a,c){var d=b.createEvent(&quot;Event&quot;);d.initEvent(a,!0,!0),d.gesture=c,c.target.dispatchEvent(d)}var e=[&quot;&quot;,&quot;webkit&quot;,&quot;moz&quot;,&quot;MS&quot;,&quot;ms&quot;,&quot;o&quot;],f=b.createElement(&quot;div&quot;),g=&quot;function&quot;,h=Math.round,i=Math.abs,j=Date.now,C=1,F=/mobile|tablet|ip(ad|hone|od)|android/i,G=&quot;ontouchstart&quot;in a,H=B(a,&quot;PointerEvent&quot;)!==d,I=G&amp;&amp;F.test(navigator.userAgent),J=&quot;touch&quot;,K=&quot;pen&quot;,L=&quot;mouse&quot;,M=&quot;kinect&quot;,N=25,O=1,P=2,Q=4,R=8,S=1,T=2,U=4,V=8,W=16,X=T|U,Y=V|W,Z=X|Y,$=[&quot;x&quot;,&quot;y&quot;],_=[&quot;clientX&quot;,&quot;clientY&quot;];ab.prototype={handler:function(){},init:function(){this.evEl&amp;&amp;t(this.element,this.evEl,this.domHandler),this.evTarget&amp;&amp;t(this.target,this.evTarget,this.domHandler),this.evWin&amp;&amp;t(E(this.element),this.evWin,this.domHandler)},destroy:function(){this.evEl&amp;&amp;u(this.element,this.evEl,this.domHandler),this.evTarget&amp;&amp;u(this.target,this.evTarget,this.domHandler),this.evWin&amp;&amp;u(E(this.element),this.evWin,this.domHandler)}};var ob={mousedown:O,mousemove:P,mouseup:Q},pb=&quot;mousedown&quot;,qb=&quot;mousemove mouseup&quot;;p(rb,ab,{handler:function(a){var b=ob[a.type];b&amp;O&amp;&amp;0===a.button&amp;&amp;(this.pressed=!0),b&amp;P&amp;&amp;1!==a.which&amp;&amp;(b=Q),this.pressed&amp;&amp;this.allow&amp;&amp;(b&amp;Q&amp;&amp;(this.pressed=!1),this.callback(this.manager,b,{pointers:[a],changedPointers:[a],pointerType:L,srcEvent:a}))}});var sb={pointerdown:O,pointermove:P,pointerup:Q,pointercancel:R,pointerout:R},tb={2:J,3:K,4:L,5:M},ub=&quot;pointerdown&quot;,vb=&quot;pointermove pointerup pointercancel&quot;;a.MSPointerEvent&amp;&amp;(ub=&quot;MSPointerDown&quot;,vb=&quot;MSPointerMove MSPointerUp MSPointerCancel&quot;),p(wb,ab,{handler:function(a){var b=this.store,c=!1,d=a.type.toLowerCase().replace(&quot;ms&quot;,&quot;&quot;),e=sb[d],f=tb[a.pointerType]||a.pointerType,g=f==J,h=y(b,a.pointerId,&quot;pointerId&quot;);e&amp;O&amp;&amp;(0===a.button||g)?0&gt;h&amp;&amp;(b.push(a),h=b.length-1):e&amp;(Q|R)&amp;&amp;(c=!0),0&gt;h||(b[h]=a,this.callback(this.manager,e,{pointers:b,changedPointers:[a],pointerType:f,srcEvent:a}),c&amp;&amp;b.splice(h,1))}});var xb={touchstart:O,touchmove:P,touchend:Q,touchcancel:R},yb=&quot;touchstart&quot;,zb=&quot;touchstart touchmove touchend touchcancel&quot;;p(Ab,ab,{handler:function(a){var b=xb[a.type];if(b===O&amp;&amp;(this.started=!0),this.started){var c=Bb.call(this,a,b);b&amp;(Q|R)&amp;&amp;0===c[0].length-c[1].length&amp;&amp;(this.started=!1),this.callback(this.manager,b,{pointers:c[0],changedPointers:c[1],pointerType:J,srcEvent:a})}}});var Cb={touchstart:O,touchmove:P,touchend:Q,touchcancel:R},Db=&quot;touchstart touchmove touchend touchcancel&quot;;p(Eb,ab,{handler:function(a){var b=Cb[a.type],c=Fb.call(this,a,b);c&amp;&amp;this.callback(this.manager,b,{pointers:c[0],changedPointers:c[1],pointerType:J,srcEvent:a})}}),p(Gb,ab,{handler:function(a,b,c){var d=c.pointerType==J,e=c.pointerType==L;if(d)this.mouse.allow=!1;else if(e&amp;&amp;!this.mouse.allow)return;b&amp;(Q|R)&amp;&amp;(this.mouse.allow=!0),this.callback(a,b,c)},destroy:function(){this.touch.destroy(),this.mouse.destroy()}});var Hb=B(f.style,&quot;touchAction&quot;),Ib=Hb!==d,Jb=&quot;compute&quot;,Kb=&quot;auto&quot;,Lb=&quot;manipulation&quot;,Mb=&quot;none&quot;,Nb=&quot;pan-x&quot;,Ob=&quot;pan-y&quot;;Pb.prototype={set:function(a){a==Jb&amp;&amp;(a=this.compute()),Ib&amp;&amp;(this.manager.element.style[Hb]=a),this.actions=a.toLowerCase().trim()},update:function(){this.set(this.manager.options.touchAction)},compute:function(){var a=[];return m(this.manager.recognizers,function(b){r(b.options.enable,[b])&amp;&amp;(a=a.concat(b.getTouchAction()))}),Qb(a.join(&quot; &quot;))},preventDefaults:function(a){if(!Ib){var b=a.srcEvent,c=a.offsetDirection;if(this.manager.session.prevented)return b.preventDefault(),void 0;var d=this.actions,e=w(d,Mb),f=w(d,Ob),g=w(d,Nb);return e||f&amp;&amp;c&amp;X||g&amp;&amp;c&amp;Y?this.preventSrc(b):void 0}},preventSrc:function(a){this.manager.session.prevented=!0,a.preventDefault()}};var Rb=1,Sb=2,Tb=4,Ub=8,Vb=Ub,Wb=16,Xb=32;Yb.prototype={defaults:{},set:function(a){return n(this.options,a),this.manager&amp;&amp;this.manager.touchAction.update(),this},recognizeWith:function(a){if(l(a,&quot;recognizeWith&quot;,this))return this;var b=this.simultaneous;return a=_b(a,this),b[a.id]||(b[a.id]=a,a.recognizeWith(this)),this},dropRecognizeWith:function(a){return l(a,&quot;dropRecognizeWith&quot;,this)?this:(a=_b(a,this),delete this.simultaneous[a.id],this)},requireFailure:function(a){if(l(a,&quot;requireFailure&quot;,this))return this;var b=this.requireFail;return a=_b(a,this),-1===y(b,a)&amp;&amp;(b.push(a),a.requireFailure(this)),this},dropRequireFailure:function(a){if(l(a,&quot;dropRequireFailure&quot;,this))return this;a=_b(a,this);var b=y(this.requireFail,a);return b&gt;-1&amp;&amp;this.requireFail.splice(b,1),this},hasRequireFailures:function(){return this.requireFail.length&gt;0},canRecognizeWith:function(a){return!!this.simultaneous[a.id]},emit:function(a){function d(d){b.manager.emit(b.options.event+(d?Zb(c):&quot;&quot;),a)}var b=this,c=this.state;Ub&gt;c&amp;&amp;d(!0),d(),c&gt;=Ub&amp;&amp;d(!0)},tryEmit:function(a){return this.canEmit()?this.emit(a):(this.state=Xb,void 0)},canEmit:function(){for(var a=0;a&lt;this.requireFail.length;){if(!(this.requireFail[a].state&amp;(Xb|Rb)))return!1;a++}return!0},recognize:function(a){var b=n({},a);return r(this.options.enable,[this,b])?(this.state&amp;(Vb|Wb|Xb)&amp;&amp;(this.state=Rb),this.state=this.process(b),this.state&amp;(Sb|Tb|Ub|Wb)&amp;&amp;this.tryEmit(b),void 0):(this.reset(),this.state=Xb,void 0)},process:function(){},getTouchAction:function(){},reset:function(){}},p(ac,Yb,{defaults:{pointers:1},attrTest:function(a){var b=this.options.pointers;return 0===b||a.pointers.length===b},process:function(a){var b=this.state,c=a.eventType,d=b&amp;(Sb|Tb),e=this.attrTest(a);return d&amp;&amp;(c&amp;R||!e)?b|Wb:d||e?c&amp;Q?b|Ub:b&amp;Sb?b|Tb:Sb:Xb}}),p(bc,ac,{defaults:{event:&quot;pan&quot;,threshold:10,pointers:1,direction:Z},getTouchAction:function(){var a=this.options.direction,b=[];return a&amp;X&amp;&amp;b.push(Ob),a&amp;Y&amp;&amp;b.push(Nb),b},directionTest:function(a){var b=this.options,c=!0,d=a.distance,e=a.direction,f=a.deltaX,g=a.deltaY;return e&amp;b.direction||(b.direction&amp;X?(e=0===f?S:0&gt;f?T:U,c=f!=this.pX,d=Math.abs(a.deltaX)):(e=0===g?S:0&gt;g?V:W,c=g!=this.pY,d=Math.abs(a.deltaY))),a.direction=e,c&amp;&amp;d&gt;b.threshold&amp;&amp;e&amp;b.direction},attrTest:function(a){return ac.prototype.attrTest.call(this,a)&amp;&amp;(this.state&amp;Sb||!(this.state&amp;Sb)&amp;&amp;this.directionTest(a))},emit:function(a){this.pX=a.deltaX,this.pY=a.deltaY;var b=$b(a.direction);b&amp;&amp;this.manager.emit(this.options.event+b,a),this._super.emit.call(this,a)}}),p(cc,ac,{defaults:{event:&quot;pinch&quot;,threshold:0,pointers:2},getTouchAction:function(){return[Mb]},attrTest:function(a){return this._super.attrTest.call(this,a)&amp;&amp;(Math.abs(a.scale-1)&gt;this.options.threshold||this.state&amp;Sb)},emit:function(a){if(this._super.emit.call(this,a),1!==a.scale){var b=a.scale&lt;1?&quot;in&quot;:&quot;out&quot;;this.manager.emit(this.options.event+b,a)}}}),p(dc,Yb,{defaults:{event:&quot;press&quot;,pointers:1,time:500,threshold:5},getTouchAction:function(){return[Kb]},process:function(a){var b=this.options,c=a.pointers.length===b.pointers,d=a.distance&lt;b.threshold,e=a.deltaTime&gt;b.time;if(this._input=a,!d||!c||a.eventType&amp;(Q|R)&amp;&amp;!e)this.reset();else if(a.eventType&amp;O)this.reset(),this._timer=k(function(){this.state=Vb,this.tryEmit()},b.time,this);else if(a.eventType&amp;Q)return Vb;return Xb},reset:function(){clearTimeout(this._timer)},emit:function(a){this.state===Vb&amp;&amp;(a&amp;&amp;a.eventType&amp;Q?this.manager.emit(this.options.event+&quot;up&quot;,a):(this._input.timeStamp=j(),this.manager.emit(this.options.event,this._input)))}}),p(ec,ac,{defaults:{event:&quot;rotate&quot;,threshold:0,pointers:2},getTouchAction:function(){return[Mb]},attrTest:function(a){return this._super.attrTest.call(this,a)&amp;&amp;(Math.abs(a.rotation)&gt;this.options.threshold||this.state&amp;Sb)}}),p(fc,ac,{defaults:{event:&quot;swipe&quot;,threshold:10,velocity:.65,direction:X|Y,pointers:1},getTouchAction:function(){return bc.prototype.getTouchAction.call(this)},attrTest:function(a){var c,b=this.options.direction;return b&amp;(X|Y)?c=a.velocity:b&amp;X?c=a.velocityX:b&amp;Y&amp;&amp;(c=a.velocityY),this._super.attrTest.call(this,a)&amp;&amp;b&amp;a.direction&amp;&amp;a.distance&gt;this.options.threshold&amp;&amp;i(c)&gt;this.options.velocity&amp;&amp;a.eventType&amp;Q},emit:function(a){var b=$b(a.direction);b&amp;&amp;this.manager.emit(this.options.event+b,a),this.manager.emit(this.options.event,a)}}),p(gc,Yb,{defaults:{event:&quot;tap&quot;,pointers:1,taps:1,interval:300,time:250,threshold:2,posThreshold:10},getTouchAction:function(){return[Lb]},process:function(a){var b=this.options,c=a.pointers.length===b.pointers,d=a.distance&lt;b.threshold,e=a.deltaTime&lt;b.time;if(this.reset(),a.eventType&amp;O&amp;&amp;0===this.count)return this.failTimeout();if(d&amp;&amp;e&amp;&amp;c){if(a.eventType!=Q)return this.failTimeout();var f=this.pTime?a.timeStamp-this.pTime&lt;b.interval:!0,g=!this.pCenter||kb(this.pCenter,a.center)&lt;b.posThreshold;this.pTime=a.timeStamp,this.pCenter=a.center,g&amp;&amp;f?this.count+=1:this.count=1,this._input=a;var h=this.count%b.taps;if(0===h)return this.hasRequireFailures()?(this._timer=k(function(){this.state=Vb,this.tryEmit()},b.interval,this),Sb):Vb}return Xb},failTimeout:function(){return this._timer=k(function(){this.state=Xb},this.options.interval,this),Xb},reset:function(){clearTimeout(this._timer)},emit:function(){this.state==Vb&amp;&amp;(this._input.tapCount=this.count,this.manager.emit(this.options.event,this._input))}}),hc.VERSION=&quot;2.0.4&quot;,hc.defaults={domEvents:!1,touchAction:Jb,enable:!0,inputTarget:null,inputClass:null,preset:[[ec,{enable:!1}],[cc,{enable:!1},[&quot;rotate&quot;]],[fc,{direction:X}],[bc,{direction:X},[&quot;swipe&quot;]],[gc],[gc,{event:&quot;doubletap&quot;,taps:2},[&quot;tap&quot;]],[dc]],cssProps:{userSelect:&quot;default&quot;,touchSelect:&quot;none&quot;,touchCallout:&quot;none&quot;,contentZooming:&quot;none&quot;,userDrag:&quot;none&quot;,tapHighlightColor:&quot;rgba(0,0,0,0)&quot;}};var ic=1,jc=2;kc.prototype={set:function(a){return n(this.options,a),a.touchAction&amp;&amp;this.touchAction.update(),a.inputTarget&amp;&amp;(this.input.destroy(),this.input.target=a.inputTarget,this.input.init()),this},stop:function(a){this.session.stopped=a?jc:ic},recognize:function(a){var b=this.session;if(!b.stopped){this.touchAction.preventDefaults(a);var c,d=this.recognizers,e=b.curRecognizer;(!e||e&amp;&amp;e.state&amp;Vb)&amp;&amp;(e=b.curRecognizer=null);for(var f=0;f&lt;d.length;)c=d[f],b.stopped===jc||e&amp;&amp;c!=e&amp;&amp;!c.canRecognizeWith(e)?c.reset():c.recognize(a),!e&amp;&amp;c.state&amp;(Sb|Tb|Ub)&amp;&amp;(e=b.curRecognizer=c),f++}},get:function(a){if(a instanceof Yb)return a;for(var b=this.recognizers,c=0;c&lt;b.length;c++)if(b[c].options.event==a)return b[c];return null},add:function(a){if(l(a,&quot;add&quot;,this))return this;var b=this.get(a.options.event);return b&amp;&amp;this.remove(b),this.recognizers.push(a),a.manager=this,this.touchAction.update(),a},remove:function(a){if(l(a,&quot;remove&quot;,this))return this;var b=this.recognizers;return a=this.get(a),b.splice(y(b,a),1),this.touchAction.update(),this},on:function(a,b){var c=this.handlers;return m(x(a),function(a){c[a]=c[a]||[],c[a].push(b)}),this},off:function(a,b){var c=this.handlers;return m(x(a),function(a){b?c[a].splice(y(c[a],b),1):delete c[a]}),this},emit:function(a,b){this.options.domEvents&amp;&amp;mc(a,b);var c=this.handlers[a]&amp;&amp;this.handlers[a].slice();if(c&amp;&amp;c.length){b.type=a,b.preventDefault=function(){b.srcEvent.preventDefault()};for(var d=0;d&lt;c.length;)c[d](b),d++}},destroy:function(){this.element&amp;&amp;lc(this,!1),this.handlers={},this.session={},this.input.destroy(),this.element=null}},n(hc,{INPUT_START:O,INPUT_MOVE:P,INPUT_END:Q,INPUT_CANCEL:R,STATE_POSSIBLE:Rb,STATE_BEGAN:Sb,STATE_CHANGED:Tb,STATE_ENDED:Ub,STATE_RECOGNIZED:Vb,STATE_CANCELLED:Wb,STATE_FAILED:Xb,DIRECTION_NONE:S,DIRECTION_LEFT:T,DIRECTION_RIGHT:U,DIRECTION_UP:V,DIRECTION_DOWN:W,DIRECTION_HORIZONTAL:X,DIRECTION_VERTICAL:Y,DIRECTION_ALL:Z,Manager:kc,Input:ab,TouchAction:Pb,TouchInput:Eb,MouseInput:rb,PointerEventInput:wb,TouchMouseInput:Gb,SingleTouchInput:Ab,Recognizer:Yb,AttrRecognizer:ac,Tap:gc,Pan:bc,Swipe:fc,Pinch:cc,Rotate:ec,Press:dc,on:t,off:u,each:m,merge:o,extend:n,inherit:p,bindFn:q,prefixed:B}),typeof define==g&amp;&amp;define.amd?define(function(){return hc}):&quot;undefined&quot;!=typeof module&amp;&amp;module.exports?module.exports=hc:a[c]=hc}(window,document,&quot;Hammer&quot;);;(function(factory) {
    if (typeof define === &#x27;function&#x27; &amp;&amp; define.amd) {
        define([&#x27;jquery&#x27;, &#x27;hammerjs&#x27;], factory);
    } else if (typeof exports === &#x27;object&#x27;) {
        factory(require(&#x27;jquery&#x27;), require(&#x27;hammerjs&#x27;));
    } else {
        factory(jQuery, Hammer);
    }
}(function($, Hammer) {
    function hammerify(el, options) {
        var $el = $(el);
        if(!$el.data(&quot;hammer&quot;)) {
            $el.data(&quot;hammer&quot;, new Hammer($el[0], options));
        }
    }

    $.fn.hammer = function(options) {
        return this.each(function() {
            hammerify(this, options);
        });
    };

    // extend the emit method to also trigger jQuery events
    Hammer.Manager.prototype.emit = (function(originalEmit) {
        return function(type, data) {
            originalEmit.call(this, type, data);
            $(this.element).trigger({
                type: type,
                gesture: data
            });
        };
    })(Hammer.Manager.prototype.emit);
}));
;// Required for Meteor package, the use of window prevents export by Meteor
(function(window){
  if(window.Package){
    Materialize = {};
  } else {
    window.Materialize = {};
  }
})(window);


/*
 * raf.js
 * https://github.com/ngryman/raf.js
 *
 * original requestAnimationFrame polyfill by Erik Möller
 * inspired from paul_irish gist and post
 *
 * Copyright (c) 2013 ngryman
 * Licensed under the MIT license.
 */
(function(window) {
  var lastTime = 0,
    vendors = [&#x27;webkit&#x27;, &#x27;moz&#x27;],
    requestAnimationFrame = window.requestAnimationFrame,
    cancelAnimationFrame = window.cancelAnimationFrame,
    i = vendors.length;

  // try to un-prefix existing raf
  while (--i &gt;= 0 &amp;&amp; !requestAnimationFrame) {
    requestAnimationFrame = window[vendors[i] + &#x27;RequestAnimationFrame&#x27;];
    cancelAnimationFrame = window[vendors[i] + &#x27;CancelRequestAnimationFrame&#x27;];
  }

  // polyfill with setTimeout fallback
  // heavily inspired from @darius gist mod: https://gist.github.com/paulirish/1579671#comment-837945
  if (!requestAnimationFrame || !cancelAnimationFrame) {
    requestAnimationFrame = function(callback) {
      var now = +Date.now(),
        nextTime = Math.max(lastTime + 16, now);
      return setTimeout(function() {
        callback(lastTime = nextTime);
      }, nextTime - now);
    };

    cancelAnimationFrame = clearTimeout;
  }

  // export to window
  window.requestAnimationFrame = requestAnimationFrame;
  window.cancelAnimationFrame = cancelAnimationFrame;
}(window));


// Unique ID
Materialize.guid = (function() {
  function s4() {
    return Math.floor((1 + Math.random()) * 0x10000)
      .toString(16)
      .substring(1);
  }
  return function() {
    return s4() + s4() + &#x27;-&#x27; + s4() + &#x27;-&#x27; + s4() + &#x27;-&#x27; +
           s4() + &#x27;-&#x27; + s4() + s4() + s4();
  };
})();

/**
 * Escapes hash from special characters
 * @param {string} hash  String returned from this.hash
 * @returns {string}
 */
Materialize.escapeHash = function(hash) {
  return hash.replace( /(:|\.|\[|\]|,|=)/g, &quot;\\$1&quot; );
};

Materialize.elementOrParentIsFixed = function(element) {
    var $element = $(element);
    var $checkElements = $element.add($element.parents());
    var isFixed = false;
    $checkElements.each(function(){
        if ($(this).css(&quot;position&quot;) === &quot;fixed&quot;) {
            isFixed = true;
            return false;
        }
    });
    return isFixed;
};


/**
 * Get time in ms
 * @license https://raw.github.com/jashkenas/underscore/master/LICENSE
 * @type {function}
 * @return {number}
 */
var getTime = (Date.now || function () {
  return new Date().getTime();
});


/**
 * Returns a function, that, when invoked, will only be triggered at most once
 * during a given window of time. Normally, the throttled function will run
 * as much as it can, without ever going more than once per &#x60;wait&#x60; duration;
 * but if you&#x27;d like to disable the execution on the leading edge, pass
 * &#x60;{leading: false}&#x60;. To disable execution on the trailing edge, ditto.
 * @license https://raw.github.com/jashkenas/underscore/master/LICENSE
 * @param {function} func
 * @param {number} wait
 * @param {Object=} options
 * @returns {Function}
 */
Materialize.throttle = function(func, wait, options) {
  var context, args, result;
  var timeout = null;
  var previous = 0;
  options || (options = {});
  var later = function () {
    previous = options.leading === false ? 0 : getTime();
    timeout = null;
    result = func.apply(context, args);
    context = args = null;
  };
  return function () {
    var now = getTime();
    if (!previous &amp;&amp; options.leading === false) previous = now;
    var remaining = wait - (now - previous);
    context = this;
    args = arguments;
    if (remaining &lt;= 0) {
      clearTimeout(timeout);
      timeout = null;
      previous = now;
      result = func.apply(context, args);
      context = args = null;
    } else if (!timeout &amp;&amp; options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result;
  };
};


// Velocity has conflicts when loaded with jQuery, this will check for it
// First, check if in noConflict mode
var Vel;
if (jQuery) {
  Vel = jQuery.Velocity;
} else if ($) {
  Vel = $.Velocity;
} else {
  Vel = Velocity;
}
;(function ($) {
  $.fn.collapsible = function(options) {
    var defaults = {
      accordion: undefined,
      onOpen: undefined,
      onClose: undefined
    };

    options = $.extend(defaults, options);


    return this.each(function() {

      var $this = $(this);

      var $panel_headers = $(this).find(&#x27;&gt; li &gt; .collapsible-header&#x27;);

      var collapsible_type = $this.data(&quot;collapsible&quot;);

      // Turn off any existing event handlers
      $this.off(&#x27;click.collapse&#x27;, &#x27;&gt; li &gt; .collapsible-header&#x27;);
      $panel_headers.off(&#x27;click.collapse&#x27;);


      /****************
      Helper Functions
      ****************/

      // Accordion Open
      function accordionOpen(object) {
        $panel_headers = $this.find(&#x27;&gt; li &gt; .collapsible-header&#x27;);
        if (object.hasClass(&#x27;active&#x27;)) {
          object.parent().addClass(&#x27;active&#x27;);
        }
        else {
          object.parent().removeClass(&#x27;active&#x27;);
        }
        if (object.parent().hasClass(&#x27;active&#x27;)){
          object.siblings(&#x27;.collapsible-body&#x27;).stop(true,false).slideDown({ duration: 350, easing: &quot;easeOutQuart&quot;, queue: false, complete: function() {$(this).css(&#x27;height&#x27;, &#x27;&#x27;);}});
        }
        else{
          object.siblings(&#x27;.collapsible-body&#x27;).stop(true,false).slideUp({ duration: 350, easing: &quot;easeOutQuart&quot;, queue: false, complete: function() {$(this).css(&#x27;height&#x27;, &#x27;&#x27;);}});
        }

        $panel_headers.not(object).removeClass(&#x27;active&#x27;).parent().removeClass(&#x27;active&#x27;);

        // Close previously open accordion elements.
        $panel_headers.not(object).parent().children(&#x27;.collapsible-body&#x27;).stop(true,false).each(function() {
          if ($(this).is(&#x27;:visible&#x27;)) {
            $(this).slideUp({
              duration: 350,
              easing: &quot;easeOutQuart&quot;,
              queue: false,
              complete:
                function() {
                  $(this).css(&#x27;height&#x27;, &#x27;&#x27;);
                  execCallbacks($(this).siblings(&#x27;.collapsible-header&#x27;));
                }
            });
          }
        });
      }

      // Expandable Open
      function expandableOpen(object) {
        if (object.hasClass(&#x27;active&#x27;)) {
          object.parent().addClass(&#x27;active&#x27;);
        }
        else {
          object.parent().removeClass(&#x27;active&#x27;);
        }
        if (object.parent().hasClass(&#x27;active&#x27;)){
          object.siblings(&#x27;.collapsible-body&#x27;).stop(true,false).slideDown({ duration: 350, easing: &quot;easeOutQuart&quot;, queue: false, complete: function() {$(this).css(&#x27;height&#x27;, &#x27;&#x27;);}});
        }
        else {
          object.siblings(&#x27;.collapsible-body&#x27;).stop(true,false).slideUp({ duration: 350, easing: &quot;easeOutQuart&quot;, queue: false, complete: function() {$(this).css(&#x27;height&#x27;, &#x27;&#x27;);}});
        }
      }

      // Open collapsible. object: .collapsible-header
      function collapsibleOpen(object) {
        if (options.accordion || collapsible_type === &quot;accordion&quot; || collapsible_type === undefined) { // Handle Accordion
          accordionOpen(object);
        } else { // Handle Expandables
          expandableOpen(object);
        }

        execCallbacks(object);
      }

      // Handle callbacks
      function execCallbacks(object) {
        if (object.hasClass(&#x27;active&#x27;)) {
          if (typeof(options.onOpen) === &quot;function&quot;) {
            options.onOpen.call(this, object.parent());
          }
        } else {
          if (typeof(options.onClose) === &quot;function&quot;) {
            options.onClose.call(this, object.parent());
          }
        }
      }

      /**
       * Check if object is children of panel header
       * @param  {Object}  object Jquery object
       * @return {Boolean} true if it is children
       */
      function isChildrenOfPanelHeader(object) {

        var panelHeader = getPanelHeader(object);

        return panelHeader.length &gt; 0;
      }

      /**
       * Get panel header from a children element
       * @param  {Object} object Jquery object
       * @return {Object} panel header object
       */
      function getPanelHeader(object) {

        return object.closest(&#x27;li &gt; .collapsible-header&#x27;);
      }

      /*****  End Helper Functions  *****/



      // Add click handler to only direct collapsible header children
      $this.on(&#x27;click.collapse&#x27;, &#x27;&gt; li &gt; .collapsible-header&#x27;, function(e) {
        var element = $(e.target);

        if (isChildrenOfPanelHeader(element)) {
          element = getPanelHeader(element);
        }

        element.toggleClass(&#x27;active&#x27;);

        collapsibleOpen(element);
      });


      // Open first active
      if (options.accordion || collapsible_type === &quot;accordion&quot; || collapsible_type === undefined) { // Handle Accordion
        collapsibleOpen($panel_headers.filter(&#x27;.active&#x27;).first());

      } else { // Handle Expandables
        $panel_headers.filter(&#x27;.active&#x27;).each(function() {
          collapsibleOpen($(this));
        });
      }

    });
  };

  $(document).ready(function(){
    $(&#x27;.collapsible&#x27;).collapsible();
  });
}( jQuery ));;(function ($) {

  // Add posibility to scroll to selected option
  // usefull for select for example
  $.fn.scrollTo = function(elem) {
    $(this).scrollTop($(this).scrollTop() - $(this).offset().top + $(elem).offset().top);
    return this;
  };

  $.fn.dropdown = function (options) {
    var defaults = {
      inDuration: 300,
      outDuration: 225,
      constrainWidth: true, // Constrains width of dropdown to the activator
      hover: false,
      gutter: 0, // Spacing from edge
      belowOrigin: false,
      alignment: &#x27;left&#x27;,
      stopPropagation: false
    };

    // Open dropdown.
    if (options === &quot;open&quot;) {
      this.each(function() {
        $(this).trigger(&#x27;open&#x27;);
      });
      return false;
    }

    // Close dropdown.
    if (options === &quot;close&quot;) {
      this.each(function() {
        $(this).trigger(&#x27;close&#x27;);
      });
      return false;
    }

    this.each(function(){
      var origin = $(this);
      var curr_options = $.extend({}, defaults, options);
      var isFocused = false;

      // Dropdown menu
      var activates = $(&quot;#&quot;+ origin.attr(&#x27;data-activates&#x27;));

      function updateOptions() {
        if (origin.data(&#x27;induration&#x27;) !== undefined)
          curr_options.inDuration = origin.data(&#x27;induration&#x27;);
        if (origin.data(&#x27;outduration&#x27;) !== undefined)
          curr_options.outDuration = origin.data(&#x27;outduration&#x27;);
        if (origin.data(&#x27;constrainwidth&#x27;) !== undefined)
          curr_options.constrainWidth = origin.data(&#x27;constrainwidth&#x27;);
        if (origin.data(&#x27;hover&#x27;) !== undefined)
          curr_options.hover = origin.data(&#x27;hover&#x27;);
        if (origin.data(&#x27;gutter&#x27;) !== undefined)
          curr_options.gutter = origin.data(&#x27;gutter&#x27;);
        if (origin.data(&#x27;beloworigin&#x27;) !== undefined)
          curr_options.belowOrigin = origin.data(&#x27;beloworigin&#x27;);
        if (origin.data(&#x27;alignment&#x27;) !== undefined)
          curr_options.alignment = origin.data(&#x27;alignment&#x27;);
        if (origin.data(&#x27;stoppropagation&#x27;) !== undefined)
          curr_options.stopPropagation = origin.data(&#x27;stoppropagation&#x27;);
      }

      updateOptions();

      // Attach dropdown to its activator
      origin.after(activates);

      /*
        Helper function to position and resize dropdown.
        Used in hover and click handler.
      */
      function placeDropdown(eventType) {
        // Check for simultaneous focus and click events.
        if (eventType === &#x27;focus&#x27;) {
          isFocused = true;
        }

        // Check html data attributes
        updateOptions();

        // Set Dropdown state
        activates.addClass(&#x27;active&#x27;);
        origin.addClass(&#x27;active&#x27;);

        // Constrain width
        if (curr_options.constrainWidth === true) {
          activates.css(&#x27;width&#x27;, origin.outerWidth());

        } else {
          activates.css(&#x27;white-space&#x27;, &#x27;nowrap&#x27;);
        }

        // Offscreen detection
        var windowHeight = window.innerHeight;
        var originHeight = origin.innerHeight();
        var offsetLeft = origin.offset().left;
        var offsetTop = origin.offset().top - $(window).scrollTop();
        var currAlignment = curr_options.alignment;
        var gutterSpacing = 0;
        var leftPosition = 0;

        // Below Origin
        var verticalOffset = 0;
        if (curr_options.belowOrigin === true) {
          verticalOffset = originHeight;
        }

        // Check for scrolling positioned container.
        var scrollYOffset = 0;
        var scrollXOffset = 0;
        var wrapper = origin.parent();
        if (!wrapper.is(&#x27;body&#x27;)) {
          if (wrapper[0].scrollHeight &gt; wrapper[0].clientHeight) {
            scrollYOffset = wrapper[0].scrollTop;
          }
          if (wrapper[0].scrollWidth &gt; wrapper[0].clientWidth) {
            scrollXOffset = wrapper[0].scrollLeft;
          }
        }


        if (offsetLeft + activates.innerWidth() &gt; $(window).width()) {
          // Dropdown goes past screen on right, force right alignment
          currAlignment = &#x27;right&#x27;;

        } else if (offsetLeft - activates.innerWidth() + origin.innerWidth() &lt; 0) {
          // Dropdown goes past screen on left, force left alignment
          currAlignment = &#x27;left&#x27;;
        }
        // Vertical bottom offscreen detection
        if (offsetTop + activates.innerHeight() &gt; windowHeight) {
          // If going upwards still goes offscreen, just crop height of dropdown.
          if (offsetTop + originHeight - activates.innerHeight() &lt; 0) {
            var adjustedHeight = windowHeight - offsetTop - verticalOffset;
            activates.css(&#x27;max-height&#x27;, adjustedHeight);
          } else {
            // Flow upwards.
            if (!verticalOffset) {
              verticalOffset += originHeight;
            }
            verticalOffset -= activates.innerHeight();
          }
        }

        // Handle edge alignment
        if (currAlignment === &#x27;left&#x27;) {
          gutterSpacing = curr_options.gutter;
          leftPosition = origin.position().left + gutterSpacing;
        }
        else if (currAlignment === &#x27;right&#x27;) {
          var offsetRight = origin.position().left + origin.outerWidth() - activates.outerWidth();
          gutterSpacing = -curr_options.gutter;
          leftPosition =  offsetRight + gutterSpacing;
        }

        // Position dropdown
        activates.css({
          position: &#x27;absolute&#x27;,
          top: origin.position().top + verticalOffset + scrollYOffset,
          left: leftPosition + scrollXOffset
        });


        // Show dropdown
        activates.stop(true, true).css(&#x27;opacity&#x27;, 0)
          .slideDown({
            queue: false,
            duration: curr_options.inDuration,
            easing: &#x27;easeOutCubic&#x27;,
            complete: function() {
              $(this).css(&#x27;height&#x27;, &#x27;&#x27;);
            }
          })
          .animate( {opacity: 1}, {queue: false, duration: curr_options.inDuration, easing: &#x27;easeOutSine&#x27;});

        // Add click close handler to document
        $(document).bind(&#x27;click.&#x27;+ activates.attr(&#x27;id&#x27;) + &#x27; touchstart.&#x27; + activates.attr(&#x27;id&#x27;), function (e) {
          if (!activates.is(e.target) &amp;&amp; !origin.is(e.target) &amp;&amp; (!origin.find(e.target).length) ) {
            hideDropdown();
            $(document).unbind(&#x27;click.&#x27;+ activates.attr(&#x27;id&#x27;) + &#x27; touchstart.&#x27; + activates.attr(&#x27;id&#x27;));
          }
        });
      }

      function hideDropdown() {
        // Check for simultaneous focus and click events.
        isFocused = false;
        activates.fadeOut(curr_options.outDuration);
        activates.removeClass(&#x27;active&#x27;);
        origin.removeClass(&#x27;active&#x27;);
        $(document).unbind(&#x27;click.&#x27;+ activates.attr(&#x27;id&#x27;) + &#x27; touchstart.&#x27; + activates.attr(&#x27;id&#x27;));
        setTimeout(function() { activates.css(&#x27;max-height&#x27;, &#x27;&#x27;); }, curr_options.outDuration);
      }

      // Hover
      if (curr_options.hover) {
        var open = false;
        origin.unbind(&#x27;click.&#x27; + origin.attr(&#x27;id&#x27;));
        // Hover handler to show dropdown
        origin.on(&#x27;mouseenter&#x27;, function(e){ // Mouse over
          if (open === false) {
            placeDropdown();
            open = true;
          }
        });
        origin.on(&#x27;mouseleave&#x27;, function(e){
          // If hover on origin then to something other than dropdown content, then close
          var toEl = e.toElement || e.relatedTarget; // added browser compatibility for target element
          if(!$(toEl).closest(&#x27;.dropdown-content&#x27;).is(activates)) {
            activates.stop(true, true);
            hideDropdown();
            open = false;
          }
        });

        activates.on(&#x27;mouseleave&#x27;, function(e){ // Mouse out
          var toEl = e.toElement || e.relatedTarget;
          if(!$(toEl).closest(&#x27;.dropdown-button&#x27;).is(origin)) {
            activates.stop(true, true);
            hideDropdown();
            open = false;
          }
        });

        // Click
      } else {
        // Click handler to show dropdown
        origin.unbind(&#x27;click.&#x27; + origin.attr(&#x27;id&#x27;));
        origin.bind(&#x27;click.&#x27;+origin.attr(&#x27;id&#x27;), function(e){
          if (!isFocused) {
            if ( origin[0] == e.currentTarget &amp;&amp;
                 !origin.hasClass(&#x27;active&#x27;) &amp;&amp;
                 ($(e.target).closest(&#x27;.dropdown-content&#x27;).length === 0)) {
              e.preventDefault(); // Prevents button click from moving window
              if (curr_options.stopPropagation) {
                e.stopPropagation();
              }
              placeDropdown(&#x27;click&#x27;);
            }
            // If origin is clicked and menu is open, close menu
            else if (origin.hasClass(&#x27;active&#x27;)) {
              hideDropdown();
              $(document).unbind(&#x27;click.&#x27;+ activates.attr(&#x27;id&#x27;) + &#x27; touchstart.&#x27; + activates.attr(&#x27;id&#x27;));
            }
          }
        });

      } // End else

      // Listen to open and close event - useful for select component
      origin.on(&#x27;open&#x27;, function(e, eventType) {
        placeDropdown(eventType);
      });
      origin.on(&#x27;close&#x27;, hideDropdown);


    });
  }; // End dropdown plugin

  $(document).ready(function(){
    $(&#x27;.dropdown-button&#x27;).dropdown();
  });
}( jQuery ));
;(function($) {
  var _stack = 0,
  _lastID = 0,
  _generateID = function() {
    _lastID++;
    return &#x27;materialize-modal-overlay-&#x27; + _lastID;
  };

  var methods = {
    init : function(options) {
      var defaults = {
        opacity: 0.5,
        inDuration: 350,
        outDuration: 250,
        ready: undefined,
        complete: undefined,
        dismissible: true,
        startingTop: &#x27;4%&#x27;,
        endingTop: &#x27;10%&#x27;
      };

      // Override defaults
      options = $.extend(defaults, options);

      return this.each(function() {
        var $modal = $(this);
        var modal_id = $(this).attr(&quot;id&quot;) || &#x27;#&#x27; + $(this).data(&#x27;target&#x27;);

        var closeModal = function() {
          var overlayID = $modal.data(&#x27;overlay-id&#x27;);
          var $overlay = $(&#x27;#&#x27; + overlayID);
          $modal.removeClass(&#x27;open&#x27;);

          // Enable scrolling
          $(&#x27;body&#x27;).css({
            overflow: &#x27;&#x27;,
            width: &#x27;&#x27;
          });

          $modal.find(&#x27;.modal-close&#x27;).off(&#x27;click.close&#x27;);
          $(document).off(&#x27;keyup.modal&#x27; + overlayID);

          $overlay.velocity( { opacity: 0}, {duration: options.outDuration, queue: false, ease: &quot;easeOutQuart&quot;});


          // Define Bottom Sheet animation
          var exitVelocityOptions = {
            duration: options.outDuration,
            queue: false,
            ease: &quot;easeOutCubic&quot;,
            // Handle modal ready callback
            complete: function() {
              $(this).css({display:&quot;none&quot;});

              // Call complete callback
              if (typeof(options.complete) === &quot;function&quot;) {
                options.complete.call(this, $modal);
              }
              $overlay.remove();
              _stack--;
            }
          };
          if ($modal.hasClass(&#x27;bottom-sheet&#x27;)) {
            $modal.velocity({bottom: &quot;-100%&quot;, opacity: 0}, exitVelocityOptions);
          }
          else {
            $modal.velocity(
              { top: options.startingTop, opacity: 0, scaleX: 0.7},
              exitVelocityOptions
            );
          }
        };

        var openModal = function($trigger) {
          var $body = $(&#x27;body&#x27;);
          var oldWidth = $body.innerWidth();
          $body.css(&#x27;overflow&#x27;, &#x27;hidden&#x27;);
          $body.width(oldWidth);

          if ($modal.hasClass(&#x27;open&#x27;)) {
            return;
          }

          var overlayID = _generateID();
          var $overlay = $(&#x27;&lt;div class=&quot;modal-overlay&quot;&gt;&lt;/div&gt;&#x27;);
          lStack = (++_stack);

          // Store a reference of the overlay
          $overlay.attr(&#x27;id&#x27;, overlayID).css(&#x27;z-index&#x27;, 1000 + lStack * 2);
          $modal.data(&#x27;overlay-id&#x27;, overlayID).css(&#x27;z-index&#x27;, 1000 + lStack * 2 + 1);
          $modal.addClass(&#x27;open&#x27;);

          $(&quot;body&quot;).append($overlay);

          if (options.dismissible) {
            $overlay.click(function() {
              closeModal();
            });
            // Return on ESC
            $(document).on(&#x27;keyup.modal&#x27; + overlayID, function(e) {
              if (e.keyCode === 27) {   // ESC key
                closeModal();
              }
            });
          }

          $modal.find(&quot;.modal-close&quot;).on(&#x27;click.close&#x27;, function(e) {
            closeModal();
          });

          $overlay.css({ display : &quot;block&quot;, opacity : 0 });

          $modal.css({
            display : &quot;block&quot;,
            opacity: 0
          });

          $overlay.velocity({opacity: options.opacity}, {duration: options.inDuration, queue: false, ease: &quot;easeOutCubic&quot;});
          $modal.data(&#x27;associated-overlay&#x27;, $overlay[0]);

          // Define Bottom Sheet animation
          var enterVelocityOptions = {
            duration: options.inDuration,
            queue: false,
            ease: &quot;easeOutCubic&quot;,
            // Handle modal ready callback
            complete: function() {
              if (typeof(options.ready) === &quot;function&quot;) {
                options.ready.call(this, $modal, $trigger);
              }
            }
          };
          if ($modal.hasClass(&#x27;bottom-sheet&#x27;)) {
            $modal.velocity({bottom: &quot;0&quot;, opacity: 1}, enterVelocityOptions);
          }
          else {
            $.Velocity.hook($modal, &quot;scaleX&quot;, 0.7);
            $modal.css({ top: options.startingTop });
            $modal.velocity({top: options.endingTop, opacity: 1, scaleX: &#x27;1&#x27;}, enterVelocityOptions);
          }

        };

        // Reset handlers
        $(document).off(&#x27;click.modalTrigger&#x27;, &#x27;a[href=&quot;#&#x27; + modal_id + &#x27;&quot;], [data-target=&quot;&#x27; + modal_id + &#x27;&quot;]&#x27;);
        $(this).off(&#x27;openModal&#x27;);
        $(this).off(&#x27;closeModal&#x27;);

        // Close Handlers
        $(document).on(&#x27;click.modalTrigger&#x27;, &#x27;a[href=&quot;#&#x27; + modal_id + &#x27;&quot;], [data-target=&quot;&#x27; + modal_id + &#x27;&quot;]&#x27;, function(e) {
          options.startingTop = ($(this).offset().top - $(window).scrollTop()) /1.15;
          openModal($(this));
          e.preventDefault();
        }); // done set on click

        $(this).on(&#x27;openModal&#x27;, function() {
          var modal_id = $(this).attr(&quot;href&quot;) || &#x27;#&#x27; + $(this).data(&#x27;target&#x27;);
          openModal();
        });

        $(this).on(&#x27;closeModal&#x27;, function() {
          closeModal();
        });
      }); // done return
    },
    open : function() {
      $(this).trigger(&#x27;openModal&#x27;);
    },
    close : function() {
      $(this).trigger(&#x27;closeModal&#x27;);
    }
  };

  $.fn.modal = function(methodOrOptions) {
    if ( methods[methodOrOptions] ) {
      return methods[ methodOrOptions ].apply( this, Array.prototype.slice.call( arguments, 1 ));
    } else if ( typeof methodOrOptions === &#x27;object&#x27; || ! methodOrOptions ) {
      // Default to &quot;init&quot;
      return methods.init.apply( this, arguments );
    } else {
      $.error( &#x27;Method &#x27; +  methodOrOptions + &#x27; does not exist on jQuery.modal&#x27; );
    }
  };
})(jQuery);
;(function ($) {

  $.fn.materialbox = function () {

    return this.each(function() {

      if ($(this).hasClass(&#x27;initialized&#x27;)) {
        return;
      }

      $(this).addClass(&#x27;initialized&#x27;);

      var overlayActive = false;
      var doneAnimating = true;
      var inDuration = 275;
      var outDuration = 200;
      var origin = $(this);
      var placeholder = $(&#x27;&lt;div&gt;&lt;/div&gt;&#x27;).addClass(&#x27;material-placeholder&#x27;);
      var originalWidth = 0;
      var originalHeight = 0;
      var ancestorsChanged;
      var ancestor;
      origin.wrap(placeholder);


      origin.on(&#x27;click&#x27;, function(){
        var placeholder = origin.parent(&#x27;.material-placeholder&#x27;);
        var windowWidth = window.innerWidth;
        var windowHeight = window.innerHeight;
        var originalWidth = origin.width();
        var originalHeight = origin.height();


        // If already modal, return to original
        if (doneAnimating === false) {
          returnToOriginal();
          return false;
        }
        else if (overlayActive &amp;&amp; doneAnimating===true) {
          returnToOriginal();
          return false;
        }


        // Set states
        doneAnimating = false;
        origin.addClass(&#x27;active&#x27;);
        overlayActive = true;

        // Set positioning for placeholder
        placeholder.css({
          width: placeholder[0].getBoundingClientRect().width,
          height: placeholder[0].getBoundingClientRect().height,
          position: &#x27;relative&#x27;,
          top: 0,
          left: 0
        });

        // Find ancestor with overflow: hidden; and remove it
        ancestorsChanged = undefined;
        ancestor = placeholder[0].parentNode;
        var count = 0;
        while (ancestor !== null &amp;&amp; !$(ancestor).is(document)) {
          var curr = $(ancestor);
          if (curr.css(&#x27;overflow&#x27;) !== &#x27;visible&#x27;) {
            curr.css(&#x27;overflow&#x27;, &#x27;visible&#x27;);
            if (ancestorsChanged === undefined) {
              ancestorsChanged = curr;
            }
            else {
              ancestorsChanged = ancestorsChanged.add(curr);
            }
          }
          ancestor = ancestor.parentNode;
        }

        // Set css on origin
        origin.css({
          position: &#x27;absolute&#x27;,
          &#x27;z-index&#x27;: 1000,
          &#x27;will-change&#x27;: &#x27;left, top, width, height&#x27;
        })
        .data(&#x27;width&#x27;, originalWidth)
        .data(&#x27;height&#x27;, originalHeight);

        // Add overlay
        var overlay = $(&#x27;&lt;div id=&quot;materialbox-overlay&quot;&gt;&lt;/div&gt;&#x27;)
          .css({
            opacity: 0
          })
          .click(function(){
            if (doneAnimating === true)
            returnToOriginal();
          });

        // Put before in origin image to preserve z-index layering.
        origin.before(overlay);

        // Set dimensions if needed
        var overlayOffset = overlay[0].getBoundingClientRect();
        overlay.css({
          width: windowWidth,
          height: windowHeight,
          left: -1 * overlayOffset.left,
          top: -1 * overlayOffset.top
        })

        // Animate Overlay
        overlay.velocity({opacity: 1},
                           {duration: inDuration, queue: false, easing: &#x27;easeOutQuad&#x27;} );

        // Add and animate caption if it exists
        if (origin.data(&#x27;caption&#x27;) !== &quot;&quot;) {
          var $photo_caption = $(&#x27;&lt;div class=&quot;materialbox-caption&quot;&gt;&lt;/div&gt;&#x27;);
          $photo_caption.text(origin.data(&#x27;caption&#x27;));
          $(&#x27;body&#x27;).append($photo_caption);
          $photo_caption.css({ &quot;display&quot;: &quot;inline&quot; });
          $photo_caption.velocity({opacity: 1}, {duration: inDuration, queue: false, easing: &#x27;easeOutQuad&#x27;});
        }

        // Resize Image
        var ratio = 0;
        var widthPercent = originalWidth / windowWidth;
        var heightPercent = originalHeight / windowHeight;
        var newWidth = 0;
        var newHeight = 0;

        if (widthPercent &gt; heightPercent) {
          ratio = originalHeight / originalWidth;
          newWidth = windowWidth * 0.9;
          newHeight = windowWidth * 0.9 * ratio;
        }
        else {
          ratio = originalWidth / originalHeight;
          newWidth = (windowHeight * 0.9) * ratio;
          newHeight = windowHeight * 0.9;
        }

        // Animate image + set z-index
        if(origin.hasClass(&#x27;responsive-img&#x27;)) {
          origin.velocity({&#x27;max-width&#x27;: newWidth, &#x27;width&#x27;: originalWidth}, {duration: 0, queue: false,
            complete: function(){
              origin.css({left: 0, top: 0})
              .velocity(
                {
                  height: newHeight,
                  width: newWidth,
                  left: $(document).scrollLeft() + windowWidth/2 - origin.parent(&#x27;.material-placeholder&#x27;).offset().left - newWidth/2,
                  top: $(document).scrollTop() + windowHeight/2 - origin.parent(&#x27;.material-placeholder&#x27;).offset().top - newHeight/ 2
                },
                {
                  duration: inDuration,
                  queue: false,
                  easing: &#x27;easeOutQuad&#x27;,
                  complete: function(){doneAnimating = true;}
                }
              );
            } // End Complete
          }); // End Velocity
        }
        else {
          origin.css(&#x27;left&#x27;, 0)
          .css(&#x27;top&#x27;, 0)
          .velocity(
            {
              height: newHeight,
              width: newWidth,
              left: $(document).scrollLeft() + windowWidth/2 - origin.parent(&#x27;.material-placeholder&#x27;).offset().left - newWidth/2,
              top: $(document).scrollTop() + windowHeight/2 - origin.parent(&#x27;.material-placeholder&#x27;).offset().top - newHeight/ 2
            },
            {
              duration: inDuration,
              queue: false,
              easing: &#x27;easeOutQuad&#x27;,
              complete: function(){doneAnimating = true;}
            }
            ); // End Velocity
        }

      }); // End origin on click


      // Return on scroll
      $(window).scroll(function() {
        if (overlayActive) {
          returnToOriginal();
        }
      });

      // Return on ESC
      $(document).keyup(function(e) {

        if (e.keyCode === 27 &amp;&amp; doneAnimating === true) {   // ESC key
          if (overlayActive) {
            returnToOriginal();
          }
        }
      });


      // This function returns the modaled image to the original spot
      function returnToOriginal() {

        doneAnimating = false;

        var placeholder = origin.parent(&#x27;.material-placeholder&#x27;);
        var windowWidth = window.innerWidth;
        var windowHeight = window.innerHeight;
        var originalWidth = origin.data(&#x27;width&#x27;);
        var originalHeight = origin.data(&#x27;height&#x27;);

        origin.velocity(&quot;stop&quot;, true);
        $(&#x27;#materialbox-overlay&#x27;).velocity(&quot;stop&quot;, true);
        $(&#x27;.materialbox-caption&#x27;).velocity(&quot;stop&quot;, true);


        $(&#x27;#materialbox-overlay&#x27;).velocity({opacity: 0}, {
          duration: outDuration, // Delay prevents animation overlapping
          queue: false, easing: &#x27;easeOutQuad&#x27;,
          complete: function(){
            // Remove Overlay
            overlayActive = false;
            $(this).remove();
          }
        });

        // Resize Image
        origin.velocity(
          {
            width: originalWidth,
            height: originalHeight,
            left: 0,
            top: 0
          },
          {
            duration: outDuration,
            queue: false, easing: &#x27;easeOutQuad&#x27;
          }
        );

        // Remove Caption + reset css settings on image
        $(&#x27;.materialbox-caption&#x27;).velocity({opacity: 0}, {
          duration: outDuration, // Delay prevents animation overlapping
          queue: false, easing: &#x27;easeOutQuad&#x27;,
          complete: function(){
            placeholder.css({
              height: &#x27;&#x27;,
              width: &#x27;&#x27;,
              position: &#x27;&#x27;,
              top: &#x27;&#x27;,
              left: &#x27;&#x27;
            });

            origin.css({
              height: &#x27;&#x27;,
              top: &#x27;&#x27;,
              left: &#x27;&#x27;,
              width: &#x27;&#x27;,
              &#x27;max-width&#x27;: &#x27;&#x27;,
              position: &#x27;&#x27;,
              &#x27;z-index&#x27;: &#x27;&#x27;,
              &#x27;will-change&#x27;: &#x27;&#x27;
            });

            // Remove class
            origin.removeClass(&#x27;active&#x27;);
            doneAnimating = true;
            $(this).remove();

            // Remove overflow overrides on ancestors
            if (ancestorsChanged) {
              ancestorsChanged.css(&#x27;overflow&#x27;, &#x27;&#x27;);
            }
          }
        });

      }
    });
  };

  $(document).ready(function(){
    $(&#x27;.materialboxed&#x27;).materialbox();
  });

}( jQuery ));
;(function ($) {

  $.fn.parallax = function () {
    var window_width = $(window).width();
    // Parallax Scripts
    return this.each(function(i) {
      var $this = $(this);
      $this.addClass(&#x27;parallax&#x27;);

      function updateParallax(initial) {
        var container_height;
        if (window_width &lt; 601) {
          container_height = ($this.height() &gt; 0) ? $this.height() : $this.children(&quot;img&quot;).height();
        }
        else {
          container_height = ($this.height() &gt; 0) ? $this.height() : 500;
        }
        var $img = $this.children(&quot;img&quot;).first();
        var img_height = $img.height();
        var parallax_dist = img_height - container_height;
        var bottom = $this.offset().top + container_height;
        var top = $this.offset().top;
        var scrollTop = $(window).scrollTop();
        var windowHeight = window.innerHeight;
        var windowBottom = scrollTop + windowHeight;
        var percentScrolled = (windowBottom - top) / (container_height + windowHeight);
        var parallax = Math.round((parallax_dist * percentScrolled));

        if (initial) {
          $img.css(&#x27;display&#x27;, &#x27;block&#x27;);
        }
        if ((bottom &gt; scrollTop) &amp;&amp; (top &lt; (scrollTop + windowHeight))) {
          $img.css(&#x27;transform&#x27;, &quot;translate3D(-50%,&quot; + parallax + &quot;px, 0)&quot;);
        }

      }

      // Wait for image load
      $this.children(&quot;img&quot;).one(&quot;load&quot;, function() {
        updateParallax(true);
      }).each(function() {
        if (this.complete) $(this).trigger(&quot;load&quot;);
      });

      $(window).scroll(function() {
        window_width = $(window).width();
        updateParallax(false);
      });

      $(window).resize(function() {
        window_width = $(window).width();
        updateParallax(false);
      });

    });

  };
}( jQuery ));
;(function ($) {

  var methods = {
    init : function(options) {
      var defaults = {
        onShow: null,
        swipeable: false,
        responsiveThreshold: Infinity, // breakpoint for swipeable
      };
      options = $.extend(defaults, options);

      return this.each(function() {

      // For each set of tabs, we want to keep track of
      // which tab is active and its associated content
      var $this = $(this),
          window_width = $(window).width();

      var $active, $content, $links = $this.find(&#x27;li.tab a&#x27;),
          $tabs_width = $this.width(),
          $tabs_content = $(),
          $tabs_wrapper,
          $tab_width = Math.max($tabs_width, $this[0].scrollWidth) / $links.length,
          $indicator,
          index = prev_index = 0,
          clicked = false,
          clickedTimeout,
          transition = 300;


      // Finds right attribute for indicator based on active tab.
      // el: jQuery Object
      var calcRightPos = function(el) {
        return $tabs_width - el.position().left - el.outerWidth() - $this.scrollLeft();
      };

      // Finds left attribute for indicator based on active tab.
      // el: jQuery Object
      var calcLeftPos = function(el) {
        return el.position().left + $this.scrollLeft();
      };

      // Animates Indicator to active tab.
      // prev_index: Number
      var animateIndicator = function(prev_index) {
        if ((index - prev_index) &gt;= 0) {
          $indicator.velocity({&quot;right&quot;: calcRightPos($active) }, { duration: transition, queue: false, easing: &#x27;easeOutQuad&#x27;});
          $indicator.velocity({&quot;left&quot;: calcLeftPos($active) }, {duration: transition, queue: false, easing: &#x27;easeOutQuad&#x27;, delay: 90});

        } else {
          $indicator.velocity({&quot;left&quot;: calcLeftPos($active) }, { duration: transition, queue: false, easing: &#x27;easeOutQuad&#x27;});
          $indicator.velocity({&quot;right&quot;: calcRightPos($active) }, {duration: transition, queue: false, easing: &#x27;easeOutQuad&#x27;, delay: 90});
        }
      };

      // Change swipeable according to responsive threshold
      if (options.swipeable) {
        if (window_width &gt; options.responsiveThreshold) {
          options.swipeable = false;
        }
      }


      // If the location.hash matches one of the links, use that as the active tab.
      $active = $($links.filter(&#x27;[href=&quot;&#x27;+location.hash+&#x27;&quot;]&#x27;));

      // If no match is found, use the first link or any with class &#x27;active&#x27; as the initial active tab.
      if ($active.length === 0) {
        $active = $(this).find(&#x27;li.tab a.active&#x27;).first();
      }
      if ($active.length === 0) {
        $active = $(this).find(&#x27;li.tab a&#x27;).first();
      }

      $active.addClass(&#x27;active&#x27;);
      index = $links.index($active);
      if (index &lt; 0) {
        index = 0;
      }

      if ($active[0] !== undefined) {
        $content = $($active[0].hash);
        $content.addClass(&#x27;active&#x27;);
      }

      // append indicator then set indicator width to tab width
      if (!$this.find(&#x27;.indicator&#x27;).length) {
        $this.append(&#x27;&lt;div class=&quot;indicator&quot;&gt;&lt;/div&gt;&#x27;);
      }
      $indicator = $this.find(&#x27;.indicator&#x27;);

      // we make sure that the indicator is at the end of the tabs
      $this.append($indicator);

      if ($this.is(&quot;:visible&quot;)) {
        // $indicator.css({&quot;right&quot;: $tabs_width - ((index + 1) * $tab_width)});
        // $indicator.css({&quot;left&quot;: index * $tab_width});
        setTimeout(function() {
          $indicator.css({&quot;right&quot;: calcRightPos($active) });
          $indicator.css({&quot;left&quot;: calcLeftPos($active) });
        }, 0);
      }
      $(window).resize(function () {
        $tabs_width = $this.width();
        $tab_width = Math.max($tabs_width, $this[0].scrollWidth) / $links.length;
        if (index &lt; 0) {
          index = 0;
        }
        if ($tab_width !== 0 &amp;&amp; $tabs_width !== 0) {
          $indicator.css({&quot;right&quot;: calcRightPos($active) });
          $indicator.css({&quot;left&quot;: calcLeftPos($active) });
        }
      });

      // Initialize Tabs Content.
      if (options.swipeable) {
        // TODO: Duplicate calls with swipeable? handle multiple div wrapping.
        $links.each(function () {
          var $curr_content = $(Materialize.escapeHash(this.hash));
          $curr_content.addClass(&#x27;carousel-item&#x27;);
          $tabs_content = $tabs_content.add($curr_content);
        });
        $tabs_wrapper = $tabs_content.wrapAll(&#x27;&lt;div class=&quot;tabs-content carousel&quot;&gt;&lt;/div&gt;&#x27;);
        $tabs_content.css(&#x27;display&#x27;, &#x27;&#x27;);
        $(&#x27;.tabs-content.carousel&#x27;).carousel({
          fullWidth: true,
          noWrap: true,
          onCycleTo: function(item) {
            if (!clicked) {
              var prev_index = index;
              index = $tabs_wrapper.index(item);
              $active = $links.eq(index);
              animateIndicator(prev_index);
            }
          },
        });
      } else {
        // Hide the remaining content
        $links.not($active).each(function () {
          $(Materialize.escapeHash(this.hash)).hide();
        });
      }


      // Bind the click event handler
      $this.on(&#x27;click&#x27;, &#x27;a&#x27;, function(e) {
        if ($(this).parent().hasClass(&#x27;disabled&#x27;)) {
          e.preventDefault();
          return;
        }

        // Act as regular link if target attribute is specified.
        if (!!$(this).attr(&quot;target&quot;)) {
          return;
        }

        clicked = true;
        $tabs_width = $this.width();
        $tab_width = Math.max($tabs_width, $this[0].scrollWidth) / $links.length;

        // Make the old tab inactive.
        $active.removeClass(&#x27;active&#x27;);
        var $oldContent = $content

        // Update the variables with the new link and content
        $active = $(this);
        $content = $(Materialize.escapeHash(this.hash));
        $links = $this.find(&#x27;li.tab a&#x27;);
        var activeRect = $active.position();

        // Make the tab active.
        $active.addClass(&#x27;active&#x27;);
        prev_index = index;
        index = $links.index($(this));
        if (index &lt; 0) {
          index = 0;
        }
        // Change url to current tab
        // window.location.hash = $active.attr(&#x27;href&#x27;);

        // Swap content
        if (options.swipeable) {
          if ($tabs_content.length) {
            $tabs_content.carousel(&#x27;set&#x27;, index);
          }
        } else {
          if ($content !== undefined) {
            $content.show();
            $content.addClass(&#x27;active&#x27;);
            if (typeof(options.onShow) === &quot;function&quot;) {
              options.onShow.call(this, $content);
            }
          }

          if ($oldContent !== undefined &amp;&amp;
              !$oldContent.is($content)) {
            $oldContent.hide();
            $oldContent.removeClass(&#x27;active&#x27;);
          }
        }

        // Reset clicked state
        clickedTimeout = setTimeout(function(){ clicked = false; }, transition);

        // Update indicator
        animateIndicator(prev_index);

        // Prevent the anchor&#x27;s default click action
        e.preventDefault();
      });
    });

    },
    select_tab : function( id ) {
      this.find(&#x27;a[href=&quot;#&#x27; + id + &#x27;&quot;]&#x27;).trigger(&#x27;click&#x27;);
    }
  };

  $.fn.tabs = function(methodOrOptions) {
    if ( methods[methodOrOptions] ) {
      return methods[ methodOrOptions ].apply( this, Array.prototype.slice.call( arguments, 1 ));
    } else if ( typeof methodOrOptions === &#x27;object&#x27; || ! methodOrOptions ) {
      // Default to &quot;init&quot;
      return methods.init.apply( this, arguments );
    } else {
      $.error( &#x27;Method &#x27; +  methodOrOptions + &#x27; does not exist on jQuery.tabs&#x27; );
    }
  };

  $(document).ready(function(){
    $(&#x27;ul.tabs&#x27;).tabs();
  });
}( jQuery ));
;(function ($) {
    $.fn.tooltip = function (options) {
      var timeout = null,
      margin = 5;

      // Defaults
      var defaults = {
        delay: 350,
        tooltip: &#x27;&#x27;,
        position: &#x27;bottom&#x27;,
        html: false
      };

      // Remove tooltip from the activator
      if (options === &quot;remove&quot;) {
        this.each(function() {
          $(&#x27;#&#x27; + $(this).attr(&#x27;data-tooltip-id&#x27;)).remove();
          $(this).off(&#x27;mouseenter.tooltip mouseleave.tooltip&#x27;);
        });
        return false;
      }

      options = $.extend(defaults, options);

      return this.each(function() {
        var tooltipId = Materialize.guid();
        var origin = $(this);

        // Destroy old tooltip
        if (origin.attr(&#x27;data-tooltip-id&#x27;)) {
          $(&#x27;#&#x27; + origin.attr(&#x27;data-tooltip-id&#x27;)).remove();
        }

        origin.attr(&#x27;data-tooltip-id&#x27;, tooltipId);

        // Get attributes.
        var allowHtml,
            tooltipDelay,
            tooltipPosition,
            tooltipText,
            tooltipEl,
            backdrop;
        var setAttributes = function() {
          allowHtml = origin.attr(&#x27;data-html&#x27;) ? origin.attr(&#x27;data-html&#x27;) === &#x27;true&#x27; : options.html;
          tooltipDelay = origin.attr(&#x27;data-delay&#x27;);
          tooltipDelay = (tooltipDelay === undefined || tooltipDelay === &#x27;&#x27;) ?
              options.delay : tooltipDelay;
          tooltipPosition = origin.attr(&#x27;data-position&#x27;);
          tooltipPosition = (tooltipPosition === undefined || tooltipPosition === &#x27;&#x27;) ?
              options.position : tooltipPosition;
          tooltipText = origin.attr(&#x27;data-tooltip&#x27;);
          tooltipText = (tooltipText === undefined || tooltipText === &#x27;&#x27;) ?
              options.tooltip : tooltipText;
        };
        setAttributes();

        var renderTooltipEl = function() {
          var tooltip = $(&#x27;&lt;div class=&quot;material-tooltip&quot;&gt;&lt;/div&gt;&#x27;);

          // Create Text span
          if (allowHtml) {
            tooltipText = $(&#x27;&lt;span&gt;&lt;/span&gt;&#x27;).html(tooltipText);
          } else{
            tooltipText = $(&#x27;&lt;span&gt;&lt;/span&gt;&#x27;).text(tooltipText);
          }

          // Create tooltip
          tooltip.append(tooltipText)
            .appendTo($(&#x27;body&#x27;))
            .attr(&#x27;id&#x27;, tooltipId);

          // Create backdrop
          backdrop = $(&#x27;&lt;div class=&quot;backdrop&quot;&gt;&lt;/div&gt;&#x27;);
          backdrop.appendTo(tooltip);
          return tooltip;
        };
        tooltipEl = renderTooltipEl();

        // Destroy previously binded events
        origin.off(&#x27;mouseenter.tooltip mouseleave.tooltip&#x27;);
        // Mouse In
        var started = false, timeoutRef;
        origin.on({&#x27;mouseenter.tooltip&#x27;: function(e) {
          var showTooltip = function() {
            setAttributes();
            started = true;
            tooltipEl.velocity(&#x27;stop&#x27;);
            backdrop.velocity(&#x27;stop&#x27;);
            tooltipEl.css({ visibility: &#x27;visible&#x27;, left: &#x27;0px&#x27;, top: &#x27;0px&#x27; });

            // Tooltip positioning
            var originWidth = origin.outerWidth();
            var originHeight = origin.outerHeight();
            var tooltipHeight = tooltipEl.outerHeight();
            var tooltipWidth = tooltipEl.outerWidth();
            var tooltipVerticalMovement = &#x27;0px&#x27;;
            var tooltipHorizontalMovement = &#x27;0px&#x27;;
            var backdropOffsetWidth = backdrop[0].offsetWidth;
            var backdropOffsetHeight = backdrop[0].offsetHeight;
            var scaleXFactor = 8;
            var scaleYFactor = 8;
            var scaleFactor = 0;
            var targetTop, targetLeft, newCoordinates;

            if (tooltipPosition === &quot;top&quot;) {
              // Top Position
              targetTop = origin.offset().top - tooltipHeight - margin;
              targetLeft = origin.offset().left + originWidth/2 - tooltipWidth/2;
              newCoordinates = repositionWithinScreen(targetLeft, targetTop, tooltipWidth, tooltipHeight);
              tooltipVerticalMovement = &#x27;-10px&#x27;;
              backdrop.css({
                bottom: 0,
                left: 0,
                borderRadius: &#x27;14px 14px 0 0&#x27;,
                transformOrigin: &#x27;50% 100%&#x27;,
                marginTop: tooltipHeight,
                marginLeft: (tooltipWidth/2) - (backdropOffsetWidth/2)
              });
            }
            // Left Position
            else if (tooltipPosition === &quot;left&quot;) {
              targetTop = origin.offset().top + originHeight/2 - tooltipHeight/2;
              targetLeft =  origin.offset().left - tooltipWidth - margin;
              newCoordinates = repositionWithinScreen(targetLeft, targetTop, tooltipWidth, tooltipHeight);

              tooltipHorizontalMovement = &#x27;-10px&#x27;;
              backdrop.css({
                top: &#x27;-7px&#x27;,
                right: 0,
                width: &#x27;14px&#x27;,
                height: &#x27;14px&#x27;,
                borderRadius: &#x27;14px 0 0 14px&#x27;,
                transformOrigin: &#x27;95% 50%&#x27;,
                marginTop: tooltipHeight/2,
                marginLeft: tooltipWidth
              });
            }
            // Right Position
            else if (tooltipPosition === &quot;right&quot;) {
              targetTop = origin.offset().top + originHeight/2 - tooltipHeight/2;
              targetLeft = origin.offset().left + originWidth + margin;
              newCoordinates = repositionWithinScreen(targetLeft, targetTop, tooltipWidth, tooltipHeight);

              tooltipHorizontalMovement = &#x27;+10px&#x27;;
              backdrop.css({
                top: &#x27;-7px&#x27;,
                left: 0,
                width: &#x27;14px&#x27;,
                height: &#x27;14px&#x27;,
                borderRadius: &#x27;0 14px 14px 0&#x27;,
                transformOrigin: &#x27;5% 50%&#x27;,
                marginTop: tooltipHeight/2,
                marginLeft: &#x27;0px&#x27;
              });
            }
            else {
              // Bottom Position
              targetTop = origin.offset().top + origin.outerHeight() + margin;
              targetLeft = origin.offset().left + originWidth/2 - tooltipWidth/2;
              newCoordinates = repositionWithinScreen(targetLeft, targetTop, tooltipWidth, tooltipHeight);
              tooltipVerticalMovement = &#x27;+10px&#x27;;
              backdrop.css({
                top: 0,
                left: 0,
                marginLeft: (tooltipWidth/2) - (backdropOffsetWidth/2)
              });
            }

            // Set tooptip css placement
            tooltipEl.css({
              top: newCoordinates.y,
              left: newCoordinates.x
            });

            // Calculate Scale to fill
            scaleXFactor = Math.SQRT2 * tooltipWidth / parseInt(backdropOffsetWidth);
            scaleYFactor = Math.SQRT2 * tooltipHeight / parseInt(backdropOffsetHeight);
            scaleFactor = Math.max(scaleXFactor, scaleYFactor);

            tooltipEl.velocity({ translateY: tooltipVerticalMovement, translateX: tooltipHorizontalMovement}, { duration: 350, queue: false })
              .velocity({opacity: 1}, {duration: 300, delay: 50, queue: false});
            backdrop.css({ visibility: &#x27;visible&#x27; })
              .velocity({opacity:1},{duration: 55, delay: 0, queue: false})
              .velocity({scaleX: scaleFactor, scaleY: scaleFactor}, {duration: 300, delay: 0, queue: false, easing: &#x27;easeInOutQuad&#x27;});
          };

          timeoutRef = setTimeout(showTooltip, tooltipDelay); // End Interval

        // Mouse Out
        },
        &#x27;mouseleave.tooltip&#x27;: function(){
          // Reset State
          started = false;
          clearTimeout(timeoutRef);

          // Animate back
          setTimeout(function() {
            if (started !== true) {
              tooltipEl.velocity({
                opacity: 0, translateY: 0, translateX: 0}, { duration: 225, queue: false});
              backdrop.velocity({opacity: 0, scaleX: 1, scaleY: 1}, {
                duration:225,
                queue: false,
                complete: function(){
                  backdrop.css({ visibility: &#x27;hidden&#x27; });
                  tooltipEl.css({ visibility: &#x27;hidden&#x27; });
                  started = false;}
              });
            }
          },225);
        }
        });
    });
  };

  var repositionWithinScreen = function(x, y, width, height) {
    var newX = x;
    var newY = y;

    if (newX &lt; 0) {
      newX = 4;
    } else if (newX + width &gt; window.innerWidth) {
      newX -= newX + width - window.innerWidth;
    }

    if (newY &lt; 0) {
      newY = 4;
    } else if (newY + height &gt; window.innerHeight + $(window).scrollTop) {
      newY -= newY + height - window.innerHeight;
    }

    return {x: newX, y: newY};
  };

  $(document).ready(function(){
     $(&#x27;.tooltipped&#x27;).tooltip();
   });
}( jQuery ));
;/*!
 * Waves v0.6.4
 * http://fian.my.id/Waves
 *
 * Copyright 2014 Alfiana E. Sibuea and other contributors
 * Released under the MIT license
 * https://github.com/fians/Waves/blob/master/LICENSE
 */

;(function(window) {
    &#x27;use strict&#x27;;

    var Waves = Waves || {};
    var $$ = document.querySelectorAll.bind(document);

    // Find exact position of element
    function isWindow(obj) {
        return obj !== null &amp;&amp; obj === obj.window;
    }

    function getWindow(elem) {
        return isWindow(elem) ? elem : elem.nodeType === 9 &amp;&amp; elem.defaultView;
    }

    function offset(elem) {
        var docElem, win,
            box = {top: 0, left: 0},
            doc = elem &amp;&amp; elem.ownerDocument;

        docElem = doc.documentElement;

        if (typeof elem.getBoundingClientRect !== typeof undefined) {
            box = elem.getBoundingClientRect();
        }
        win = getWindow(doc);
        return {
            top: box.top + win.pageYOffset - docElem.clientTop,
            left: box.left + win.pageXOffset - docElem.clientLeft
        };
    }

    function convertStyle(obj) {
        var style = &#x27;&#x27;;

        for (var a in obj) {
            if (obj.hasOwnProperty(a)) {
                style += (a + &#x27;:&#x27; + obj[a] + &#x27;;&#x27;);
            }
        }

        return style;
    }

    var Effect = {

        // Effect delay
        duration: 750,

        show: function(e, element) {

            // Disable right click
            if (e.button === 2) {
                return false;
            }

            var el = element || this;

            // Create ripple
            var ripple = document.createElement(&#x27;div&#x27;);
            ripple.className = &#x27;waves-ripple&#x27;;
            el.appendChild(ripple);

            // Get click coordinate and element witdh
            var pos         = offset(el);
            var relativeY   = (e.pageY - pos.top);
            var relativeX   = (e.pageX - pos.left);
            var scale       = &#x27;scale(&#x27;+((el.clientWidth / 100) * 10)+&#x27;)&#x27;;

            // Support for touch devices
            if (&#x27;touches&#x27; in e) {
              relativeY   = (e.touches[0].pageY - pos.top);
              relativeX   = (e.touches[0].pageX - pos.left);
            }

            // Attach data to element
            ripple.setAttribute(&#x27;data-hold&#x27;, Date.now());
            ripple.setAttribute(&#x27;data-scale&#x27;, scale);
            ripple.setAttribute(&#x27;data-x&#x27;, relativeX);
            ripple.setAttribute(&#x27;data-y&#x27;, relativeY);

            // Set ripple position
            var rippleStyle = {
                &#x27;top&#x27;: relativeY+&#x27;px&#x27;,
                &#x27;left&#x27;: relativeX+&#x27;px&#x27;
            };

            ripple.className = ripple.className + &#x27; waves-notransition&#x27;;
            ripple.setAttribute(&#x27;style&#x27;, convertStyle(rippleStyle));
            ripple.className = ripple.className.replace(&#x27;waves-notransition&#x27;, &#x27;&#x27;);

            // Scale the ripple
            rippleStyle[&#x27;-webkit-transform&#x27;] = scale;
            rippleStyle[&#x27;-moz-transform&#x27;] = scale;
            rippleStyle[&#x27;-ms-transform&#x27;] = scale;
            rippleStyle[&#x27;-o-transform&#x27;] = scale;
            rippleStyle.transform = scale;
            rippleStyle.opacity   = &#x27;1&#x27;;

            rippleStyle[&#x27;-webkit-transition-duration&#x27;] = Effect.duration + &#x27;ms&#x27;;
            rippleStyle[&#x27;-moz-transition-duration&#x27;]    = Effect.duration + &#x27;ms&#x27;;
            rippleStyle[&#x27;-o-transition-duration&#x27;]      = Effect.duration + &#x27;ms&#x27;;
            rippleStyle[&#x27;transition-duration&#x27;]         = Effect.duration + &#x27;ms&#x27;;

            rippleStyle[&#x27;-webkit-transition-timing-function&#x27;] = &#x27;cubic-bezier(0.250, 0.460, 0.450, 0.940)&#x27;;
            rippleStyle[&#x27;-moz-transition-timing-function&#x27;]    = &#x27;cubic-bezier(0.250, 0.460, 0.450, 0.940)&#x27;;
            rippleStyle[&#x27;-o-transition-timing-function&#x27;]      = &#x27;cubic-bezier(0.250, 0.460, 0.450, 0.940)&#x27;;
            rippleStyle[&#x27;transition-timing-function&#x27;]         = &#x27;cubic-bezier(0.250, 0.460, 0.450, 0.940)&#x27;;

            ripple.setAttribute(&#x27;style&#x27;, convertStyle(rippleStyle));
        },

        hide: function(e) {
            TouchHandler.touchup(e);

            var el = this;
            var width = el.clientWidth * 1.4;

            // Get first ripple
            var ripple = null;
            var ripples = el.getElementsByClassName(&#x27;waves-ripple&#x27;);
            if (ripples.length &gt; 0) {
                ripple = ripples[ripples.length - 1];
            } else {
                return false;
            }

            var relativeX   = ripple.getAttribute(&#x27;data-x&#x27;);
            var relativeY   = ripple.getAttribute(&#x27;data-y&#x27;);
            var scale       = ripple.getAttribute(&#x27;data-scale&#x27;);

            // Get delay beetween mousedown and mouse leave
            var diff = Date.now() - Number(ripple.getAttribute(&#x27;data-hold&#x27;));
            var delay = 350 - diff;

            if (delay &lt; 0) {
                delay = 0;
            }

            // Fade out ripple after delay
            setTimeout(function() {
                var style = {
                    &#x27;top&#x27;: relativeY+&#x27;px&#x27;,
                    &#x27;left&#x27;: relativeX+&#x27;px&#x27;,
                    &#x27;opacity&#x27;: &#x27;0&#x27;,

                    // Duration
                    &#x27;-webkit-transition-duration&#x27;: Effect.duration + &#x27;ms&#x27;,
                    &#x27;-moz-transition-duration&#x27;: Effect.duration + &#x27;ms&#x27;,
                    &#x27;-o-transition-duration&#x27;: Effect.duration + &#x27;ms&#x27;,
                    &#x27;transition-duration&#x27;: Effect.duration + &#x27;ms&#x27;,
                    &#x27;-webkit-transform&#x27;: scale,
                    &#x27;-moz-transform&#x27;: scale,
                    &#x27;-ms-transform&#x27;: scale,
                    &#x27;-o-transform&#x27;: scale,
                    &#x27;transform&#x27;: scale,
                };

                ripple.setAttribute(&#x27;style&#x27;, convertStyle(style));

                setTimeout(function() {
                    try {
                        el.removeChild(ripple);
                    } catch(e) {
                        return false;
                    }
                }, Effect.duration);
            }, delay);
        },

        // Little hack to make &lt;input&gt; can perform waves effect
        wrapInput: function(elements) {
            for (var a = 0; a &lt; elements.length; a++) {
                var el = elements[a];

                if (el.tagName.toLowerCase() === &#x27;input&#x27;) {
                    var parent = el.parentNode;

                    // If input already have parent just pass through
                    if (parent.tagName.toLowerCase() === &#x27;i&#x27; &amp;&amp; parent.className.indexOf(&#x27;waves-effect&#x27;) !== -1) {
                        continue;
                    }

                    // Put element class and style to the specified parent
                    var wrapper = document.createElement(&#x27;i&#x27;);
                    wrapper.className = el.className + &#x27; waves-input-wrapper&#x27;;

                    var elementStyle = el.getAttribute(&#x27;style&#x27;);

                    if (!elementStyle) {
                        elementStyle = &#x27;&#x27;;
                    }

                    wrapper.setAttribute(&#x27;style&#x27;, elementStyle);

                    el.className = &#x27;waves-button-input&#x27;;
                    el.removeAttribute(&#x27;style&#x27;);

                    // Put element as child
                    parent.replaceChild(wrapper, el);
                    wrapper.appendChild(el);
                }
            }
        }
    };


    /**
     * Disable mousedown event for 500ms during and after touch
     */
    var TouchHandler = {
        /* uses an integer rather than bool so there&#x27;s no issues with
         * needing to clear timeouts if another touch event occurred
         * within the 500ms. Cannot mouseup between touchstart and
         * touchend, nor in the 500ms after touchend. */
        touches: 0,
        allowEvent: function(e) {
            var allow = true;

            if (e.type === &#x27;touchstart&#x27;) {
                TouchHandler.touches += 1; //push
            } else if (e.type === &#x27;touchend&#x27; || e.type === &#x27;touchcancel&#x27;) {
                setTimeout(function() {
                    if (TouchHandler.touches &gt; 0) {
                        TouchHandler.touches -= 1; //pop after 500ms
                    }
                }, 500);
            } else if (e.type === &#x27;mousedown&#x27; &amp;&amp; TouchHandler.touches &gt; 0) {
                allow = false;
            }

            return allow;
        },
        touchup: function(e) {
            TouchHandler.allowEvent(e);
        }
    };


    /**
     * Delegated click handler for .waves-effect element.
     * returns null when .waves-effect element not in &quot;click tree&quot;
     */
    function getWavesEffectElement(e) {
        if (TouchHandler.allowEvent(e) === false) {
            return null;
        }

        var element = null;
        var target = e.target || e.srcElement;

        while (target.parentElement !== null) {
            if (!(target instanceof SVGElement) &amp;&amp; target.className.indexOf(&#x27;waves-effect&#x27;) !== -1) {
                element = target;
                break;
            } else if (target.classList.contains(&#x27;waves-effect&#x27;)) {
                element = target;
                break;
            }
            target = target.parentElement;
        }

        return element;
    }

    /**
     * Bubble the click and show effect if .waves-effect elem was found
     */
    function showEffect(e) {
        var element = getWavesEffectElement(e);

        if (element !== null) {
            Effect.show(e, element);

            if (&#x27;ontouchstart&#x27; in window) {
                element.addEventListener(&#x27;touchend&#x27;, Effect.hide, false);
                element.addEventListener(&#x27;touchcancel&#x27;, Effect.hide, false);
            }

            element.addEventListener(&#x27;mouseup&#x27;, Effect.hide, false);
            element.addEventListener(&#x27;mouseleave&#x27;, Effect.hide, false);
        }
    }

    Waves.displayEffect = function(options) {
        options = options || {};

        if (&#x27;duration&#x27; in options) {
            Effect.duration = options.duration;
        }

        //Wrap input inside &lt;i&gt; tag
        Effect.wrapInput($$(&#x27;.waves-effect&#x27;));

        if (&#x27;ontouchstart&#x27; in window) {
            document.body.addEventListener(&#x27;touchstart&#x27;, showEffect, false);
        }

        document.body.addEventListener(&#x27;mousedown&#x27;, showEffect, false);
    };

    /**
     * Attach Waves to an input element (or any element which doesn&#x27;t
     * bubble mouseup/mousedown events).
     *   Intended to be used with dynamically loaded forms/inputs, or
     * where the user doesn&#x27;t want a delegated click handler.
     */
    Waves.attach = function(element) {
        //FUTURE: automatically add waves classes and allow users
        // to specify them with an options param? Eg. light/classic/button
        if (element.tagName.toLowerCase() === &#x27;input&#x27;) {
            Effect.wrapInput([element]);
            element = element.parentElement;
        }

        if (&#x27;ontouchstart&#x27; in window) {
            element.addEventListener(&#x27;touchstart&#x27;, showEffect, false);
        }

        element.addEventListener(&#x27;mousedown&#x27;, showEffect, false);
    };

    window.Waves = Waves;

    document.addEventListener(&#x27;DOMContentLoaded&#x27;, function() {
        Waves.displayEffect();
    }, false);

})(window);
;Materialize.toast = function (message, displayLength, className, completeCallback) {
  className = className || &quot;&quot;;

  var container = document.getElementById(&#x27;toast-container&#x27;);

  // Create toast container if it does not exist
  if (container === null) {
    // create notification container
    container = document.createElement(&#x27;div&#x27;);
    container.id = &#x27;toast-container&#x27;;
    document.body.appendChild(container);
  }

  // Select and append toast
  var newToast = createToast(message);

  // only append toast if message is not undefined
  if(message){
    container.appendChild(newToast);
  }

  newToast.style.opacity = 0;

  // Animate toast in
  Vel(newToast, {translateY: &#x27;-35px&#x27;,  opacity: 1 }, {duration: 300,
    easing: &#x27;easeOutCubic&#x27;,
    queue: false});

  // Allows timer to be pause while being panned
  var timeLeft = displayLength;
  var counterInterval;
  if (timeLeft != null)  {
    counterInterval = setInterval (function(){
      if (newToast.parentNode === null)
        window.clearInterval(counterInterval);

      // If toast is not being dragged, decrease its time remaining
      if (!newToast.classList.contains(&#x27;panning&#x27;)) {
        timeLeft -= 20;
      }

      if (timeLeft &lt;= 0) {
        // Animate toast out
        Vel(newToast, {&quot;opacity&quot;: 0, marginTop: &#x27;-40px&#x27;}, { duration: 375,
            easing: &#x27;easeOutExpo&#x27;,
            queue: false,
            complete: function(){
              // Call the optional callback
              if(typeof(completeCallback) === &quot;function&quot;)
                completeCallback();
              // Remove toast after it times out
              this[0].parentNode.removeChild(this[0]);
            }
          });
        window.clearInterval(counterInterval);
      }
    }, 20);
  }



  function createToast(html) {

    // Create toast
    var toast = document.createElement(&#x27;div&#x27;);
    toast.classList.add(&#x27;toast&#x27;);
    if (className) {
      var classes = className.split(&#x27; &#x27;);

      for (var i = 0, count = classes.length; i &lt; count; i++) {
        toast.classList.add(classes[i]);
      }
    }
  // If type of parameter is HTML Element
    if ( typeof HTMLElement === &quot;object&quot; ? html instanceof HTMLElement : html &amp;&amp; typeof html === &quot;object&quot; &amp;&amp; html !== null &amp;&amp; html.nodeType === 1 &amp;&amp; typeof html.nodeName===&quot;string&quot;
) {
      toast.appendChild(html);
    }
    else if (html instanceof jQuery) {
      // Check if it is jQuery object
      toast.appendChild(html[0]);
    }
    else {
      // Insert as text;
      toast.innerHTML = html;
    }
    // Bind hammer
    var hammerHandler = new Hammer(toast, {prevent_default: false});
    hammerHandler.on(&#x27;pan&#x27;, function(e) {
      var deltaX = e.deltaX;
      var activationDistance = 80;

      // Change toast state
      if (!toast.classList.contains(&#x27;panning&#x27;)){
        toast.classList.add(&#x27;panning&#x27;);
      }

      var opacityPercent = 1-Math.abs(deltaX / activationDistance);
      if (opacityPercent &lt; 0)
        opacityPercent = 0;

      Vel(toast, {left: deltaX, opacity: opacityPercent }, {duration: 50, queue: false, easing: &#x27;easeOutQuad&#x27;});

    });

    hammerHandler.on(&#x27;panend&#x27;, function(e) {
      var deltaX = e.deltaX;
      var activationDistance = 80;

      // If toast dragged past activation point
      if (Math.abs(deltaX) &gt; activationDistance) {
        Vel(toast, {marginTop: &#x27;-40px&#x27;}, { duration: 375,
          easing: &#x27;easeOutExpo&#x27;,
          queue: false,
          complete: function(){
            if(typeof(completeCallback) === &quot;function&quot;) {
              completeCallback();
            }
            toast.parentNode.removeChild(toast);
          }
        });

      } else {
        toast.classList.remove(&#x27;panning&#x27;);
        // Put toast back into original position
        Vel(toast, { left: 0, opacity: 1 }, { duration: 300,
          easing: &#x27;easeOutExpo&#x27;,
          queue: false
        });

      }
    });

    return toast;
  }
};
;(function ($) {

  var methods = {
    init : function(options) {
      var defaults = {
        menuWidth: 300,
        edge: &#x27;left&#x27;,
        closeOnClick: false,
        draggable: true
      };
      options = $.extend(defaults, options);

      $(this).each(function(){
        var $this = $(this);
        var menuId = $this.attr(&#x27;data-activates&#x27;);
        var menu = $(&quot;#&quot;+ menuId);

        // Set to width
        if (options.menuWidth != 300) {
          menu.css(&#x27;width&#x27;, options.menuWidth);
        }

        // Add Touch Area
        var $dragTarget = $(&#x27;.drag-target[data-sidenav=&quot;&#x27; + menuId + &#x27;&quot;]&#x27;);
        if (options.draggable) {
          // Regenerate dragTarget
          if ($dragTarget.length) {
            $dragTarget.remove();
          }

          $dragTarget = $(&#x27;&lt;div class=&quot;drag-target&quot;&gt;&lt;/div&gt;&#x27;).attr(&#x27;data-sidenav&#x27;, menuId);
          $(&#x27;body&#x27;).append($dragTarget);
        } else {
          $dragTarget = $();
        }

        if (options.edge == &#x27;left&#x27;) {
          menu.css(&#x27;transform&#x27;, &#x27;translateX(-100%)&#x27;);
          $dragTarget.css({&#x27;left&#x27;: 0}); // Add Touch Area
        }
        else {
          menu.addClass(&#x27;right-aligned&#x27;) // Change text-alignment to right
            .css(&#x27;transform&#x27;, &#x27;translateX(100%)&#x27;);
          $dragTarget.css({&#x27;right&#x27;: 0}); // Add Touch Area
        }

        // If fixed sidenav, bring menu out
        if (menu.hasClass(&#x27;fixed&#x27;)) {
            if (window.innerWidth &gt; 992) {
              menu.css(&#x27;transform&#x27;, &#x27;translateX(0)&#x27;);
            }
          }

        // Window resize to reset on large screens fixed
        if (menu.hasClass(&#x27;fixed&#x27;)) {
          $(window).resize( function() {
            if (window.innerWidth &gt; 992) {
              // Close menu if window is resized bigger than 992 and user has fixed sidenav
              if ($(&#x27;#sidenav-overlay&#x27;).length !== 0 &amp;&amp; menuOut) {
                removeMenu(true);
              }
              else {
                // menu.removeAttr(&#x27;style&#x27;);
                menu.css(&#x27;transform&#x27;, &#x27;translateX(0%)&#x27;);
                // menu.css(&#x27;width&#x27;, options.menuWidth);
              }
            }
            else if (menuOut === false){
              if (options.edge === &#x27;left&#x27;) {
                menu.css(&#x27;transform&#x27;, &#x27;translateX(-100%)&#x27;);
              } else {
                menu.css(&#x27;transform&#x27;, &#x27;translateX(100%)&#x27;);
              }

            }

          });
        }

        // if closeOnClick, then add close event for all a tags in side sideNav
        if (options.closeOnClick === true) {
          menu.on(&quot;click.itemclick&quot;, &quot;a:not(.collapsible-header)&quot;, function(){
            removeMenu();
          });
        }

        var removeMenu = function(restoreNav) {
          panning = false;
          menuOut = false;
          // Reenable scrolling
          $(&#x27;body&#x27;).css({
            overflow: &#x27;&#x27;,
            width: &#x27;&#x27;
          });

          $(&#x27;#sidenav-overlay&#x27;).velocity({opacity: 0}, {duration: 200,
              queue: false, easing: &#x27;easeOutQuad&#x27;,
            complete: function() {
              $(this).remove();
            } });
          if (options.edge === &#x27;left&#x27;) {
            // Reset phantom div
            $dragTarget.css({width: &#x27;&#x27;, right: &#x27;&#x27;, left: &#x27;0&#x27;});
            menu.velocity(
              {&#x27;translateX&#x27;: &#x27;-100%&#x27;},
              { duration: 200,
                queue: false,
                easing: &#x27;easeOutCubic&#x27;,
                complete: function() {
                  if (restoreNav === true) {
                    // Restore Fixed sidenav
                    menu.removeAttr(&#x27;style&#x27;);
                    menu.css(&#x27;width&#x27;, options.menuWidth);
                  }
                }

            });
          }
          else {
            // Reset phantom div
            $dragTarget.css({width: &#x27;&#x27;, right: &#x27;0&#x27;, left: &#x27;&#x27;});
            menu.velocity(
              {&#x27;translateX&#x27;: &#x27;100%&#x27;},
              { duration: 200,
                queue: false,
                easing: &#x27;easeOutCubic&#x27;,
                complete: function() {
                  if (restoreNav === true) {
                    // Restore Fixed sidenav
                    menu.removeAttr(&#x27;style&#x27;);
                    menu.css(&#x27;width&#x27;, options.menuWidth);
                  }
                }
              });
          }
        };



        // Touch Event
        var panning = false;
        var menuOut = false;

        if (options.draggable) {
          $dragTarget.on(&#x27;click&#x27;, function(){
            if (menuOut) {
              removeMenu();
            }
          });

          $dragTarget.hammer({
            prevent_default: false
          }).bind(&#x27;pan&#x27;, function(e) {

            if (e.gesture.pointerType == &quot;touch&quot;) {

              var direction = e.gesture.direction;
              var x = e.gesture.center.x;
              var y = e.gesture.center.y;
              var velocityX = e.gesture.velocityX;

              // Disable Scrolling
              var $body = $(&#x27;body&#x27;);
              var $overlay = $(&#x27;#sidenav-overlay&#x27;);
              var oldWidth = $body.innerWidth();
              $body.css(&#x27;overflow&#x27;, &#x27;hidden&#x27;);
              $body.width(oldWidth);

              // If overlay does not exist, create one and if it is clicked, close menu
              if ($overlay.length === 0) {
                $overlay = $(&#x27;&lt;div id=&quot;sidenav-overlay&quot;&gt;&lt;/div&gt;&#x27;);
                $overlay.css(&#x27;opacity&#x27;, 0).click( function(){
                  removeMenu();
                });
                $(&#x27;body&#x27;).append($overlay);
              }

              // Keep within boundaries
              if (options.edge === &#x27;left&#x27;) {
                if (x &gt; options.menuWidth) { x = options.menuWidth; }
                else if (x &lt; 0) { x = 0; }
              }

              if (options.edge === &#x27;left&#x27;) {
                // Left Direction
                if (x &lt; (options.menuWidth / 2)) { menuOut = false; }
                // Right Direction
                else if (x &gt;= (options.menuWidth / 2)) { menuOut = true; }
                menu.css(&#x27;transform&#x27;, &#x27;translateX(&#x27; + (x - options.menuWidth) + &#x27;px)&#x27;);
              }
              else {
                // Left Direction
                if (x &lt; (window.innerWidth - options.menuWidth / 2)) {
                  menuOut = true;
                }
                // Right Direction
                else if (x &gt;= (window.innerWidth - options.menuWidth / 2)) {
                 menuOut = false;
               }
                var rightPos = (x - options.menuWidth / 2);
                if (rightPos &lt; 0) {
                  rightPos = 0;
                }

                menu.css(&#x27;transform&#x27;, &#x27;translateX(&#x27; + rightPos + &#x27;px)&#x27;);
              }


              // Percentage overlay
              var overlayPerc;
              if (options.edge === &#x27;left&#x27;) {
                overlayPerc = x / options.menuWidth;
                $overlay.velocity({opacity: overlayPerc }, {duration: 10, queue: false, easing: &#x27;easeOutQuad&#x27;});
              }
              else {
                overlayPerc = Math.abs((x - window.innerWidth) / options.menuWidth);
                $overlay.velocity({opacity: overlayPerc }, {duration: 10, queue: false, easing: &#x27;easeOutQuad&#x27;});
              }
            }

          }).bind(&#x27;panend&#x27;, function(e) {

            if (e.gesture.pointerType == &quot;touch&quot;) {
              var $overlay = $(&#x27;&lt;div id=&quot;sidenav-overlay&quot;&gt;&lt;/div&gt;&#x27;);
              var velocityX = e.gesture.velocityX;
              var x = e.gesture.center.x;
              var leftPos = x - options.menuWidth;
              var rightPos = x - options.menuWidth / 2;
              if (leftPos &gt; 0 ) {
                leftPos = 0;
              }
              if (rightPos &lt; 0) {
                rightPos = 0;
              }
              panning = false;

              if (options.edge === &#x27;left&#x27;) {
                // If velocityX &lt;= 0.3 then the user is flinging the menu closed so ignore menuOut
                if ((menuOut &amp;&amp; velocityX &lt;= 0.3) || velocityX &lt; -0.5) {
                  // Return menu to open
                  if (leftPos !== 0) {
                    menu.velocity({&#x27;translateX&#x27;: [0, leftPos]}, {duration: 300, queue: false, easing: &#x27;easeOutQuad&#x27;});
                  }

                  $overlay.velocity({opacity: 1 }, {duration: 50, queue: false, easing: &#x27;easeOutQuad&#x27;});
                  $dragTarget.css({width: &#x27;50%&#x27;, right: 0, left: &#x27;&#x27;});
                  menuOut = true;
                }
                else if (!menuOut || velocityX &gt; 0.3) {
                  // Enable Scrolling
                  $(&#x27;body&#x27;).css({
                    overflow: &#x27;&#x27;,
                    width: &#x27;&#x27;
                  });
                  // Slide menu closed
                  menu.velocity({&#x27;translateX&#x27;: [-1 * options.menuWidth - 10, leftPos]}, {duration: 200, queue: false, easing: &#x27;easeOutQuad&#x27;});
                  $overlay.velocity({opacity: 0 }, {duration: 200, queue: false, easing: &#x27;easeOutQuad&#x27;,
                    complete: function () {
                      $(this).remove();
                    }});
                  $dragTarget.css({width: &#x27;10px&#x27;, right: &#x27;&#x27;, left: 0});
                }
              }
              else {
                if ((menuOut &amp;&amp; velocityX &gt;= -0.3) || velocityX &gt; 0.5) {
                  // Return menu to open
                  if (rightPos !== 0) {
                    menu.velocity({&#x27;translateX&#x27;: [0, rightPos]}, {duration: 300, queue: false, easing: &#x27;easeOutQuad&#x27;});
                  }

                  $overlay.velocity({opacity: 1 }, {duration: 50, queue: false, easing: &#x27;easeOutQuad&#x27;});
                  $dragTarget.css({width: &#x27;50%&#x27;, right: &#x27;&#x27;, left: 0});
                  menuOut = true;
                }
                else if (!menuOut || velocityX &lt; -0.3) {
                  // Enable Scrolling
                  $(&#x27;body&#x27;).css({
                    overflow: &#x27;&#x27;,
                    width: &#x27;&#x27;
                  });

                  // Slide menu closed
                  menu.velocity({&#x27;translateX&#x27;: [options.menuWidth + 10, rightPos]}, {duration: 200, queue: false, easing: &#x27;easeOutQuad&#x27;});
                  $overlay.velocity({opacity: 0 }, {duration: 200, queue: false, easing: &#x27;easeOutQuad&#x27;,
                    complete: function () {
                      $(this).remove();
                    }});
                  $dragTarget.css({width: &#x27;10px&#x27;, right: 0, left: &#x27;&#x27;});
                }
              }

            }
          });
        }

        $this.off(&#x27;click.sidenav&#x27;).on(&#x27;click.sidenav&#x27;, function() {
          if (menuOut === true) {
            menuOut = false;
            panning = false;
            removeMenu();
          }
          else {

            // Disable Scrolling
            var $body = $(&#x27;body&#x27;);
            var $overlay = $(&#x27;&lt;div id=&quot;sidenav-overlay&quot;&gt;&lt;/div&gt;&#x27;);
            var oldWidth = $body.innerWidth();
            $body.css(&#x27;overflow&#x27;, &#x27;hidden&#x27;);
            $body.width(oldWidth);

            // Push current drag target on top of DOM tree
            $(&#x27;body&#x27;).append($dragTarget);

            if (options.edge === &#x27;left&#x27;) {
              $dragTarget.css({width: &#x27;50%&#x27;, right: 0, left: &#x27;&#x27;});
              menu.velocity({&#x27;translateX&#x27;: [0, -1 * options.menuWidth]}, {duration: 300, queue: false, easing: &#x27;easeOutQuad&#x27;});
            }
            else {
              $dragTarget.css({width: &#x27;50%&#x27;, right: &#x27;&#x27;, left: 0});
              menu.velocity({&#x27;translateX&#x27;: [0, options.menuWidth]}, {duration: 300, queue: false, easing: &#x27;easeOutQuad&#x27;});
            }

            $overlay.css(&#x27;opacity&#x27;, 0)
            .click(function(){
              menuOut = false;
              panning = false;
              removeMenu();
              $overlay.velocity({opacity: 0}, {duration: 300, queue: false, easing: &#x27;easeOutQuad&#x27;,
                complete: function() {
                  $(this).remove();
                } });

            });
            $(&#x27;body&#x27;).append($overlay);
            $overlay.velocity({opacity: 1}, {duration: 300, queue: false, easing: &#x27;easeOutQuad&#x27;,
              complete: function () {
                menuOut = true;
                panning = false;
              }
            });
          }

          return false;
        });
      });


    },
    destroy: function () {
      var $overlay = $(&#x27;#sidenav-overlay&#x27;);
      var $dragTarget = $(&#x27;.drag-target[data-sidenav=&quot;&#x27; + $(this).attr(&#x27;data-activates&#x27;) + &#x27;&quot;]&#x27;);
      $overlay.trigger(&#x27;click&#x27;);
      $dragTarget.remove();
      $(this).off(&#x27;click&#x27;);
      $overlay.remove();
    },
    show : function() {
      this.trigger(&#x27;click&#x27;);
    },
    hide : function() {
      $(&#x27;#sidenav-overlay&#x27;).trigger(&#x27;click&#x27;);
    }
  };


  $.fn.sideNav = function(methodOrOptions) {
    if ( methods[methodOrOptions] ) {
      return methods[ methodOrOptions ].apply( this, Array.prototype.slice.call( arguments, 1 ));
    } else if ( typeof methodOrOptions === &#x27;object&#x27; || ! methodOrOptions ) {
      // Default to &quot;init&quot;
      return methods.init.apply( this, arguments );
    } else {
      $.error( &#x27;Method &#x27; +  methodOrOptions + &#x27; does not exist on jQuery.sideNav&#x27; );
    }
  }; // Plugin end
}( jQuery ));
;/**
 * Extend jquery with a scrollspy plugin.
 * This watches the window scroll and fires events when elements are scrolled into viewport.
 *
 * throttle() and getTime() taken from Underscore.js
 * https://github.com/jashkenas/underscore
 *
 * @author Copyright 2013 John Smart
 * @license https://raw.github.com/thesmart/jquery-scrollspy/master/LICENSE
 * @see https://github.com/thesmart
 * @version 0.1.2
 */
(function($) {

	var jWindow = $(window);
	var elements = [];
	var elementsInView = [];
	var isSpying = false;
	var ticks = 0;
	var unique_id = 1;
	var offset = {
		top : 0,
		right : 0,
		bottom : 0,
		left : 0,
	}

	/**
	 * Find elements that are within the boundary
	 * @param {number} top
	 * @param {number} right
	 * @param {number} bottom
	 * @param {number} left
	 * @return {jQuery}		A collection of elements
	 */
	function findElements(top, right, bottom, left) {
		var hits = $();
		$.each(elements, function(i, element) {
			if (element.height() &gt; 0) {
				var elTop = element.offset().top,
					elLeft = element.offset().left,
					elRight = elLeft + element.width(),
					elBottom = elTop + element.height();

				var isIntersect = !(elLeft &gt; right ||
					elRight &lt; left ||
					elTop &gt; bottom ||
					elBottom &lt; top);

				if (isIntersect) {
					hits.push(element);
				}
			}
		});

		return hits;
	}


	/**
	 * Called when the user scrolls the window
	 */
	function onScroll(scrollOffset) {
		// unique tick id
		++ticks;

		// viewport rectangle
		var top = jWindow.scrollTop(),
			left = jWindow.scrollLeft(),
			right = left + jWindow.width(),
			bottom = top + jWindow.height();

		// determine which elements are in view
		var intersections = findElements(top+offset.top + scrollOffset || 200, right+offset.right, bottom+offset.bottom, left+offset.left);
		$.each(intersections, function(i, element) {

			var lastTick = element.data(&#x27;scrollSpy:ticks&#x27;);
			if (typeof lastTick != &#x27;number&#x27;) {
				// entered into view
				element.triggerHandler(&#x27;scrollSpy:enter&#x27;);
			}

			// update tick id
			element.data(&#x27;scrollSpy:ticks&#x27;, ticks);
		});

		// determine which elements are no longer in view
		$.each(elementsInView, function(i, element) {
			var lastTick = element.data(&#x27;scrollSpy:ticks&#x27;);
			if (typeof lastTick == &#x27;number&#x27; &amp;&amp; lastTick !== ticks) {
				// exited from view
				element.triggerHandler(&#x27;scrollSpy:exit&#x27;);
				element.data(&#x27;scrollSpy:ticks&#x27;, null);
			}
		});

		// remember elements in view for next tick
		elementsInView = intersections;
	}

	/**
	 * Called when window is resized
	*/
	function onWinSize() {
		jWindow.trigger(&#x27;scrollSpy:winSize&#x27;);
	}


	/**
	 * Enables ScrollSpy using a selector
	 * @param {jQuery|string} selector  The elements collection, or a selector
	 * @param {Object=} options	Optional.
        throttle : number -&gt; scrollspy throttling. Default: 100 ms
        offsetTop : number -&gt; offset from top. Default: 0
        offsetRight : number -&gt; offset from right. Default: 0
        offsetBottom : number -&gt; offset from bottom. Default: 0
        offsetLeft : number -&gt; offset from left. Default: 0
	 * @returns {jQuery}
	 */
	$.scrollSpy = function(selector, options) {
	  var defaults = {
			throttle: 100,
			scrollOffset: 200 // offset - 200 allows elements near bottom of page to scroll
    };
    options = $.extend(defaults, options);

		var visible = [];
		selector = $(selector);
		selector.each(function(i, element) {
			elements.push($(element));
			$(element).data(&quot;scrollSpy:id&quot;, i);
			// Smooth scroll to section
		  $(&#x27;a[href=&quot;#&#x27; + $(element).attr(&#x27;id&#x27;) + &#x27;&quot;]&#x27;).click(function(e) {
		    e.preventDefault();
		    var offset = $(Materialize.escapeHash(this.hash)).offset().top + 1;
	    	$(&#x27;html, body&#x27;).animate({ scrollTop: offset - options.scrollOffset }, {duration: 400, queue: false, easing: &#x27;easeOutCubic&#x27;});
		  });
		});

		offset.top = options.offsetTop || 0;
		offset.right = options.offsetRight || 0;
		offset.bottom = options.offsetBottom || 0;
		offset.left = options.offsetLeft || 0;

		var throttledScroll = Materialize.throttle(function() {
			onScroll(options.scrollOffset);
		}, options.throttle || 100);
		var readyScroll = function(){
			$(document).ready(throttledScroll);
		};

		if (!isSpying) {
			jWindow.on(&#x27;scroll&#x27;, readyScroll);
			jWindow.on(&#x27;resize&#x27;, readyScroll);
			isSpying = true;
		}

		// perform a scan once, after current execution context, and after dom is ready
		setTimeout(readyScroll, 0);


		selector.on(&#x27;scrollSpy:enter&#x27;, function() {
			visible = $.grep(visible, function(value) {
	      return value.height() != 0;
	    });

			var $this = $(this);

			if (visible[0]) {
				$(&#x27;a[href=&quot;#&#x27; + visible[0].attr(&#x27;id&#x27;) + &#x27;&quot;]&#x27;).removeClass(&#x27;active&#x27;);
				if ($this.data(&#x27;scrollSpy:id&#x27;) &lt; visible[0].data(&#x27;scrollSpy:id&#x27;)) {
					visible.unshift($(this));
				}
				else {
					visible.push($(this));
				}
			}
			else {
				visible.push($(this));
			}


			$(&#x27;a[href=&quot;#&#x27; + visible[0].attr(&#x27;id&#x27;) + &#x27;&quot;]&#x27;).addClass(&#x27;active&#x27;);
		});
		selector.on(&#x27;scrollSpy:exit&#x27;, function() {
			visible = $.grep(visible, function(value) {
	      return value.height() != 0;
	    });

			if (visible[0]) {
				$(&#x27;a[href=&quot;#&#x27; + visible[0].attr(&#x27;id&#x27;) + &#x27;&quot;]&#x27;).removeClass(&#x27;active&#x27;);
				var $this = $(this);
				visible = $.grep(visible, function(value) {
	        return value.attr(&#x27;id&#x27;) != $this.attr(&#x27;id&#x27;);
	      });
	      if (visible[0]) { // Check if empty
					$(&#x27;a[href=&quot;#&#x27; + visible[0].attr(&#x27;id&#x27;) + &#x27;&quot;]&#x27;).addClass(&#x27;active&#x27;);
	      }
			}
		});

		return selector;
	};

	/**
	 * Listen for window resize events
	 * @param {Object=} options						Optional. Set { throttle: number } to change throttling. Default: 100 ms
	 * @returns {jQuery}		$(window)
	 */
	$.winSizeSpy = function(options) {
		$.winSizeSpy = function() { return jWindow; }; // lock from multiple calls
		options = options || {
			throttle: 100
		};
		return jWindow.on(&#x27;resize&#x27;, Materialize.throttle(onWinSize, options.throttle || 100));
	};

	/**
	 * Enables ScrollSpy on a collection of elements
	 * e.g. $(&#x27;.scrollSpy&#x27;).scrollSpy()
	 * @param {Object=} options	Optional.
											throttle : number -&gt; scrollspy throttling. Default: 100 ms
											offsetTop : number -&gt; offset from top. Default: 0
											offsetRight : number -&gt; offset from right. Default: 0
											offsetBottom : number -&gt; offset from bottom. Default: 0
											offsetLeft : number -&gt; offset from left. Default: 0
	 * @returns {jQuery}
	 */
	$.fn.scrollSpy = function(options) {
		return $.scrollSpy($(this), options);
	};

})(jQuery);
;(function ($) {
  $(document).ready(function() {

    // Function to update labels of text fields
    Materialize.updateTextFields = function() {
      var input_selector = &#x27;input[type=text], input[type=password], input[type=email], input[type=url], input[type=tel], input[type=number], input[type=search], textarea&#x27;;
      $(input_selector).each(function(index, element) {
        var $this = $(this);
        if ($(element).val().length &gt; 0 || element.autofocus || $this.attr(&#x27;placeholder&#x27;) !== undefined) {
          $this.siblings(&#x27;label&#x27;).addClass(&#x27;active&#x27;);
        } else if ($(element)[0].validity) {
          $this.siblings(&#x27;label&#x27;).toggleClass(&#x27;active&#x27;, $(element)[0].validity.badInput === true);
        } else {
          $this.siblings(&#x27;label&#x27;).removeClass(&#x27;active&#x27;);
        }
      });
    };

    // Text based inputs
    var input_selector = &#x27;input[type=text], input[type=password], input[type=email], input[type=url], input[type=tel], input[type=number], input[type=search], textarea&#x27;;

    // Add active if form auto complete
    $(document).on(&#x27;change&#x27;, input_selector, function () {
      if($(this).val().length !== 0 || $(this).attr(&#x27;placeholder&#x27;) !== undefined) {
        $(this).siblings(&#x27;label&#x27;).addClass(&#x27;active&#x27;);
      }
      validate_field($(this));
    });

    // Add active if input element has been pre-populated on document ready
    $(document).ready(function() {
      Materialize.updateTextFields();
    });

    // HTML DOM FORM RESET handling
    $(document).on(&#x27;reset&#x27;, function(e) {
      var formReset = $(e.target);
      if (formReset.is(&#x27;form&#x27;)) {
        formReset.find(input_selector).removeClass(&#x27;valid&#x27;).removeClass(&#x27;invalid&#x27;);
        formReset.find(input_selector).each(function () {
          if ($(this).attr(&#x27;value&#x27;) === &#x27;&#x27;) {
            $(this).siblings(&#x27;label&#x27;).removeClass(&#x27;active&#x27;);
          }
        });

        // Reset select
        formReset.find(&#x27;select.initialized&#x27;).each(function () {
          var reset_text = formReset.find(&#x27;option[selected]&#x27;).text();
          formReset.siblings(&#x27;input.select-dropdown&#x27;).val(reset_text);
        });
      }
    });

    // Add active when element has focus
    $(document).on(&#x27;focus&#x27;, input_selector, function () {
      $(this).siblings(&#x27;label, .prefix&#x27;).addClass(&#x27;active&#x27;);
    });

    $(document).on(&#x27;blur&#x27;, input_selector, function () {
      var $inputElement = $(this);
      var selector = &quot;.prefix&quot;;

      if ($inputElement.val().length === 0 &amp;&amp; $inputElement[0].validity.badInput !== true &amp;&amp; $inputElement.attr(&#x27;placeholder&#x27;) === undefined) {
        selector += &quot;, label&quot;;
      }

      $inputElement.siblings(selector).removeClass(&#x27;active&#x27;);

      validate_field($inputElement);
    });

    window.validate_field = function(object) {
      var hasLength = object.attr(&#x27;data-length&#x27;) !== undefined;
      var lenAttr = parseInt(object.attr(&#x27;data-length&#x27;));
      var len = object.val().length;

      if (object.val().length === 0 &amp;&amp; object[0].validity.badInput === false) {
        if (object.hasClass(&#x27;validate&#x27;)) {
          object.removeClass(&#x27;valid&#x27;);
          object.removeClass(&#x27;invalid&#x27;);
        }
      }
      else {
        if (object.hasClass(&#x27;validate&#x27;)) {
          // Check for character counter attributes
          if ((object.is(&#x27;:valid&#x27;) &amp;&amp; hasLength &amp;&amp; (len &lt;= lenAttr)) || (object.is(&#x27;:valid&#x27;) &amp;&amp; !hasLength)) {
            object.removeClass(&#x27;invalid&#x27;);
            object.addClass(&#x27;valid&#x27;);
          }
          else {
            object.removeClass(&#x27;valid&#x27;);
            object.addClass(&#x27;invalid&#x27;);
          }
        }
      }
    };

    // Radio and Checkbox focus class
    var radio_checkbox = &#x27;input[type=radio], input[type=checkbox]&#x27;;
    $(document).on(&#x27;keyup.radio&#x27;, radio_checkbox, function(e) {
      // TAB, check if tabbing to radio or checkbox.
      if (e.which === 9) {
        $(this).addClass(&#x27;tabbed&#x27;);
        var $this = $(this);
        $this.one(&#x27;blur&#x27;, function(e) {

          $(this).removeClass(&#x27;tabbed&#x27;);
        });
        return;
      }
    });

    // Textarea Auto Resize
    var hiddenDiv = $(&#x27;.hiddendiv&#x27;).first();
    if (!hiddenDiv.length) {
      hiddenDiv = $(&#x27;&lt;div class=&quot;hiddendiv common&quot;&gt;&lt;/div&gt;&#x27;);
      $(&#x27;body&#x27;).append(hiddenDiv);
    }
    var text_area_selector = &#x27;.materialize-textarea&#x27;;

    function textareaAutoResize($textarea) {
      // Set font properties of hiddenDiv

      var fontFamily = $textarea.css(&#x27;font-family&#x27;);
      var fontSize = $textarea.css(&#x27;font-size&#x27;);
      var lineHeight = $textarea.css(&#x27;line-height&#x27;);

      if (fontSize) { hiddenDiv.css(&#x27;font-size&#x27;, fontSize); }
      if (fontFamily) { hiddenDiv.css(&#x27;font-family&#x27;, fontFamily); }
      if (lineHeight) { hiddenDiv.css(&#x27;line-height&#x27;, lineHeight); }

      if ($textarea.attr(&#x27;wrap&#x27;) === &quot;off&quot;) {
        hiddenDiv.css(&#x27;overflow-wrap&#x27;, &quot;normal&quot;)
                 .css(&#x27;white-space&#x27;, &quot;pre&quot;);
      }

      hiddenDiv.text($textarea.val() + &#x27;\n&#x27;);
      var content = hiddenDiv.html().replace(/\n/g, &#x27;&lt;br&gt;&#x27;);
      hiddenDiv.html(content);


      // When textarea is hidden, width goes crazy.
      // Approximate with half of window size

      if ($textarea.is(&#x27;:visible&#x27;)) {
        hiddenDiv.css(&#x27;width&#x27;, $textarea.width());
      }
      else {
        hiddenDiv.css(&#x27;width&#x27;, $(window).width()/2);
      }

      $textarea.css(&#x27;height&#x27;, hiddenDiv.height());
    }

    $(text_area_selector).each(function () {
      var $textarea = $(this);
      if ($textarea.val().length) {
        textareaAutoResize($textarea);
      }
    });

    $(&#x27;body&#x27;).on(&#x27;keyup keydown autoresize&#x27;, text_area_selector, function () {
      textareaAutoResize($(this));
    });

    // File Input Path
    $(document).on(&#x27;change&#x27;, &#x27;.file-field input[type=&quot;file&quot;]&#x27;, function () {
      var file_field = $(this).closest(&#x27;.file-field&#x27;);
      var path_input = file_field.find(&#x27;input.file-path&#x27;);
      var files      = $(this)[0].files;
      var file_names = [];
      for (var i = 0; i &lt; files.length; i++) {
        file_names.push(files[i].name);
      }
      path_input.val(file_names.join(&quot;, &quot;));
      path_input.trigger(&#x27;change&#x27;);
    });

    /****************
    *  Range Input  *
    ****************/

    var range_type = &#x27;input[type=range]&#x27;;
    var range_mousedown = false;
    var left;

    $(range_type).each(function () {
      var thumb = $(&#x27;&lt;span class=&quot;thumb&quot;&gt;&lt;span class=&quot;value&quot;&gt;&lt;/span&gt;&lt;/span&gt;&#x27;);
      $(this).after(thumb);
    });

    var range_wrapper = &#x27;.range-field&#x27;;
    $(document).on(&#x27;change&#x27;, range_type, function(e) {
      var thumb = $(this).siblings(&#x27;.thumb&#x27;);
      thumb.find(&#x27;.value&#x27;).html($(this).val());
    });

    $(document).on(&#x27;input mousedown touchstart&#x27;, range_type, function(e) {
      var thumb = $(this).siblings(&#x27;.thumb&#x27;);
      var width = $(this).outerWidth();

      // If thumb indicator does not exist yet, create it
      if (thumb.length &lt;= 0) {
        thumb = $(&#x27;&lt;span class=&quot;thumb&quot;&gt;&lt;span class=&quot;value&quot;&gt;&lt;/span&gt;&lt;/span&gt;&#x27;);
        $(this).after(thumb);
      }

      // Set indicator value
      thumb.find(&#x27;.value&#x27;).html($(this).val());

      range_mousedown = true;
      $(this).addClass(&#x27;active&#x27;);

      if (!thumb.hasClass(&#x27;active&#x27;)) {
        thumb.velocity({ height: &quot;30px&quot;, width: &quot;30px&quot;, top: &quot;-20px&quot;, marginLeft: &quot;-15px&quot;}, { duration: 300, easing: &#x27;easeOutExpo&#x27; });
      }

      if (e.type !== &#x27;input&#x27;) {
        if(e.pageX === undefined || e.pageX === null){//mobile
           left = e.originalEvent.touches[0].pageX - $(this).offset().left;
        }
        else{ // desktop
           left = e.pageX - $(this).offset().left;
        }
        if (left &lt; 0) {
          left = 0;
        }
        else if (left &gt; width) {
          left = width;
        }
        thumb.addClass(&#x27;active&#x27;).css(&#x27;left&#x27;, left);
      }

      thumb.find(&#x27;.value&#x27;).html($(this).val());
    });

    $(document).on(&#x27;mouseup touchend&#x27;, range_wrapper, function() {
      range_mousedown = false;
      $(this).removeClass(&#x27;active&#x27;);
    });

    $(document).on(&#x27;mousemove touchmove&#x27;, range_wrapper, function(e) {
      var thumb = $(this).children(&#x27;.thumb&#x27;);
      var left;
      if (range_mousedown) {
        if (!thumb.hasClass(&#x27;active&#x27;)) {
          thumb.velocity({ height: &#x27;30px&#x27;, width: &#x27;30px&#x27;, top: &#x27;-20px&#x27;, marginLeft: &#x27;-15px&#x27;}, { duration: 300, easing: &#x27;easeOutExpo&#x27; });
        }
        if (e.pageX === undefined || e.pageX === null) { //mobile
          left = e.originalEvent.touches[0].pageX - $(this).offset().left;
        }
        else{ // desktop
          left = e.pageX - $(this).offset().left;
        }
        var width = $(this).outerWidth();

        if (left &lt; 0) {
          left = 0;
        }
        else if (left &gt; width) {
          left = width;
        }
        thumb.addClass(&#x27;active&#x27;).css(&#x27;left&#x27;, left);
        thumb.find(&#x27;.value&#x27;).html(thumb.siblings(range_type).val());
      }
    });

    $(document).on(&#x27;mouseout touchleave&#x27;, range_wrapper, function() {
      if (!range_mousedown) {

        var thumb = $(this).children(&#x27;.thumb&#x27;);

        if (thumb.hasClass(&#x27;active&#x27;)) {
          thumb.velocity({ height: &#x27;0&#x27;, width: &#x27;0&#x27;, top: &#x27;10px&#x27;, marginLeft: &#x27;-6px&#x27;}, { duration: 100 });
        }
        thumb.removeClass(&#x27;active&#x27;);
      }
    });

    /**************************
     * Auto complete plugin  *
     *************************/
    $.fn.autocomplete = function (options) {
      // Defaults
      var defaults = {
        data: {},
        limit: Infinity,
        onAutocomplete: null
      };

      options = $.extend(defaults, options);

      return this.each(function() {
        var $input = $(this);
        var data = options.data,
            count = 0,
            activeIndex = 0,
            oldVal,
            $inputDiv = $input.closest(&#x27;.input-field&#x27;); // Div to append on

        // Check if data isn&#x27;t empty
        if (!$.isEmptyObject(data)) {
          var $autocomplete = $(&#x27;&lt;ul class=&quot;autocomplete-content dropdown-content&quot;&gt;&lt;/ul&gt;&#x27;);
          var $oldAutocomplete;

          // Append autocomplete element.
          // Prevent double structure init.
          if ($inputDiv.length) {
            $oldAutocomplete = $inputDiv.children(&#x27;.autocomplete-content.dropdown-content&#x27;).first();
            if (!$oldAutocomplete.length) {
              $inputDiv.append($autocomplete); // Set ul in body
            }
          } else {
            $oldAutocomplete = $input.next(&#x27;.autocomplete-content.dropdown-content&#x27;);
            if (!$oldAutocomplete.length) {
              $input.after($autocomplete);
            }
          }
          if ($oldAutocomplete.length) {
            $autocomplete = $oldAutocomplete;
          }

          // Highlight partial match.
          var highlight = function(string, $el) {
            var img = $el.find(&#x27;img&#x27;);
            var matchStart = $el.text().toLowerCase().indexOf(&quot;&quot; + string.toLowerCase() + &quot;&quot;),
                matchEnd = matchStart + string.length - 1,
                beforeMatch = $el.text().slice(0, matchStart),
                matchText = $el.text().slice(matchStart, matchEnd + 1),
                afterMatch = $el.text().slice(matchEnd + 1);
            $el.html(&quot;&lt;span&gt;&quot; + beforeMatch + &quot;&lt;span class=&#x27;highlight&#x27;&gt;&quot; + matchText + &quot;&lt;/span&gt;&quot; + afterMatch + &quot;&lt;/span&gt;&quot;);
            if (img.length) {
              $el.prepend(img);
            }
          };

          // Reset current element position
          var resetCurrentElement = function() {
            activeIndex = 0;
            $autocomplete.find(&#x27;.active&#x27;).removeClass(&#x27;active&#x27;);
          }

          // Perform search
          $input.off(&#x27;keyup.autocomplete&#x27;).on(&#x27;keyup.autocomplete&#x27;, function (e) {
            // Reset count.
            count = 0;

            // Don&#x27;t capture enter or arrow key usage.
            if (e.which === 13 ||
                e.which === 38 ||
                e.which === 40) {
              return;
            }

            var val = $input.val().toLowerCase();

            // Check if the input isn&#x27;t empty
            if (oldVal !== val) {
              $autocomplete.empty();
              resetCurrentElement();

              if (val !== &#x27;&#x27;) {
                for(var key in data) {
                  if (data.hasOwnProperty(key) &amp;&amp;
                      key.toLowerCase().indexOf(val) !== -1 &amp;&amp;
                      key.toLowerCase() !== val) {
                    // Break if past limit
                    if (count &gt;= options.limit) {
                      break;
                    }

                    var autocompleteOption = $(&#x27;&lt;li&gt;&lt;/li&gt;&#x27;);
                    if (!!data[key]) {
                      autocompleteOption.append(&#x27;&lt;img src=&quot;&#x27;+ data[key] +&#x27;&quot; class=&quot;right circle&quot;&gt;&lt;span&gt;&#x27;+ key +&#x27;&lt;/span&gt;&#x27;);
                    } else {
                      autocompleteOption.append(&#x27;&lt;span&gt;&#x27;+ key +&#x27;&lt;/span&gt;&#x27;);
                    }

                    $autocomplete.append(autocompleteOption);
                    highlight(val, autocompleteOption);
                    count++;
                  }
                }
              }
            }

            // Update oldVal
            oldVal = val;
          });

          $input.off(&#x27;keydown.autocomplete&#x27;).on(&#x27;keydown.autocomplete&#x27;, function (e) {
            // Arrow keys and enter key usage
            var keyCode = e.which,
                liElement,
                numItems = $autocomplete.children(&#x27;li&#x27;).length,
                $active = $autocomplete.children(&#x27;.active&#x27;).first();

            // select element on Enter
            if (keyCode === 13) {
              liElement = $autocomplete.children(&#x27;li&#x27;).eq(activeIndex);
              if (liElement.length) {
                liElement.click();
                e.preventDefault();
              }
              return;
            }

            // Capture up and down key
            if ( keyCode === 38 || keyCode === 40 ) {
              e.preventDefault();

              if (keyCode === 38 &amp;&amp;
                  activeIndex &gt; 0) {
                activeIndex--;
              }

              if (keyCode === 40 &amp;&amp;
                  activeIndex &lt; (numItems - 1) &amp;&amp;
                  $active.length) {
                activeIndex++;
              }

              $active.removeClass(&#x27;active&#x27;);
              $autocomplete.children(&#x27;li&#x27;).eq(activeIndex).addClass(&#x27;active&#x27;);
            }
          });

          // Set input value
          $autocomplete.on(&#x27;click&#x27;, &#x27;li&#x27;, function () {
            var text = $(this).text().trim();
            $input.val(text);
            $input.trigger(&#x27;change&#x27;);
            $autocomplete.empty();
            resetCurrentElement();

            // Handle onAutocomplete callback.
            if (typeof(options.onAutocomplete) === &quot;function&quot;) {
              options.onAutocomplete.call(this, text);
            }
          });
        }
      });
    };

  }); // End of $(document).ready

  /*******************
   *  Select Plugin  *
   ******************/
  $.fn.material_select = function (callback) {
    $(this).each(function(){
      var $select = $(this);

      if ($select.hasClass(&#x27;browser-default&#x27;)) {
        return; // Continue to next (return false breaks out of entire loop)
      }

      var multiple = $select.attr(&#x27;multiple&#x27;) ? true : false,
          lastID = $select.data(&#x27;select-id&#x27;); // Tear down structure if Select needs to be rebuilt

      if (lastID) {
        $select.parent().find(&#x27;span.caret&#x27;).remove();
        $select.parent().find(&#x27;input&#x27;).remove();

        $select.unwrap();
        $(&#x27;ul#select-options-&#x27;+lastID).remove();
      }

      // If destroying the select, remove the selelct-id and reset it to it&#x27;s uninitialized state.
      if(callback === &#x27;destroy&#x27;) {
        $select.data(&#x27;select-id&#x27;, null).removeClass(&#x27;initialized&#x27;);
        return;
      }

      var uniqueID = Materialize.guid();
      $select.data(&#x27;select-id&#x27;, uniqueID);
      var wrapper = $(&#x27;&lt;div class=&quot;select-wrapper&quot;&gt;&lt;/div&gt;&#x27;);
      wrapper.addClass($select.attr(&#x27;class&#x27;));
      var options = $(&#x27;&lt;ul id=&quot;select-options-&#x27; + uniqueID +&#x27;&quot; class=&quot;dropdown-content select-dropdown &#x27; + (multiple ? &#x27;multiple-select-dropdown&#x27; : &#x27;&#x27;) + &#x27;&quot;&gt;&lt;/ul&gt;&#x27;),
          selectChildren = $select.children(&#x27;option, optgroup&#x27;),
          valuesSelected = [],
          optionsHover = false;

      var label = $select.find(&#x27;option:selected&#x27;).html() || $select.find(&#x27;option:first&#x27;).html() || &quot;&quot;;

      // Function that renders and appends the option taking into
      // account type and possible image icon.
      var appendOptionWithIcon = function(select, option, type) {
        // Add disabled attr if disabled
        var disabledClass = (option.is(&#x27;:disabled&#x27;)) ? &#x27;disabled &#x27; : &#x27;&#x27;;
        var optgroupClass = (type === &#x27;optgroup-option&#x27;) ? &#x27;optgroup-option &#x27; : &#x27;&#x27;;

        // add icons
        var icon_url = option.data(&#x27;icon&#x27;);
        var classes = option.attr(&#x27;class&#x27;);
        if (!!icon_url) {
          var classString = &#x27;&#x27;;
          if (!!classes) classString = &#x27; class=&quot;&#x27; + classes + &#x27;&quot;&#x27;;

          // Check for multiple type.
          if (type === &#x27;multiple&#x27;) {
            options.append($(&#x27;&lt;li class=&quot;&#x27; + disabledClass + &#x27;&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;&#x27; + icon_url + &#x27;&quot;&#x27; + classString + &#x27;&gt;&lt;span&gt;&lt;input type=&quot;checkbox&quot;&#x27; + disabledClass + &#x27;/&gt;&lt;label&gt;&lt;/label&gt;&#x27; + option.html() + &#x27;&lt;/span&gt;&lt;/li&gt;&#x27;));
          } else {
            options.append($(&#x27;&lt;li class=&quot;&#x27; + disabledClass + optgroupClass + &#x27;&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;&#x27; + icon_url + &#x27;&quot;&#x27; + classString + &#x27;&gt;&lt;span&gt;&#x27; + option.html() + &#x27;&lt;/span&gt;&lt;/li&gt;&#x27;));
          }
          return true;
        }

        // Check for multiple type.
        if (type === &#x27;multiple&#x27;) {
          options.append($(&#x27;&lt;li class=&quot;&#x27; + disabledClass + &#x27;&quot;&gt;&lt;span&gt;&lt;input type=&quot;checkbox&quot;&#x27; + disabledClass + &#x27;/&gt;&lt;label&gt;&lt;/label&gt;&#x27; + option.html() + &#x27;&lt;/span&gt;&lt;/li&gt;&#x27;));
        } else {
          options.append($(&#x27;&lt;li class=&quot;&#x27; + disabledClass + optgroupClass + &#x27;&quot;&gt;&lt;span&gt;&#x27; + option.html() + &#x27;&lt;/span&gt;&lt;/li&gt;&#x27;));
        }
      };

      /* Create dropdown structure. */
      if (selectChildren.length) {
        selectChildren.each(function() {
          if ($(this).is(&#x27;option&#x27;)) {
            // Direct descendant option.
            if (multiple) {
              appendOptionWithIcon($select, $(this), &#x27;multiple&#x27;);

            } else {
              appendOptionWithIcon($select, $(this));
            }
          } else if ($(this).is(&#x27;optgroup&#x27;)) {
            // Optgroup.
            var selectOptions = $(this).children(&#x27;option&#x27;);
            options.append($(&#x27;&lt;li class=&quot;optgroup&quot;&gt;&lt;span&gt;&#x27; + $(this).attr(&#x27;label&#x27;) + &#x27;&lt;/span&gt;&lt;/li&gt;&#x27;));

            selectOptions.each(function() {
              appendOptionWithIcon($select, $(this), &#x27;optgroup-option&#x27;);
            });
          }
        });
      }

      options.find(&#x27;li:not(.optgroup)&#x27;).each(function (i) {
        $(this).click(function (e) {
          // Check if option element is disabled
          if (!$(this).hasClass(&#x27;disabled&#x27;) &amp;&amp; !$(this).hasClass(&#x27;optgroup&#x27;)) {
            var selected = true;

            if (multiple) {
              $(&#x27;input[type=&quot;checkbox&quot;]&#x27;, this).prop(&#x27;checked&#x27;, function(i, v) { return !v; });
              selected = toggleEntryFromArray(valuesSelected, $(this).index(), $select);
              $newSelect.trigger(&#x27;focus&#x27;);
            } else {
              options.find(&#x27;li&#x27;).removeClass(&#x27;active&#x27;);
              $(this).toggleClass(&#x27;active&#x27;);
              $newSelect.val($(this).text());
            }

            activateOption(options, $(this));
            $select.find(&#x27;option&#x27;).eq(i).prop(&#x27;selected&#x27;, selected);
            // Trigger onchange() event
            $select.trigger(&#x27;change&#x27;);
            if (typeof callback !== &#x27;undefined&#x27;) callback();
          }

          e.stopPropagation();
        });
      });

      // Wrap Elements
      $select.wrap(wrapper);
      // Add Select Display Element
      var dropdownIcon = $(&#x27;&lt;span class=&quot;caret&quot;&gt;&amp;#9660;&lt;/span&gt;&#x27;);
      if ($select.is(&#x27;:disabled&#x27;))
        dropdownIcon.addClass(&#x27;disabled&#x27;);

      // escape double quotes
      var sanitizedLabelHtml = label.replace(/&quot;/g, &#x27;&amp;quot;&#x27;);

      var $newSelect = $(&#x27;&lt;input type=&quot;text&quot; class=&quot;select-dropdown&quot; readonly=&quot;true&quot; &#x27; + (($select.is(&#x27;:disabled&#x27;)) ? &#x27;disabled&#x27; : &#x27;&#x27;) + &#x27; data-activates=&quot;select-options-&#x27; + uniqueID +&#x27;&quot; value=&quot;&#x27;+ sanitizedLabelHtml +&#x27;&quot;/&gt;&#x27;);
      $select.before($newSelect);
      $newSelect.before(dropdownIcon);

      $newSelect.after(options);
      // Check if section element is disabled
      if (!$select.is(&#x27;:disabled&#x27;)) {
        $newSelect.dropdown({&#x27;hover&#x27;: false, &#x27;closeOnClick&#x27;: false});
      }

      // Copy tabindex
      if ($select.attr(&#x27;tabindex&#x27;)) {
        $($newSelect[0]).attr(&#x27;tabindex&#x27;, $select.attr(&#x27;tabindex&#x27;));
      }

      $select.addClass(&#x27;initialized&#x27;);

      $newSelect.on({
        &#x27;focus&#x27;: function (){
          if ($(&#x27;ul.select-dropdown&#x27;).not(options[0]).is(&#x27;:visible&#x27;)) {
            $(&#x27;input.select-dropdown&#x27;).trigger(&#x27;close&#x27;);
          }
          if (!options.is(&#x27;:visible&#x27;)) {
            $(this).trigger(&#x27;open&#x27;, [&#x27;focus&#x27;]);
            var label = $(this).val();
            if (multiple &amp;&amp; label.indexOf(&#x27;,&#x27;) &gt;= 0) {
              label = label.split(&#x27;,&#x27;)[0];
            }

            var selectedOption = options.find(&#x27;li&#x27;).filter(function() {
              return $(this).text().toLowerCase() === label.toLowerCase();
            })[0];
            activateOption(options, selectedOption, true);
          }
        },
        &#x27;click&#x27;: function (e){
          e.stopPropagation();
        }
      });

      $newSelect.on(&#x27;blur&#x27;, function() {
        if (!multiple) {
          $(this).trigger(&#x27;close&#x27;);
        }
        options.find(&#x27;li.selected&#x27;).removeClass(&#x27;selected&#x27;);
      });

      options.hover(function() {
        optionsHover = true;
      }, function () {
        optionsHover = false;
      });

      $(window).on({
        &#x27;click&#x27;: function () {
          multiple &amp;&amp; (optionsHover || $newSelect.trigger(&#x27;close&#x27;));
        }
      });

      // Add initial multiple selections.
      if (multiple) {
        $select.find(&quot;option:selected:not(:disabled)&quot;).each(function () {
          var index = $(this).index();

          toggleEntryFromArray(valuesSelected, index, $select);
          options.find(&quot;li&quot;).eq(index).find(&quot;:checkbox&quot;).prop(&quot;checked&quot;, true);
        });
      }

      /**
       * Make option as selected and scroll to selected position
       * @param {jQuery} collection  Select options jQuery element
       * @param {Element} newOption  element of the new option
       * @param {Boolean} firstActivation  If on first activation of select
       */
      var activateOption = function(collection, newOption, firstActivation) {
        if (newOption) {
          collection.find(&#x27;li.selected&#x27;).removeClass(&#x27;selected&#x27;);
          var option = $(newOption);
          option.addClass(&#x27;selected&#x27;);
          if (!multiple || !!firstActivation) {
            options.scrollTo(option);
          }
        }
      };

      // Allow user to search by typing
      // this array is cleared after 1 second
      var filterQuery = [],
          onKeyDown = function(e){
            // TAB - switch to another input
            if(e.which == 9){
              $newSelect.trigger(&#x27;close&#x27;);
              return;
            }

            // ARROW DOWN WHEN SELECT IS CLOSED - open select options
            if(e.which == 40 &amp;&amp; !options.is(&#x27;:visible&#x27;)){
              $newSelect.trigger(&#x27;open&#x27;);
              return;
            }

            // ENTER WHEN SELECT IS CLOSED - submit form
            if(e.which == 13 &amp;&amp; !options.is(&#x27;:visible&#x27;)){
              return;
            }

            e.preventDefault();

            // CASE WHEN USER TYPE LETTERS
            var letter = String.fromCharCode(e.which).toLowerCase(),
                nonLetters = [9,13,27,38,40];
            if (letter &amp;&amp; (nonLetters.indexOf(e.which) === -1)) {
              filterQuery.push(letter);

              var string = filterQuery.join(&#x27;&#x27;),
                  newOption = options.find(&#x27;li&#x27;).filter(function() {
                    return $(this).text().toLowerCase().indexOf(string) === 0;
                  })[0];

              if (newOption) {
                activateOption(options, newOption);
              }
            }

            // ENTER - select option and close when select options are opened
            if (e.which == 13) {
              var activeOption = options.find(&#x27;li.selected:not(.disabled)&#x27;)[0];
              if(activeOption){
                $(activeOption).trigger(&#x27;click&#x27;);
                if (!multiple) {
                  $newSelect.trigger(&#x27;close&#x27;);
                }
              }
            }

            // ARROW DOWN - move to next not disabled option
            if (e.which == 40) {
              if (options.find(&#x27;li.selected&#x27;).length) {
                newOption = options.find(&#x27;li.selected&#x27;).next(&#x27;li:not(.disabled)&#x27;)[0];
              } else {
                newOption = options.find(&#x27;li:not(.disabled)&#x27;)[0];
              }
              activateOption(options, newOption);
            }

            // ESC - close options
            if (e.which == 27) {
              $newSelect.trigger(&#x27;close&#x27;);
            }

            // ARROW UP - move to previous not disabled option
            if (e.which == 38) {
              newOption = options.find(&#x27;li.selected&#x27;).prev(&#x27;li:not(.disabled)&#x27;)[0];
              if(newOption)
                activateOption(options, newOption);
            }

            // Automaticaly clean filter query so user can search again by starting letters
            setTimeout(function(){ filterQuery = []; }, 1000);
          };

      $newSelect.on(&#x27;keydown&#x27;, onKeyDown);
    });

    function toggleEntryFromArray(entriesArray, entryIndex, select) {
      var index = entriesArray.indexOf(entryIndex),
          notAdded = index === -1;

      if (notAdded) {
        entriesArray.push(entryIndex);
      } else {
        entriesArray.splice(index, 1);
      }

      select.siblings(&#x27;ul.dropdown-content&#x27;).find(&#x27;li&#x27;).eq(entryIndex).toggleClass(&#x27;active&#x27;);

      // use notAdded instead of true (to detect if the option is selected or not)
      select.find(&#x27;option&#x27;).eq(entryIndex).prop(&#x27;selected&#x27;, notAdded);
      setValueToInput(entriesArray, select);

      return notAdded;
    }

    function setValueToInput(entriesArray, select) {
      var value = &#x27;&#x27;;

      for (var i = 0, count = entriesArray.length; i &lt; count; i++) {
        var text = select.find(&#x27;option&#x27;).eq(entriesArray[i]).text();

        i === 0 ? value += text : value += &#x27;, &#x27; + text;
      }

      if (value === &#x27;&#x27;) {
        value = select.find(&#x27;option:disabled&#x27;).eq(0).text();
      }

      select.siblings(&#x27;input.select-dropdown&#x27;).val(value);
    }
  };

}( jQuery ));
;(function ($) {

  var methods = {

    init : function(options) {
      var defaults = {
        indicators: true,
        height: 400,
        transition: 500,
        interval: 6000
      };
      options = $.extend(defaults, options);

      return this.each(function() {

        // For each slider, we want to keep track of
        // which slide is active and its associated content
        var $this = $(this);
        var $slider = $this.find(&#x27;ul.slides&#x27;).first();
        var $slides = $slider.find(&#x27;&gt; li&#x27;);
        var $active_index = $slider.find(&#x27;.active&#x27;).index();
        var $active, $indicators, $interval;
        if ($active_index != -1) { $active = $slides.eq($active_index); }

        // Transitions the caption depending on alignment
        function captionTransition(caption, duration) {
          if (caption.hasClass(&quot;center-align&quot;)) {
            caption.velocity({opacity: 0, translateY: -100}, {duration: duration, queue: false});
          }
          else if (caption.hasClass(&quot;right-align&quot;)) {
            caption.velocity({opacity: 0, translateX: 100}, {duration: duration, queue: false});
          }
          else if (caption.hasClass(&quot;left-align&quot;)) {
            caption.velocity({opacity: 0, translateX: -100}, {duration: duration, queue: false});
          }
        }

        // This function will transition the slide to any index of the next slide
        function moveToSlide(index) {
          // Wrap around indices.
          if (index &gt;= $slides.length) index = 0;
          else if (index &lt; 0) index = $slides.length -1;

          $active_index = $slider.find(&#x27;.active&#x27;).index();

          // Only do if index changes
          if ($active_index != index) {
            $active = $slides.eq($active_index);
            $caption = $active.find(&#x27;.caption&#x27;);

            $active.removeClass(&#x27;active&#x27;);
            $active.velocity({opacity: 0}, {duration: options.transition, queue: false, easing: &#x27;easeOutQuad&#x27;,
                              complete: function() {
                                $slides.not(&#x27;.active&#x27;).velocity({opacity: 0, translateX: 0, translateY: 0}, {duration: 0, queue: false});
                              } });
            captionTransition($caption, options.transition);


            // Update indicators
            if (options.indicators) {
              $indicators.eq($active_index).removeClass(&#x27;active&#x27;);
            }

            $slides.eq(index).velocity({opacity: 1}, {duration: options.transition, queue: false, easing: &#x27;easeOutQuad&#x27;});
            $slides.eq(index).find(&#x27;.caption&#x27;).velocity({opacity: 1, translateX: 0, translateY: 0}, {duration: options.transition, delay: options.transition, queue: false, easing: &#x27;easeOutQuad&#x27;});
            $slides.eq(index).addClass(&#x27;active&#x27;);


            // Update indicators
            if (options.indicators) {
              $indicators.eq(index).addClass(&#x27;active&#x27;);
            }
          }
        }

        // Set height of slider
        // If fullscreen, do nothing
        if (!$this.hasClass(&#x27;fullscreen&#x27;)) {
          if (options.indicators) {
            // Add height if indicators are present
            $this.height(options.height + 40);
          }
          else {
            $this.height(options.height);
          }
          $slider.height(options.height);
        }


        // Set initial positions of captions
        $slides.find(&#x27;.caption&#x27;).each(function () {
          captionTransition($(this), 0);
        });

        // Move img src into background-image
        $slides.find(&#x27;img&#x27;).each(function () {
          var placeholderBase64 = &#x27;data:image/gif;base64,R0lGODlhAQABAIABAP///wAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==&#x27;;
          if ($(this).attr(&#x27;src&#x27;) !== placeholderBase64) {
            $(this).css(&#x27;background-image&#x27;, &#x27;url(&#x27; + $(this).attr(&#x27;src&#x27;) + &#x27;)&#x27; );
            $(this).attr(&#x27;src&#x27;, placeholderBase64);
          }
        });

        // dynamically add indicators
        if (options.indicators) {
          $indicators = $(&#x27;&lt;ul class=&quot;indicators&quot;&gt;&lt;/ul&gt;&#x27;);
          $slides.each(function( index ) {
            var $indicator = $(&#x27;&lt;li class=&quot;indicator-item&quot;&gt;&lt;/li&gt;&#x27;);

            // Handle clicks on indicators
            $indicator.click(function () {
              var $parent = $slider.parent();
              var curr_index = $parent.find($(this)).index();
              moveToSlide(curr_index);

              // reset interval
              clearInterval($interval);
              $interval = setInterval(
                function(){
                  $active_index = $slider.find(&#x27;.active&#x27;).index();
                  if ($slides.length == $active_index + 1) $active_index = 0; // loop to start
                  else $active_index += 1;

                  moveToSlide($active_index);

                }, options.transition + options.interval
              );
            });
            $indicators.append($indicator);
          });
          $this.append($indicators);
          $indicators = $this.find(&#x27;ul.indicators&#x27;).find(&#x27;li.indicator-item&#x27;);
        }

        if ($active) {
          $active.show();
        }
        else {
          $slides.first().addClass(&#x27;active&#x27;).velocity({opacity: 1}, {duration: options.transition, queue: false, easing: &#x27;easeOutQuad&#x27;});

          $active_index = 0;
          $active = $slides.eq($active_index);

          // Update indicators
          if (options.indicators) {
            $indicators.eq($active_index).addClass(&#x27;active&#x27;);
          }
        }

        // Adjust height to current slide
        $active.find(&#x27;img&#x27;).each(function() {
          $active.find(&#x27;.caption&#x27;).velocity({opacity: 1, translateX: 0, translateY: 0}, {duration: options.transition, queue: false, easing: &#x27;easeOutQuad&#x27;});
        });

        // auto scroll
        $interval = setInterval(
          function(){
            $active_index = $slider.find(&#x27;.active&#x27;).index();
            moveToSlide($active_index + 1);

          }, options.transition + options.interval
        );


        // HammerJS, Swipe navigation

        // Touch Event
        var panning = false;
        var swipeLeft = false;
        var swipeRight = false;

        $this.hammer({
            prevent_default: false
        }).bind(&#x27;pan&#x27;, function(e) {
          if (e.gesture.pointerType === &quot;touch&quot;) {

            // reset interval
            clearInterval($interval);

            var direction = e.gesture.direction;
            var x = e.gesture.deltaX;
            var velocityX = e.gesture.velocityX;
            var velocityY = e.gesture.velocityY;

            $curr_slide = $slider.find(&#x27;.active&#x27;);
            if (Math.abs(velocityX) &gt; Math.abs(velocityY)) {
              $curr_slide.velocity({ translateX: x
                  }, {duration: 50, queue: false, easing: &#x27;easeOutQuad&#x27;});
            }

            // Swipe Left
            if (direction === 4 &amp;&amp; (x &gt; ($this.innerWidth() / 2) || velocityX &lt; -0.65)) {
              swipeRight = true;
            }
            // Swipe Right
            else if (direction === 2 &amp;&amp; (x &lt; (-1 * $this.innerWidth() / 2) || velocityX &gt; 0.65)) {
              swipeLeft = true;
            }

            // Make Slide Behind active slide visible
            var next_slide;
            if (swipeLeft) {
              next_slide = $curr_slide.next();
              if (next_slide.length === 0) {
                next_slide = $slides.first();
              }
              next_slide.velocity({ opacity: 1
                  }, {duration: 300, queue: false, easing: &#x27;easeOutQuad&#x27;});
            }
            if (swipeRight) {
              next_slide = $curr_slide.prev();
              if (next_slide.length === 0) {
                next_slide = $slides.last();
              }
              next_slide.velocity({ opacity: 1
                  }, {duration: 300, queue: false, easing: &#x27;easeOutQuad&#x27;});
            }


          }

        }).bind(&#x27;panend&#x27;, function(e) {
          if (e.gesture.pointerType === &quot;touch&quot;) {

            $curr_slide = $slider.find(&#x27;.active&#x27;);
            panning = false;
            curr_index = $slider.find(&#x27;.active&#x27;).index();

            if (!swipeRight &amp;&amp; !swipeLeft || $slides.length &lt;=1) {
              // Return to original spot
              $curr_slide.velocity({ translateX: 0
                  }, {duration: 300, queue: false, easing: &#x27;easeOutQuad&#x27;});
            }
            else if (swipeLeft) {
              moveToSlide(curr_index + 1);
              $curr_slide.velocity({translateX: -1 * $this.innerWidth() }, {duration: 300, queue: false, easing: &#x27;easeOutQuad&#x27;,
                                    complete: function() {
                                      $curr_slide.velocity({opacity: 0, translateX: 0}, {duration: 0, queue: false});
                                    } });
            }
            else if (swipeRight) {
              moveToSlide(curr_index - 1);
              $curr_slide.velocity({translateX: $this.innerWidth() }, {duration: 300, queue: false, easing: &#x27;easeOutQuad&#x27;,
                                    complete: function() {
                                      $curr_slide.velocity({opacity: 0, translateX: 0}, {duration: 0, queue: false});
                                    } });
            }
            swipeLeft = false;
            swipeRight = false;

            // Restart interval
            clearInterval($interval);
            $interval = setInterval(
              function(){
                $active_index = $slider.find(&#x27;.active&#x27;).index();
                if ($slides.length == $active_index + 1) $active_index = 0; // loop to start
                else $active_index += 1;

                moveToSlide($active_index);

              }, options.transition + options.interval
            );
          }
        });

        $this.on(&#x27;sliderPause&#x27;, function() {
          clearInterval($interval);
        });

        $this.on(&#x27;sliderStart&#x27;, function() {
          clearInterval($interval);
          $interval = setInterval(
            function(){
              $active_index = $slider.find(&#x27;.active&#x27;).index();
              if ($slides.length == $active_index + 1) $active_index = 0; // loop to start
              else $active_index += 1;

              moveToSlide($active_index);

            }, options.transition + options.interval
          );
        });

        $this.on(&#x27;sliderNext&#x27;, function() {
          $active_index = $slider.find(&#x27;.active&#x27;).index();
          moveToSlide($active_index + 1);
        });

        $this.on(&#x27;sliderPrev&#x27;, function() {
          $active_index = $slider.find(&#x27;.active&#x27;).index();
          moveToSlide($active_index - 1);
        });

      });



    },
    pause : function() {
      $(this).trigger(&#x27;sliderPause&#x27;);
    },
    start : function() {
      $(this).trigger(&#x27;sliderStart&#x27;);
    },
    next : function() {
      $(this).trigger(&#x27;sliderNext&#x27;);
    },
    prev : function() {
      $(this).trigger(&#x27;sliderPrev&#x27;);
    }
  };


  $.fn.slider = function(methodOrOptions) {
    if ( methods[methodOrOptions] ) {
      return methods[ methodOrOptions ].apply( this, Array.prototype.slice.call( arguments, 1 ));
    } else if ( typeof methodOrOptions === &#x27;object&#x27; || ! methodOrOptions ) {
      // Default to &quot;init&quot;
      return methods.init.apply( this, arguments );
    } else {
      $.error( &#x27;Method &#x27; +  methodOrOptions + &#x27; does not exist on jQuery.tooltip&#x27; );
    }
  }; // Plugin end
}( jQuery ));
;(function ($) {
  $(document).ready(function() {

    $(document).on(&#x27;click.card&#x27;, &#x27;.card&#x27;, function (e) {
      if ($(this).find(&#x27;&gt; .card-reveal&#x27;).length) {
        if ($(e.target).is($(&#x27;.card-reveal .card-title&#x27;)) || $(e.target).is($(&#x27;.card-reveal .card-title i&#x27;))) {
          // Make Reveal animate down and display none
          $(this).find(&#x27;.card-reveal&#x27;).velocity(
            {translateY: 0}, {
              duration: 225,
              queue: false,
              easing: &#x27;easeInOutQuad&#x27;,
              complete: function() { $(this).css({ display: &#x27;none&#x27;}); }
            }
          );
        }
        else if ($(e.target).is($(&#x27;.card .activator&#x27;)) ||
                 $(e.target).is($(&#x27;.card .activator i&#x27;)) ) {
          $(e.target).closest(&#x27;.card&#x27;).css(&#x27;overflow&#x27;, &#x27;hidden&#x27;);
          $(this).find(&#x27;.card-reveal&#x27;).css({ display: &#x27;block&#x27;}).velocity(&quot;stop&quot;, false).velocity({translateY: &#x27;-100%&#x27;}, {duration: 300, queue: false, easing: &#x27;easeInOutQuad&#x27;});
        }
      }
    });

  });
}( jQuery ));;(function ($) {
  var materialChipsDefaults = {
    data: [],
    placeholder: &#x27;&#x27;,
    secondaryPlaceholder: &#x27;&#x27;,
    autocompleteData: {},
    autocompleteLimit: Infinity,
  };

  $(document).ready(function() {
    // Handle removal of static chips.
    $(document).on(&#x27;click&#x27;, &#x27;.chip .close&#x27;, function(e){
      var $chips = $(this).closest(&#x27;.chips&#x27;);
      if ($chips.attr(&#x27;data-initialized&#x27;)) {
        return;
      }
      $(this).closest(&#x27;.chip&#x27;).remove();
    });
  });

  $.fn.material_chip = function (options) {
    var self = this;
    this.$el = $(this);
    this.$document = $(document);
    this.SELS = {
      CHIPS: &#x27;.chips&#x27;,
      CHIP: &#x27;.chip&#x27;,
      INPUT: &#x27;input&#x27;,
      DELETE: &#x27;.material-icons&#x27;,
      SELECTED_CHIP: &#x27;.selected&#x27;,
    };

    if (&#x27;data&#x27; === options) {
      return this.$el.data(&#x27;chips&#x27;);
    }

    var curr_options = $.extend({}, materialChipsDefaults, options);
    self.hasAutocomplete = !$.isEmptyObject(curr_options.autocompleteData);

    // Initialize
    this.init = function() {
      var i = 0;
      var chips;
      self.$el.each(function(){
        var $chips = $(this);
        var chipId = Materialize.guid();
        self.chipId = chipId;

        if (!curr_options.data || !(curr_options.data instanceof Array)) {
          curr_options.data = [];
        }
        $chips.data(&#x27;chips&#x27;, curr_options.data);
        $chips.attr(&#x27;data-index&#x27;, i);
        $chips.attr(&#x27;data-initialized&#x27;, true);

        if (!$chips.hasClass(self.SELS.CHIPS)) {
          $chips.addClass(&#x27;chips&#x27;);
        }

        self.chips($chips, chipId);
        i++;
      });
    };

    this.handleEvents = function() {
      var SELS = self.SELS;

      self.$document.off(&#x27;click.chips-focus&#x27;, SELS.CHIPS).on(&#x27;click.chips-focus&#x27;, SELS.CHIPS, function(e){
        $(e.target).find(SELS.INPUT).focus();
      });

      self.$document.off(&#x27;click.chips-select&#x27;, SELS.CHIP).on(&#x27;click.chips-select&#x27;, SELS.CHIP, function(e){
        var $chip = $(e.target);
        if ($chip.length) {
          var wasSelected = $chip.hasClass(&#x27;selected&#x27;);
          var $chips = $chip.closest(SELS.CHIPS);
          $(SELS.CHIP).removeClass(&#x27;selected&#x27;);

          if (!wasSelected) {
            self.selectChip($chip.index(), $chips);
          }
        }
      });

      self.$document.off(&#x27;keydown.chips&#x27;).on(&#x27;keydown.chips&#x27;, function(e){
        if ($(e.target).is(&#x27;input, textarea&#x27;)) {
          return;
        }

        // delete
        var $chip = self.$document.find(SELS.CHIP + SELS.SELECTED_CHIP);
        var $chips = $chip.closest(SELS.CHIPS);
        var length = $chip.siblings(SELS.CHIP).length;
        var index;

        if (!$chip.length) {
          return;
        }

        if (e.which === 8 || e.which === 46) {
          e.preventDefault();

          index = $chip.index();
          self.deleteChip(index, $chips);

          var selectIndex = null;
          if ((index + 1) &lt; length) {
            selectIndex = index;
          } else if (index === length || (index + 1) === length) {
            selectIndex = length - 1;
          }

          if (selectIndex &lt; 0) selectIndex = null;

          if (null !== selectIndex) {
            self.selectChip(selectIndex, $chips);
          }
          if (!length) $chips.find(&#x27;input&#x27;).focus();

        // left
        } else if (e.which === 37) {
          index = $chip.index() - 1;
          if (index &lt; 0) {
            return;
          }
          $(SELS.CHIP).removeClass(&#x27;selected&#x27;);
          self.selectChip(index, $chips);

        // right
        } else if (e.which === 39) {
          index = $chip.index() + 1;
          $(SELS.CHIP).removeClass(&#x27;selected&#x27;);
          if (index &gt; length) {
            $chips.find(&#x27;input&#x27;).focus();
            return;
          }
          self.selectChip(index, $chips);
        }
      });

      self.$document.off(&#x27;focusin.chips&#x27;, SELS.CHIPS + &#x27; &#x27; + SELS.INPUT).on(&#x27;focusin.chips&#x27;, SELS.CHIPS + &#x27; &#x27; + SELS.INPUT, function(e){
        var $currChips = $(e.target).closest(SELS.CHIPS);
        $currChips.addClass(&#x27;focus&#x27;);
        $currChips.siblings(&#x27;label, .prefix&#x27;).addClass(&#x27;active&#x27;);
        $(SELS.CHIP).removeClass(&#x27;selected&#x27;);
      });

      self.$document.off(&#x27;focusout.chips&#x27;, SELS.CHIPS + &#x27; &#x27; + SELS.INPUT).on(&#x27;focusout.chips&#x27;, SELS.CHIPS + &#x27; &#x27; + SELS.INPUT, function(e){
        var $currChips = $(e.target).closest(SELS.CHIPS);
        $currChips.removeClass(&#x27;focus&#x27;);

        // Remove active if empty
        if (!$currChips.data(&#x27;chips&#x27;).length) {
          $currChips.siblings(&#x27;label&#x27;).removeClass(&#x27;active&#x27;);
        }
        $currChips.siblings(&#x27;.prefix&#x27;).removeClass(&#x27;active&#x27;);
      });

      self.$document.off(&#x27;keydown.chips-add&#x27;, SELS.CHIPS + &#x27; &#x27; + SELS.INPUT).on(&#x27;keydown.chips-add&#x27;, SELS.CHIPS + &#x27; &#x27; + SELS.INPUT, function(e){
        var $target = $(e.target);
        var $chips = $target.closest(SELS.CHIPS);
        var chipsLength = $chips.children(SELS.CHIP).length;

        // enter
        if (13 === e.which) {
          // Override enter if autocompleting.
          if (self.hasAutocomplete &amp;&amp;
              $chips.find(&#x27;.autocomplete-content.dropdown-content&#x27;).length &amp;&amp;
              $chips.find(&#x27;.autocomplete-content.dropdown-content&#x27;).children().length) {
            return;
          }

          e.preventDefault();
          self.addChip({tag: $target.val()}, $chips);
          $target.val(&#x27;&#x27;);
          return;
        }

        // delete or left
        if ((8 === e.keyCode || 37 === e.keyCode) &amp;&amp; &#x27;&#x27; === $target.val() &amp;&amp; chipsLength) {
          e.preventDefault();
          self.selectChip(chipsLength - 1, $chips);
          $target.blur();
          return;
        }
      });

      // Click on delete icon in chip.
      self.$document.off(&#x27;click.chips-delete&#x27;, SELS.CHIPS + &#x27; &#x27; + SELS.DELETE).on(&#x27;click.chips-delete&#x27;, SELS.CHIPS + &#x27; &#x27; + SELS.DELETE, function(e) {
        var $target = $(e.target);
        var $chips = $target.closest(SELS.CHIPS);
        var $chip = $target.closest(SELS.CHIP);
        e.stopPropagation();
        self.deleteChip($chip.index(), $chips);
        $chips.find(&#x27;input&#x27;).focus();
      });
    };

    this.chips = function($chips, chipId) {
      var html = &#x27;&#x27;;
      $chips.data(&#x27;chips&#x27;).forEach(function(elem){
        html += self.renderChip(elem);
      });
      html += &#x27;&lt;input id=&quot;&#x27; + chipId +&#x27;&quot; class=&quot;input&quot; placeholder=&quot;&quot;&gt;&#x27;;
      $chips.html(html);
      self.setPlaceholder($chips);

      // Set for attribute for label
      var label = $chips.next(&#x27;label&#x27;);
      if (label.length) {
        label.attr(&#x27;for&#x27;, chipId);

        if ($chips.data(&#x27;chips&#x27;).length) {
          label.addClass(&#x27;active&#x27;);
        }
      }

      // Setup autocomplete if needed.
      var input = $(&#x27;#&#x27; + chipId);
      if (self.hasAutocomplete) {
        input.autocomplete({
          data: curr_options.autocompleteData,
          limit: curr_options.autocompleteLimit,
          onAutocomplete: function(val) {
            self.addChip({tag: val}, $chips);
            input.val(&#x27;&#x27;);
            input.focus();
          },
        })
      }
    };

    this.renderChip = function(elem) {
      if (!elem.tag) return;

      var html = &#x27;&lt;div class=&quot;chip&quot;&gt;&#x27; + elem.tag;
      if (elem.image) {
        html += &#x27; &lt;img src=&quot;&#x27; + elem.image + &#x27;&quot;&gt; &#x27;;
      }
      html += &#x27;&lt;i class=&quot;material-icons close&quot;&gt;close&lt;/i&gt;&#x27;;
      html += &#x27;&lt;/div&gt;&#x27;;
      return html;
    };

    this.setPlaceholder = function($chips) {
      if ($chips.data(&#x27;chips&#x27;).length &amp;&amp; curr_options.placeholder) {
        $chips.find(&#x27;input&#x27;).prop(&#x27;placeholder&#x27;, curr_options.placeholder);

      } else if (!$chips.data(&#x27;chips&#x27;).length &amp;&amp; curr_options.secondaryPlaceholder) {
        $chips.find(&#x27;input&#x27;).prop(&#x27;placeholder&#x27;, curr_options.secondaryPlaceholder);
      }
    };

    this.isValid = function($chips, elem) {
      var chips = $chips.data(&#x27;chips&#x27;);
      var exists = false;
      for (var i=0; i &lt; chips.length; i++) {
        if (chips[i].tag === elem.tag) {
            exists = true;
            return;
        }
      }
      return &#x27;&#x27; !== elem.tag &amp;&amp; !exists;
    };

    this.addChip = function(elem, $chips) {
      if (!self.isValid($chips, elem)) {
        return;
      }
      var chipHtml = self.renderChip(elem);
      var newData = [];
      var oldData = $chips.data(&#x27;chips&#x27;);
      for (var i = 0; i &lt; oldData.length; i++) {
        newData.push(oldData[i]);
      }
      newData.push(elem);

      $chips.data(&#x27;chips&#x27;, newData);
      $(chipHtml).insertBefore($chips.find(&#x27;input&#x27;));
      $chips.trigger(&#x27;chip.add&#x27;, elem);
      self.setPlaceholder($chips);
    };

    this.deleteChip = function(chipIndex, $chips) {
      var chip = $chips.data(&#x27;chips&#x27;)[chipIndex];
      $chips.find(&#x27;.chip&#x27;).eq(chipIndex).remove();

      var newData = [];
      var oldData = $chips.data(&#x27;chips&#x27;);
      for (var i = 0; i &lt; oldData.length; i++) {
        if (i !== chipIndex) {
          newData.push(oldData[i]);
        }
      }

      $chips.data(&#x27;chips&#x27;, newData);
      $chips.trigger(&#x27;chip.delete&#x27;, chip);
      self.setPlaceholder($chips);
    };

    this.selectChip = function(chipIndex, $chips) {
      var $chip = $chips.find(&#x27;.chip&#x27;).eq(chipIndex);
      if ($chip &amp;&amp; false === $chip.hasClass(&#x27;selected&#x27;)) {
        $chip.addClass(&#x27;selected&#x27;);
        $chips.trigger(&#x27;chip.select&#x27;, $chips.data(&#x27;chips&#x27;)[chipIndex]);
      }
    };

    this.getChipsElement = function(index, $chips) {
      return $chips.eq(index);
    };

    // init
    this.init();

    this.handleEvents();
  };
}( jQuery ));
;(function ($) {
  $.fn.pushpin = function (options) {
    // Defaults
    var defaults = {
      top: 0,
      bottom: Infinity,
      offset: 0
    };

    // Remove pushpin event and classes
    if (options === &quot;remove&quot;) {
      this.each(function () {
        if (id = $(this).data(&#x27;pushpin-id&#x27;)) {
          $(window).off(&#x27;scroll.&#x27; + id);
          $(this).removeData(&#x27;pushpin-id&#x27;).removeClass(&#x27;pin-top pinned pin-bottom&#x27;).removeAttr(&#x27;style&#x27;);
        }
      });
      return false;
    }

    options = $.extend(defaults, options);


    $index = 0;
    return this.each(function() {
      var $uniqueId = Materialize.guid(),
          $this = $(this),
          $original_offset = $(this).offset().top;

      function removePinClasses(object) {
        object.removeClass(&#x27;pin-top&#x27;);
        object.removeClass(&#x27;pinned&#x27;);
        object.removeClass(&#x27;pin-bottom&#x27;);
      }

      function updateElements(objects, scrolled) {
        objects.each(function () {
          // Add position fixed (because its between top and bottom)
          if (options.top &lt;= scrolled &amp;&amp; options.bottom &gt;= scrolled &amp;&amp; !$(this).hasClass(&#x27;pinned&#x27;)) {
            removePinClasses($(this));
            $(this).css(&#x27;top&#x27;, options.offset);
            $(this).addClass(&#x27;pinned&#x27;);
          }

          // Add pin-top (when scrolled position is above top)
          if (scrolled &lt; options.top &amp;&amp; !$(this).hasClass(&#x27;pin-top&#x27;)) {
            removePinClasses($(this));
            $(this).css(&#x27;top&#x27;, 0);
            $(this).addClass(&#x27;pin-top&#x27;);
          }

          // Add pin-bottom (when scrolled position is below bottom)
          if (scrolled &gt; options.bottom &amp;&amp; !$(this).hasClass(&#x27;pin-bottom&#x27;)) {
            removePinClasses($(this));
            $(this).addClass(&#x27;pin-bottom&#x27;);
            $(this).css(&#x27;top&#x27;, options.bottom - $original_offset);
          }
        });
      }

      $(this).data(&#x27;pushpin-id&#x27;, $uniqueId);
      updateElements($this, $(window).scrollTop());
      $(window).on(&#x27;scroll.&#x27; + $uniqueId, function () {
        var $scrolled = $(window).scrollTop() + options.offset;
        updateElements($this, $scrolled);
      });

    });

  };
}( jQuery ));;(function ($) {
  $(document).ready(function() {

    // jQuery reverse
    $.fn.reverse = [].reverse;

    // Hover behaviour: make sure this doesn&#x27;t work on .click-to-toggle FABs!
    $(document).on(&#x27;mouseenter.fixedActionBtn&#x27;, &#x27;.fixed-action-btn:not(.click-to-toggle):not(.toolbar)&#x27;, function(e) {
      var $this = $(this);
      openFABMenu($this);
    });
    $(document).on(&#x27;mouseleave.fixedActionBtn&#x27;, &#x27;.fixed-action-btn:not(.click-to-toggle):not(.toolbar)&#x27;, function(e) {
      var $this = $(this);
      closeFABMenu($this);
    });

    // Toggle-on-click behaviour.
    $(document).on(&#x27;click.fabClickToggle&#x27;, &#x27;.fixed-action-btn.click-to-toggle &gt; a&#x27;, function(e) {
      var $this = $(this);
      var $menu = $this.parent();
      if ($menu.hasClass(&#x27;active&#x27;)) {
        closeFABMenu($menu);
      } else {
        openFABMenu($menu);
      }
    });

    // Toolbar transition behaviour.
    $(document).on(&#x27;click.fabToolbar&#x27;, &#x27;.fixed-action-btn.toolbar &gt; a&#x27;, function(e) {
      var $this = $(this);
      var $menu = $this.parent();
      FABtoToolbar($menu);
    });

  });

  $.fn.extend({
    openFAB: function() {
      openFABMenu($(this));
    },
    closeFAB: function() {
      closeFABMenu($(this));
    },
    openToolbar: function() {
      FABtoToolbar($(this));
    },
    closeToolbar: function() {
      toolbarToFAB($(this));
    }
  });


  var openFABMenu = function (btn) {
    var $this = btn;
    if ($this.hasClass(&#x27;active&#x27;) === false) {

      // Get direction option
      var horizontal = $this.hasClass(&#x27;horizontal&#x27;);
      var offsetY, offsetX;

      if (horizontal === true) {
        offsetX = 40;
      } else {
        offsetY = 40;
      }

      $this.addClass(&#x27;active&#x27;);
      $this.find(&#x27;ul .btn-floating&#x27;).velocity(
        { scaleY: &quot;.4&quot;, scaleX: &quot;.4&quot;, translateY: offsetY + &#x27;px&#x27;, translateX: offsetX + &#x27;px&#x27;},
        { duration: 0 });

      var time = 0;
      $this.find(&#x27;ul .btn-floating&#x27;).reverse().each( function () {
        $(this).velocity(
          { opacity: &quot;1&quot;, scaleX: &quot;1&quot;, scaleY: &quot;1&quot;, translateY: &quot;0&quot;, translateX: &#x27;0&#x27;},
          { duration: 80, delay: time });
        time += 40;
      });
    }
  };

  var closeFABMenu = function (btn) {
    var $this = btn;
    // Get direction option
    var horizontal = $this.hasClass(&#x27;horizontal&#x27;);
    var offsetY, offsetX;

    if (horizontal === true) {
      offsetX = 40;
    } else {
      offsetY = 40;
    }

    $this.removeClass(&#x27;active&#x27;);
    var time = 0;
    $this.find(&#x27;ul .btn-floating&#x27;).velocity(&quot;stop&quot;, true);
    $this.find(&#x27;ul .btn-floating&#x27;).velocity(
      { opacity: &quot;0&quot;, scaleX: &quot;.4&quot;, scaleY: &quot;.4&quot;, translateY: offsetY + &#x27;px&#x27;, translateX: offsetX + &#x27;px&#x27;},
      { duration: 80 }
    );
  };


  /**
   * Transform FAB into toolbar
   * @param  {Object}  object jQuery object
   */
  var FABtoToolbar = function(btn) {
    if (btn.attr(&#x27;data-open&#x27;) === &quot;true&quot;) {
      return;
    }

    var offsetX, offsetY, scaleFactor;
    var windowWidth = window.innerWidth;
    var windowHeight = window.innerHeight;
    var btnRect = btn[0].getBoundingClientRect();
    var anchor = btn.find(&#x27;&gt; a&#x27;).first();
    var menu = btn.find(&#x27;&gt; ul&#x27;).first();
    var backdrop = $(&#x27;&lt;div class=&quot;fab-backdrop&quot;&gt;&lt;/div&gt;&#x27;);
    var fabColor = anchor.css(&#x27;background-color&#x27;);
    anchor.append(backdrop);

    offsetX = btnRect.left - (windowWidth / 2) + (btnRect.width / 2);
    offsetY = windowHeight - btnRect.bottom;
    scaleFactor = windowWidth / backdrop.width();
    btn.attr(&#x27;data-origin-bottom&#x27;, btnRect.bottom);
    btn.attr(&#x27;data-origin-left&#x27;, btnRect.left);
    btn.attr(&#x27;data-origin-width&#x27;, btnRect.width);

    // Set initial state
    btn.addClass(&#x27;active&#x27;);
    btn.attr(&#x27;data-open&#x27;, true);
    btn.css({
      &#x27;text-align&#x27;: &#x27;center&#x27;,
      width: &#x27;100%&#x27;,
      bottom: 0,
      left: 0,
      transform: &#x27;translateX(&#x27; + offsetX + &#x27;px)&#x27;,
      transition: &#x27;none&#x27;
    });
    anchor.css({
      transform: &#x27;translateY(&#x27; + -offsetY + &#x27;px)&#x27;,
      transition: &#x27;none&#x27;
    });
    backdrop.css({
      &#x27;background-color&#x27;: fabColor
    });


    setTimeout(function() {
      btn.css({
        transform: &#x27;&#x27;,
        transition: &#x27;transform .2s cubic-bezier(0.550, 0.085, 0.680, 0.530), background-color 0s linear .2s&#x27;
      });
      anchor.css({
        overflow: &#x27;visible&#x27;,
        transform: &#x27;&#x27;,
        transition: &#x27;transform .2s&#x27;
      });

      setTimeout(function() {
        btn.css({
          overflow: &#x27;hidden&#x27;,
          &#x27;background-color&#x27;: fabColor
        });
        backdrop.css({
          transform: &#x27;scale(&#x27; + scaleFactor + &#x27;)&#x27;,
          transition: &#x27;transform .2s cubic-bezier(0.550, 0.055, 0.675, 0.190)&#x27;
        });
        menu.find(&#x27;&gt; li &gt; a&#x27;).css({
          opacity: 1
        });

        // Scroll to close.
        $(window).on(&#x27;scroll.fabToolbarClose&#x27;, function() {
          toolbarToFAB(btn);
          $(window).off(&#x27;scroll.fabToolbarClose&#x27;);
          $(document).off(&#x27;click.fabToolbarClose&#x27;);
        });

        $(document).on(&#x27;click.fabToolbarClose&#x27;, function(e) {
          if (!$(e.target).closest(menu).length) {
            toolbarToFAB(btn);
            $(window).off(&#x27;scroll.fabToolbarClose&#x27;);
            $(document).off(&#x27;click.fabToolbarClose&#x27;);
          }
        });
      }, 100);
    }, 0);
  };

  /**
   * Transform toolbar back into FAB
   * @param  {Object}  object jQuery object
   */
  var toolbarToFAB = function(btn) {
    if (btn.attr(&#x27;data-open&#x27;) !== &quot;true&quot;) {
      return;
    }

    var offsetX, offsetY, scaleFactor;
    var windowWidth = window.innerWidth;
    var windowHeight = window.innerHeight;
    var btnWidth = btn.attr(&#x27;data-origin-width&#x27;);
    var btnBottom = btn.attr(&#x27;data-origin-bottom&#x27;);
    var btnLeft = btn.attr(&#x27;data-origin-left&#x27;);
    var anchor = btn.find(&#x27;&gt; .btn-floating&#x27;).first();
    var menu = btn.find(&#x27;&gt; ul&#x27;).first();
    var backdrop = btn.find(&#x27;.fab-backdrop&#x27;);
    var fabColor = anchor.css(&#x27;background-color&#x27;);

    offsetX = btnLeft - (windowWidth / 2) + (btnWidth / 2);
    offsetY = windowHeight - btnBottom;
    scaleFactor = windowWidth / backdrop.width();


    // Hide backdrop
    btn.removeClass(&#x27;active&#x27;);
    btn.attr(&#x27;data-open&#x27;, false);
    btn.css({
      &#x27;background-color&#x27;: &#x27;transparent&#x27;,
      transition: &#x27;none&#x27;
    });
    anchor.css({
      transition: &#x27;none&#x27;
    });
    backdrop.css({
      transform: &#x27;scale(0)&#x27;,
      &#x27;background-color&#x27;: fabColor
    });
    menu.find(&#x27;&gt; li &gt; a&#x27;).css({
      opacity: &#x27;&#x27;
    });

    setTimeout(function() {
      backdrop.remove();

      // Set initial state.
      btn.css({
        &#x27;text-align&#x27;: &#x27;&#x27;,
        width: &#x27;&#x27;,
        bottom: &#x27;&#x27;,
        left: &#x27;&#x27;,
        overflow: &#x27;&#x27;,
        &#x27;background-color&#x27;: &#x27;&#x27;,
        transform: &#x27;translate3d(&#x27; + -offsetX + &#x27;px,0,0)&#x27;
      });
      anchor.css({
        overflow: &#x27;&#x27;,
        transform: &#x27;translate3d(0,&#x27; + offsetY + &#x27;px,0)&#x27;
      });

      setTimeout(function() {
        btn.css({
          transform: &#x27;translate3d(0,0,0)&#x27;,
          transition: &#x27;transform .2s&#x27;
        });
        anchor.css({
          transform: &#x27;translate3d(0,0,0)&#x27;,
          transition: &#x27;transform .2s cubic-bezier(0.550, 0.055, 0.675, 0.190)&#x27;
        });
      }, 20);
    }, 200);
  };


}( jQuery ));
;(function ($) {
  // Image transition function
  Materialize.fadeInImage = function(selectorOrEl) {
    var element;
    if (typeof(selectorOrEl) === &#x27;string&#x27;) {
      element = $(selectorOrEl);
    } else if (typeof(selectorOrEl) === &#x27;object&#x27;) {
      element = selectorOrEl;
    } else {
      return;
    }
    element.css({opacity: 0});
    $(element).velocity({opacity: 1}, {
      duration: 650,
      queue: false,
      easing: &#x27;easeOutSine&#x27;
    });
    $(element).velocity({opacity: 1}, {
      duration: 1300,
      queue: false,
      easing: &#x27;swing&#x27;,
      step: function(now, fx) {
        fx.start = 100;
        var grayscale_setting = now/100;
        var brightness_setting = 150 - (100 - now)/1.75;

        if (brightness_setting &lt; 100) {
          brightness_setting = 100;
        }
        if (now &gt;= 0) {
          $(this).css({
              &quot;-webkit-filter&quot;: &quot;grayscale(&quot;+grayscale_setting+&quot;)&quot; + &quot;brightness(&quot;+brightness_setting+&quot;%)&quot;,
              &quot;filter&quot;: &quot;grayscale(&quot;+grayscale_setting+&quot;)&quot; + &quot;brightness(&quot;+brightness_setting+&quot;%)&quot;
          });
        }
      }
    });
  };

  // Horizontal staggered list
  Materialize.showStaggeredList = function(selectorOrEl) {
    var element;
    if (typeof(selectorOrEl) === &#x27;string&#x27;) {
      element = $(selectorOrEl);
    } else if (typeof(selectorOrEl) === &#x27;object&#x27;) {
      element = selectorOrEl;
    } else {
      return;
    }
    var time = 0;
    element.find(&#x27;li&#x27;).velocity(
        { translateX: &quot;-100px&quot;},
        { duration: 0 });

    element.find(&#x27;li&#x27;).each(function() {
      $(this).velocity(
        { opacity: &quot;1&quot;, translateX: &quot;0&quot;},
        { duration: 800, delay: time, easing: [60, 10] });
      time += 120;
    });
  };


  $(document).ready(function() {
    // Hardcoded .staggered-list scrollFire
    // var staggeredListOptions = [];
    // $(&#x27;ul.staggered-list&#x27;).each(function (i) {

    //   var label = &#x27;scrollFire-&#x27; + i;
    //   $(this).addClass(label);
    //   staggeredListOptions.push(
    //     {selector: &#x27;ul.staggered-list.&#x27; + label,
    //      offset: 200,
    //      callback: &#x27;showStaggeredList(&quot;ul.staggered-list.&#x27; + label + &#x27;&quot;)&#x27;});
    // });
    // scrollFire(staggeredListOptions);

    // HammerJS, Swipe navigation

    // Touch Event
    var swipeLeft = false;
    var swipeRight = false;


    // Dismissible Collections
    $(&#x27;.dismissable&#x27;).each(function() {
      $(this).hammer({
        prevent_default: false
      }).bind(&#x27;pan&#x27;, function(e) {
        if (e.gesture.pointerType === &quot;touch&quot;) {
          var $this = $(this);
          var direction = e.gesture.direction;
          var x = e.gesture.deltaX;
          var velocityX = e.gesture.velocityX;

          $this.velocity({ translateX: x
              }, {duration: 50, queue: false, easing: &#x27;easeOutQuad&#x27;});

          // Swipe Left
          if (direction === 4 &amp;&amp; (x &gt; ($this.innerWidth() / 2) || velocityX &lt; -0.75)) {
            swipeLeft = true;
          }

          // Swipe Right
          if (direction === 2 &amp;&amp; (x &lt; (-1 * $this.innerWidth() / 2) || velocityX &gt; 0.75)) {
            swipeRight = true;
          }
        }
      }).bind(&#x27;panend&#x27;, function(e) {
        // Reset if collection is moved back into original position
        if (Math.abs(e.gesture.deltaX) &lt; ($(this).innerWidth() / 2)) {
          swipeRight = false;
          swipeLeft = false;
        }

        if (e.gesture.pointerType === &quot;touch&quot;) {
          var $this = $(this);
          if (swipeLeft || swipeRight) {
            var fullWidth;
            if (swipeLeft) { fullWidth = $this.innerWidth(); }
            else { fullWidth = -1 * $this.innerWidth(); }

            $this.velocity({ translateX: fullWidth,
              }, {duration: 100, queue: false, easing: &#x27;easeOutQuad&#x27;, complete:
              function() {
                $this.css(&#x27;border&#x27;, &#x27;none&#x27;);
                $this.velocity({ height: 0, padding: 0,
                  }, {duration: 200, queue: false, easing: &#x27;easeOutQuad&#x27;, complete:
                    function() { $this.remove(); }
                  });
              }
            });
          }
          else {
            $this.velocity({ translateX: 0,
              }, {duration: 100, queue: false, easing: &#x27;easeOutQuad&#x27;});
          }
          swipeLeft = false;
          swipeRight = false;
        }
      });

    });


    // time = 0
    // // Vertical Staggered list
    // $(&#x27;ul.staggered-list.vertical li&#x27;).velocity(
    //     { translateY: &quot;100px&quot;},
    //     { duration: 0 });

    // $(&#x27;ul.staggered-list.vertical li&#x27;).each(function() {
    //   $(this).velocity(
    //     { opacity: &quot;1&quot;, translateY: &quot;0&quot;},
    //     { duration: 800, delay: time, easing: [60, 25] });
    //   time += 120;
    // });

    // // Fade in and Scale
    // $(&#x27;.fade-in.scale&#x27;).velocity(
    //     { scaleX: .4, scaleY: .4, translateX: -600},
    //     { duration: 0});
    // $(&#x27;.fade-in&#x27;).each(function() {
    //   $(this).velocity(
    //     { opacity: &quot;1&quot;, scaleX: 1, scaleY: 1, translateX: 0},
    //     { duration: 800, easing: [60, 10] });
    // });
  });
}( jQuery ));
;(function($) {

  var scrollFireEventsHandled = false;

  // Input: Array of JSON objects {selector, offset, callback}
  Materialize.scrollFire = function(options) {
    var onScroll = function() {
      var windowScroll = window.pageYOffset + window.innerHeight;

      for (var i = 0 ; i &lt; options.length; i++) {
        // Get options from each line
        var value = options[i];
        var selector = value.selector,
            offset = value.offset,
            callback = value.callback;

        var currentElement = document.querySelector(selector);
        if ( currentElement !== null) {
          var elementOffset = currentElement.getBoundingClientRect().top + window.pageYOffset;

          if (windowScroll &gt; (elementOffset + offset)) {
            if (value.done !== true) {
              if (typeof(callback) === &#x27;function&#x27;) {
                callback.call(this, currentElement);
              } else if (typeof(callback) === &#x27;string&#x27;) {
                var callbackFunc = new Function(callback);
                callbackFunc(currentElement);
              }
              value.done = true;
            }
          }
        }
      }
    };


    var throttledScroll = Materialize.throttle(function() {
      onScroll();
    }, options.throttle || 100);

    if (!scrollFireEventsHandled) {
      window.addEventListener(&quot;scroll&quot;, throttledScroll);
      window.addEventListener(&quot;resize&quot;, throttledScroll);
      scrollFireEventsHandled = true;
    }

    // perform a scan once, after current execution context, and after dom is ready
    setTimeout(throttledScroll, 0);
  };

})(jQuery);
;/*!
 * pickadate.js v3.5.0, 2014/04/13
 * By Amsul, http://amsul.ca
 * Hosted on http://amsul.github.io/pickadate.js
 * Licensed under MIT
 */

(function ( factory ) {

    // AMD.
    if ( typeof define == &#x27;function&#x27; &amp;&amp; define.amd )
        define( &#x27;picker&#x27;, [&#x27;jquery&#x27;], factory )

    // Node.js/browserify.
    else if ( typeof exports == &#x27;object&#x27; )
        module.exports = factory( require(&#x27;jquery&#x27;) )

    // Browser globals.
    else this.Picker = factory( jQuery )

}(function( $ ) {

var $window = $( window )
var $document = $( document )
var $html = $( document.documentElement )


/**
 * The picker constructor that creates a blank picker.
 */
function PickerConstructor( ELEMENT, NAME, COMPONENT, OPTIONS ) {

    // If there’s no element, return the picker constructor.
    if ( !ELEMENT ) return PickerConstructor


    var
        IS_DEFAULT_THEME = false,


        // The state of the picker.
        STATE = {
            id: ELEMENT.id || &#x27;P&#x27; + Math.abs( ~~(Math.random() * new Date()) )
        },


        // Merge the defaults and options passed.
        SETTINGS = COMPONENT ? $.extend( true, {}, COMPONENT.defaults, OPTIONS ) : OPTIONS || {},


        // Merge the default classes with the settings classes.
        CLASSES = $.extend( {}, PickerConstructor.klasses(), SETTINGS.klass ),


        // The element node wrapper into a jQuery object.
        $ELEMENT = $( ELEMENT ),


        // Pseudo picker constructor.
        PickerInstance = function() {
            return this.start()
        },


        // The picker prototype.
        P = PickerInstance.prototype = {

            constructor: PickerInstance,

            $node: $ELEMENT,


            /**
             * Initialize everything
             */
            start: function() {

                // If it’s already started, do nothing.
                if ( STATE &amp;&amp; STATE.start ) return P


                // Update the picker states.
                STATE.methods = {}
                STATE.start = true
                STATE.open = false
                STATE.type = ELEMENT.type


                // Confirm focus state, convert into text input to remove UA stylings,
                // and set as readonly to prevent keyboard popup.
                ELEMENT.autofocus = ELEMENT == getActiveElement()
                ELEMENT.readOnly = !SETTINGS.editable
                ELEMENT.id = ELEMENT.id || STATE.id
                if ( ELEMENT.type != &#x27;text&#x27; ) {
                    ELEMENT.type = &#x27;text&#x27;
                }


                // Create a new picker component with the settings.
                P.component = new COMPONENT(P, SETTINGS)


                // Create the picker root with a holder and then prepare it.
                P.$root = $( PickerConstructor._.node(&#x27;div&#x27;, createWrappedComponent(), CLASSES.picker, &#x27;id=&quot;&#x27; + ELEMENT.id + &#x27;_root&quot; tabindex=&quot;0&quot;&#x27;) )
                prepareElementRoot()


                // If there’s a format for the hidden input element, create the element.
                if ( SETTINGS.formatSubmit ) {
                    prepareElementHidden()
                }


                // Prepare the input element.
                prepareElement()


                // Insert the root as specified in the settings.
                if ( SETTINGS.container ) $( SETTINGS.container ).append( P.$root )
                else $ELEMENT.after( P.$root )


                // Bind the default component and settings events.
                P.on({
                    start: P.component.onStart,
                    render: P.component.onRender,
                    stop: P.component.onStop,
                    open: P.component.onOpen,
                    close: P.component.onClose,
                    set: P.component.onSet
                }).on({
                    start: SETTINGS.onStart,
                    render: SETTINGS.onRender,
                    stop: SETTINGS.onStop,
                    open: SETTINGS.onOpen,
                    close: SETTINGS.onClose,
                    set: SETTINGS.onSet
                })


                // Once we’re all set, check the theme in use.
                IS_DEFAULT_THEME = isUsingDefaultTheme( P.$root.children()[ 0 ] )


                // If the element has autofocus, open the picker.
                if ( ELEMENT.autofocus ) {
                    P.open()
                }


                // Trigger queued the “start” and “render” events.
                return P.trigger( &#x27;start&#x27; ).trigger( &#x27;render&#x27; )
            }, //start


            /**
             * Render a new picker
             */
            render: function( entireComponent ) {

                // Insert a new component holder in the root or box.
                if ( entireComponent ) P.$root.html( createWrappedComponent() )
                else P.$root.find( &#x27;.&#x27; + CLASSES.box ).html( P.component.nodes( STATE.open ) )

                // Trigger the queued “render” events.
                return P.trigger( &#x27;render&#x27; )
            }, //render


            /**
             * Destroy everything
             */
            stop: function() {

                // If it’s already stopped, do nothing.
                if ( !STATE.start ) return P

                // Then close the picker.
                P.close()

                // Remove the hidden field.
                if ( P._hidden ) {
                    P._hidden.parentNode.removeChild( P._hidden )
                }

                // Remove the root.
                P.$root.remove()

                // Remove the input class, remove the stored data, and unbind
                // the events (after a tick for IE - see &#x60;P.close&#x60;).
                $ELEMENT.removeClass( CLASSES.input ).removeData( NAME )
                setTimeout( function() {
                    $ELEMENT.off( &#x27;.&#x27; + STATE.id )
                }, 0)

                // Restore the element state
                ELEMENT.type = STATE.type
                ELEMENT.readOnly = false

                // Trigger the queued “stop” events.
                P.trigger( &#x27;stop&#x27; )

                // Reset the picker states.
                STATE.methods = {}
                STATE.start = false

                return P
            }, //stop


            /**
             * Open up the picker
             */
            open: function( dontGiveFocus ) {

                // If it’s already open, do nothing.
                if ( STATE.open ) return P

                // Add the “active” class.
                $ELEMENT.addClass( CLASSES.active )
                aria( ELEMENT, &#x27;expanded&#x27;, true )

                // * A Firefox bug, when &#x60;html&#x60; has &#x60;overflow:hidden&#x60;, results in
                //   killing transitions :(. So add the “opened” state on the next tick.
                //   Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=625289
                setTimeout( function() {

                    // Add the “opened” class to the picker root.
                    P.$root.addClass( CLASSES.opened )
                    aria( P.$root[0], &#x27;hidden&#x27;, false )

                }, 0 )

                // If we have to give focus, bind the element and doc events.
                if ( dontGiveFocus !== false ) {

                    // Set it as open.
                    STATE.open = true

                    // Prevent the page from scrolling.
                    if ( IS_DEFAULT_THEME ) {
                        $html.
                            css( &#x27;overflow&#x27;, &#x27;hidden&#x27; ).
                            css( &#x27;padding-right&#x27;, &#x27;+=&#x27; + getScrollbarWidth() )
                    }

                    // Pass focus to the root element’s jQuery object.
                    // * Workaround for iOS8 to bring the picker’s root into view.
                    P.$root.eq(0).focus()

                    // Bind the document events.
                    $document.on( &#x27;click.&#x27; + STATE.id + &#x27; focusin.&#x27; + STATE.id, function( event ) {

                        var target = event.target

                        // If the target of the event is not the element, close the picker picker.
                        // * Don’t worry about clicks or focusins on the root because those don’t bubble up.
                        //   Also, for Firefox, a click on an &#x60;option&#x60; element bubbles up directly
                        //   to the doc. So make sure the target wasn&#x27;t the doc.
                        // * In Firefox stopPropagation() doesn’t prevent right-click events from bubbling,
                        //   which causes the picker to unexpectedly close when right-clicking it. So make
                        //   sure the event wasn’t a right-click.
                        if ( target != ELEMENT &amp;&amp; target != document &amp;&amp; event.which != 3 ) {

                            // If the target was the holder that covers the screen,
                            // keep the element focused to maintain tabindex.
                            P.close( target === P.$root.children()[0] )
                        }

                    }).on( &#x27;keydown.&#x27; + STATE.id, function( event ) {

                        var
                            // Get the keycode.
                            keycode = event.keyCode,

                            // Translate that to a selection change.
                            keycodeToMove = P.component.key[ keycode ],

                            // Grab the target.
                            target = event.target


                        // On escape, close the picker and give focus.
                        if ( keycode == 27 ) {
                            P.close( true )
                        }


                        // Check if there is a key movement or “enter” keypress on the element.
                        else if ( target == P.$root[0] &amp;&amp; ( keycodeToMove || keycode == 13 ) ) {

                            // Prevent the default action to stop page movement.
                            event.preventDefault()

                            // Trigger the key movement action.
                            if ( keycodeToMove ) {
                                PickerConstructor._.trigger( P.component.key.go, P, [ PickerConstructor._.trigger( keycodeToMove ) ] )
                            }

                            // On “enter”, if the highlighted item isn’t disabled, set the value and close.
                            else if ( !P.$root.find( &#x27;.&#x27; + CLASSES.highlighted ).hasClass( CLASSES.disabled ) ) {
                                P.set( &#x27;select&#x27;, P.component.item.highlight ).close()
                            }
                        }


                        // If the target is within the root and “enter” is pressed,
                        // prevent the default action and trigger a click on the target instead.
                        else if ( $.contains( P.$root[0], target ) &amp;&amp; keycode == 13 ) {
                            event.preventDefault()
                            target.click()
                        }
                    })
                }

                // Trigger the queued “open” events.
                return P.trigger( &#x27;open&#x27; )
            }, //open


            /**
             * Close the picker
             */
            close: function( giveFocus ) {

                // If we need to give focus, do it before changing states.
                if ( giveFocus ) {
                    // ....ah yes! It would’ve been incomplete without a crazy workaround for IE :|
                    // The focus is triggered *after* the close has completed - causing it
                    // to open again. So unbind and rebind the event at the next tick.
                    P.$root.off( &#x27;focus.toOpen&#x27; ).eq(0).focus()
                    setTimeout( function() {
                        P.$root.on( &#x27;focus.toOpen&#x27;, handleFocusToOpenEvent )
                    }, 0 )
                }

                // Remove the “active” class.
                $ELEMENT.removeClass( CLASSES.active )
                aria( ELEMENT, &#x27;expanded&#x27;, false )

                // * A Firefox bug, when &#x60;html&#x60; has &#x60;overflow:hidden&#x60;, results in
                //   killing transitions :(. So remove the “opened” state on the next tick.
                //   Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=625289
                setTimeout( function() {

                    // Remove the “opened” and “focused” class from the picker root.
                    P.$root.removeClass( CLASSES.opened + &#x27; &#x27; + CLASSES.focused )
                    aria( P.$root[0], &#x27;hidden&#x27;, true )

                }, 0 )

                // If it’s already closed, do nothing more.
                if ( !STATE.open ) return P

                // Set it as closed.
                STATE.open = false

                // Allow the page to scroll.
                if ( IS_DEFAULT_THEME ) {
                    $html.
                        css( &#x27;overflow&#x27;, &#x27;&#x27; ).
                        css( &#x27;padding-right&#x27;, &#x27;-=&#x27; + getScrollbarWidth() )
                }

                // Unbind the document events.
                $document.off( &#x27;.&#x27; + STATE.id )

                // Trigger the queued “close” events.
                return P.trigger( &#x27;close&#x27; )
            }, //close


            /**
             * Clear the values
             */
            clear: function( options ) {
                return P.set( &#x27;clear&#x27;, null, options )
            }, //clear


            /**
             * Set something
             */
            set: function( thing, value, options ) {

                var thingItem, thingValue,
                    thingIsObject = $.isPlainObject( thing ),
                    thingObject = thingIsObject ? thing : {}

                // Make sure we have usable options.
                options = thingIsObject &amp;&amp; $.isPlainObject( value ) ? value : options || {}

                if ( thing ) {

                    // If the thing isn’t an object, make it one.
                    if ( !thingIsObject ) {
                        thingObject[ thing ] = value
                    }

                    // Go through the things of items to set.
                    for ( thingItem in thingObject ) {

                        // Grab the value of the thing.
                        thingValue = thingObject[ thingItem ]

                        // First, if the item exists and there’s a value, set it.
                        if ( thingItem in P.component.item ) {
                            if ( thingValue === undefined ) thingValue = null
                            P.component.set( thingItem, thingValue, options )
                        }

                        // Then, check to update the element value and broadcast a change.
                        if ( thingItem == &#x27;select&#x27; || thingItem == &#x27;clear&#x27; ) {
                            $ELEMENT.
                                val( thingItem == &#x27;clear&#x27; ? &#x27;&#x27; : P.get( thingItem, SETTINGS.format ) ).
                                trigger( &#x27;change&#x27; )
                        }
                    }

                    // Render a new picker.
                    P.render()
                }

                // When the method isn’t muted, trigger queued “set” events and pass the &#x60;thingObject&#x60;.
                return options.muted ? P : P.trigger( &#x27;set&#x27;, thingObject )
            }, //set


            /**
             * Get something
             */
            get: function( thing, format ) {

                // Make sure there’s something to get.
                thing = thing || &#x27;value&#x27;

                // If a picker state exists, return that.
                if ( STATE[ thing ] != null ) {
                    return STATE[ thing ]
                }

                // Return the submission value, if that.
                if ( thing == &#x27;valueSubmit&#x27; ) {
                    if ( P._hidden ) {
                        return P._hidden.value
                    }
                    thing = &#x27;value&#x27;
                }

                // Return the value, if that.
                if ( thing == &#x27;value&#x27; ) {
                    return ELEMENT.value
                }

                // Check if a component item exists, return that.
                if ( thing in P.component.item ) {
                    if ( typeof format == &#x27;string&#x27; ) {
                        var thingValue = P.component.get( thing )
                        return thingValue ?
                            PickerConstructor._.trigger(
                                P.component.formats.toString,
                                P.component,
                                [ format, thingValue ]
                            ) : &#x27;&#x27;
                    }
                    return P.component.get( thing )
                }
            }, //get



            /**
             * Bind events on the things.
             */
            on: function( thing, method, internal ) {

                var thingName, thingMethod,
                    thingIsObject = $.isPlainObject( thing ),
                    thingObject = thingIsObject ? thing : {}

                if ( thing ) {

                    // If the thing isn’t an object, make it one.
                    if ( !thingIsObject ) {
                        thingObject[ thing ] = method
                    }

                    // Go through the things to bind to.
                    for ( thingName in thingObject ) {

                        // Grab the method of the thing.
                        thingMethod = thingObject[ thingName ]

                        // If it was an internal binding, prefix it.
                        if ( internal ) {
                            thingName = &#x27;_&#x27; + thingName
                        }

                        // Make sure the thing methods collection exists.
                        STATE.methods[ thingName ] = STATE.methods[ thingName ] || []

                        // Add the method to the relative method collection.
                        STATE.methods[ thingName ].push( thingMethod )
                    }
                }

                return P
            }, //on



            /**
             * Unbind events on the things.
             */
            off: function() {
                var i, thingName,
                    names = arguments;
                for ( i = 0, namesCount = names.length; i &lt; namesCount; i += 1 ) {
                    thingName = names[i]
                    if ( thingName in STATE.methods ) {
                        delete STATE.methods[thingName]
                    }
                }
                return P
            },


            /**
             * Fire off method events.
             */
            trigger: function( name, data ) {
                var _trigger = function( name ) {
                    var methodList = STATE.methods[ name ]
                    if ( methodList ) {
                        methodList.map( function( method ) {
                            PickerConstructor._.trigger( method, P, [ data ] )
                        })
                    }
                }
                _trigger( &#x27;_&#x27; + name )
                _trigger( name )
                return P
            } //trigger
        } //PickerInstance.prototype


    /**
     * Wrap the picker holder components together.
     */
    function createWrappedComponent() {

        // Create a picker wrapper holder
        return PickerConstructor._.node( &#x27;div&#x27;,

            // Create a picker wrapper node
            PickerConstructor._.node( &#x27;div&#x27;,

                // Create a picker frame
                PickerConstructor._.node( &#x27;div&#x27;,

                    // Create a picker box node
                    PickerConstructor._.node( &#x27;div&#x27;,

                        // Create the components nodes.
                        P.component.nodes( STATE.open ),

                        // The picker box class
                        CLASSES.box
                    ),

                    // Picker wrap class
                    CLASSES.wrap
                ),

                // Picker frame class
                CLASSES.frame
            ),

            // Picker holder class
            CLASSES.holder
        ) //endreturn
    } //createWrappedComponent



    /**
     * Prepare the input element with all bindings.
     */
    function prepareElement() {

        $ELEMENT.

            // Store the picker data by component name.
            data(NAME, P).

            // Add the “input” class name.
            addClass(CLASSES.input).

            // Remove the tabindex.
            attr(&#x27;tabindex&#x27;, -1).

            // If there’s a &#x60;data-value&#x60;, update the value of the element.
            val( $ELEMENT.data(&#x27;value&#x27;) ?
                P.get(&#x27;select&#x27;, SETTINGS.format) :
                ELEMENT.value
            )


        // Only bind keydown events if the element isn’t editable.
        if ( !SETTINGS.editable ) {

            $ELEMENT.

                // On focus/click, focus onto the root to open it up.
                on( &#x27;focus.&#x27; + STATE.id + &#x27; click.&#x27; + STATE.id, function( event ) {
                    event.preventDefault()
                    P.$root.eq(0).focus()
                }).

                // Handle keyboard event based on the picker being opened or not.
                on( &#x27;keydown.&#x27; + STATE.id, handleKeydownEvent )
        }


        // Update the aria attributes.
        aria(ELEMENT, {
            haspopup: true,
            expanded: false,
            readonly: false,
            owns: ELEMENT.id + &#x27;_root&#x27;
        })
    }


    /**
     * Prepare the root picker element with all bindings.
     */
    function prepareElementRoot() {

        P.$root.

            on({

                // For iOS8.
                keydown: handleKeydownEvent,

                // When something within the root is focused, stop from bubbling
                // to the doc and remove the “focused” state from the root.
                focusin: function( event ) {
                    P.$root.removeClass( CLASSES.focused )
                    event.stopPropagation()
                },

                // When something within the root holder is clicked, stop it
                // from bubbling to the doc.
                &#x27;mousedown click&#x27;: function( event ) {

                    var target = event.target

                    // Make sure the target isn’t the root holder so it can bubble up.
                    if ( target != P.$root.children()[ 0 ] ) {

                        event.stopPropagation()

                        // * For mousedown events, cancel the default action in order to
                        //   prevent cases where focus is shifted onto external elements
                        //   when using things like jQuery mobile or MagnificPopup (ref: #249 &amp; #120).
                        //   Also, for Firefox, don’t prevent action on the &#x60;option&#x60; element.
                        if ( event.type == &#x27;mousedown&#x27; &amp;&amp; !$( target ).is( &#x27;input, select, textarea, button, option&#x27; )) {

                            event.preventDefault()

                            // Re-focus onto the root so that users can click away
                            // from elements focused within the picker.
                            P.$root.eq(0).focus()
                        }
                    }
                }
            }).

            // Add/remove the “target” class on focus and blur.
            on({
                focus: function() {
                    $ELEMENT.addClass( CLASSES.target )
                },
                blur: function() {
                    $ELEMENT.removeClass( CLASSES.target )
                }
            }).

            // Open the picker and adjust the root “focused” state
            on( &#x27;focus.toOpen&#x27;, handleFocusToOpenEvent ).

            // If there’s a click on an actionable element, carry out the actions.
            on( &#x27;click&#x27;, &#x27;[data-pick], [data-nav], [data-clear], [data-close]&#x27;, function() {

                var $target = $( this ),
                    targetData = $target.data(),
                    targetDisabled = $target.hasClass( CLASSES.navDisabled ) || $target.hasClass( CLASSES.disabled ),

                    // * For IE, non-focusable elements can be active elements as well
                    //   (http://stackoverflow.com/a/2684561).
                    activeElement = getActiveElement()
                    activeElement = activeElement &amp;&amp; ( activeElement.type || activeElement.href )

                // If it’s disabled or nothing inside is actively focused, re-focus the element.
                if ( targetDisabled || activeElement &amp;&amp; !$.contains( P.$root[0], activeElement ) ) {
                    P.$root.eq(0).focus()
                }

                // If something is superficially changed, update the &#x60;highlight&#x60; based on the &#x60;nav&#x60;.
                if ( !targetDisabled &amp;&amp; targetData.nav ) {
                    P.set( &#x27;highlight&#x27;, P.component.item.highlight, { nav: targetData.nav } )
                }

                // If something is picked, set &#x60;select&#x60; then close with focus.
                else if ( !targetDisabled &amp;&amp; &#x27;pick&#x27; in targetData ) {
                    P.set( &#x27;select&#x27;, targetData.pick )
                }

                // If a “clear” button is pressed, empty the values and close with focus.
                else if ( targetData.clear ) {
                    P.clear().close( true )
                }

                else if ( targetData.close ) {
                    P.close( true )
                }

            }) //P.$root

        aria( P.$root[0], &#x27;hidden&#x27;, true )
    }


     /**
      * Prepare the hidden input element along with all bindings.
      */
    function prepareElementHidden() {

        var name

        if ( SETTINGS.hiddenName === true ) {
            name = ELEMENT.name
            ELEMENT.name = &#x27;&#x27;
        }
        else {
            name = [
                typeof SETTINGS.hiddenPrefix == &#x27;string&#x27; ? SETTINGS.hiddenPrefix : &#x27;&#x27;,
                typeof SETTINGS.hiddenSuffix == &#x27;string&#x27; ? SETTINGS.hiddenSuffix : &#x27;_submit&#x27;
            ]
            name = name[0] + ELEMENT.name + name[1]
        }

        P._hidden = $(
            &#x27;&lt;input &#x27; +
            &#x27;type=hidden &#x27; +

            // Create the name using the original input’s with a prefix and suffix.
            &#x27;name=&quot;&#x27; + name + &#x27;&quot;&#x27; +

            // If the element has a value, set the hidden value as well.
            (
                $ELEMENT.data(&#x27;value&#x27;) || ELEMENT.value ?
                    &#x27; value=&quot;&#x27; + P.get(&#x27;select&#x27;, SETTINGS.formatSubmit) + &#x27;&quot;&#x27; :
                    &#x27;&#x27;
            ) +
            &#x27;&gt;&#x27;
        )[0]

        $ELEMENT.

            // If the value changes, update the hidden input with the correct format.
            on(&#x27;change.&#x27; + STATE.id, function() {
                P._hidden.value = ELEMENT.value ?
                    P.get(&#x27;select&#x27;, SETTINGS.formatSubmit) :
                    &#x27;&#x27;
            })


        // Insert the hidden input as specified in the settings.
        if ( SETTINGS.container ) $( SETTINGS.container ).append( P._hidden )
        else $ELEMENT.after( P._hidden )
    }


    // For iOS8.
    function handleKeydownEvent( event ) {

        var keycode = event.keyCode,

            // Check if one of the delete keys was pressed.
            isKeycodeDelete = /^(8|46)$/.test(keycode)

        // For some reason IE clears the input value on “escape”.
        if ( keycode == 27 ) {
            P.close()
            return false
        }

        // Check if &#x60;space&#x60; or &#x60;delete&#x60; was pressed or the picker is closed with a key movement.
        if ( keycode == 32 || isKeycodeDelete || !STATE.open &amp;&amp; P.component.key[keycode] ) {

            // Prevent it from moving the page and bubbling to doc.
            event.preventDefault()
            event.stopPropagation()

            // If &#x60;delete&#x60; was pressed, clear the values and close the picker.
            // Otherwise open the picker.
            if ( isKeycodeDelete ) { P.clear().close() }
            else { P.open() }
        }
    }


    // Separated for IE
    function handleFocusToOpenEvent( event ) {

        // Stop the event from propagating to the doc.
        event.stopPropagation()

        // If it’s a focus event, add the “focused” class to the root.
        if ( event.type == &#x27;focus&#x27; ) {
            P.$root.addClass( CLASSES.focused )
        }

        // And then finally open the picker.
        P.open()
    }


    // Return a new picker instance.
    return new PickerInstance()
} //PickerConstructor



/**
 * The default classes and prefix to use for the HTML classes.
 */
PickerConstructor.klasses = function( prefix ) {
    prefix = prefix || &#x27;picker&#x27;
    return {

        picker: prefix,
        opened: prefix + &#x27;--opened&#x27;,
        focused: prefix + &#x27;--focused&#x27;,

        input: prefix + &#x27;__input&#x27;,
        active: prefix + &#x27;__input--active&#x27;,
        target: prefix + &#x27;__input--target&#x27;,

        holder: prefix + &#x27;__holder&#x27;,

        frame: prefix + &#x27;__frame&#x27;,
        wrap: prefix + &#x27;__wrap&#x27;,

        box: prefix + &#x27;__box&#x27;
    }
} //PickerConstructor.klasses



/**
 * Check if the default theme is being used.
 */
function isUsingDefaultTheme( element ) {

    var theme,
        prop = &#x27;position&#x27;

    // For IE.
    if ( element.currentStyle ) {
        theme = element.currentStyle[prop]
    }

    // For normal browsers.
    else if ( window.getComputedStyle ) {
        theme = getComputedStyle( element )[prop]
    }

    return theme == &#x27;fixed&#x27;
}



/**
 * Get the width of the browser’s scrollbar.
 * Taken from: https://github.com/VodkaBears/Remodal/blob/master/src/jquery.remodal.js
 */
function getScrollbarWidth() {

    if ( $html.height() &lt;= $window.height() ) {
        return 0
    }

    var $outer = $( &#x27;&lt;div style=&quot;visibility:hidden;width:100px&quot; /&gt;&#x27; ).
        appendTo( &#x27;body&#x27; )

    // Get the width without scrollbars.
    var widthWithoutScroll = $outer[0].offsetWidth

    // Force adding scrollbars.
    $outer.css( &#x27;overflow&#x27;, &#x27;scroll&#x27; )

    // Add the inner div.
    var $inner = $( &#x27;&lt;div style=&quot;width:100%&quot; /&gt;&#x27; ).appendTo( $outer )

    // Get the width with scrollbars.
    var widthWithScroll = $inner[0].offsetWidth

    // Remove the divs.
    $outer.remove()

    // Return the difference between the widths.
    return widthWithoutScroll - widthWithScroll
}



/**
 * PickerConstructor helper methods.
 */
PickerConstructor._ = {

    /**
     * Create a group of nodes. Expects:
     * &#x60;
        {
            min:    {Integer},
            max:    {Integer},
            i:      {Integer},
            node:   {String},
            item:   {Function}
        }
     * &#x60;
     */
    group: function( groupObject ) {

        var
            // Scope for the looped object
            loopObjectScope,

            // Create the nodes list
            nodesList = &#x27;&#x27;,

            // The counter starts from the &#x60;min&#x60;
            counter = PickerConstructor._.trigger( groupObject.min, groupObject )


        // Loop from the &#x60;min&#x60; to &#x60;max&#x60;, incrementing by &#x60;i&#x60;
        for ( ; counter &lt;= PickerConstructor._.trigger( groupObject.max, groupObject, [ counter ] ); counter += groupObject.i ) {

            // Trigger the &#x60;item&#x60; function within scope of the object
            loopObjectScope = PickerConstructor._.trigger( groupObject.item, groupObject, [ counter ] )

            // Splice the subgroup and create nodes out of the sub nodes
            nodesList += PickerConstructor._.node(
                groupObject.node,
                loopObjectScope[ 0 ],   // the node
                loopObjectScope[ 1 ],   // the classes
                loopObjectScope[ 2 ]    // the attributes
            )
        }

        // Return the list of nodes
        return nodesList
    }, //group


    /**
     * Create a dom node string
     */
    node: function( wrapper, item, klass, attribute ) {

        // If the item is false-y, just return an empty string
        if ( !item ) return &#x27;&#x27;

        // If the item is an array, do a join
        item = $.isArray( item ) ? item.join( &#x27;&#x27; ) : item

        // Check for the class
        klass = klass ? &#x27; class=&quot;&#x27; + klass + &#x27;&quot;&#x27; : &#x27;&#x27;

        // Check for any attributes
        attribute = attribute ? &#x27; &#x27; + attribute : &#x27;&#x27;

        // Return the wrapped item
        return &#x27;&lt;&#x27; + wrapper + klass + attribute + &#x27;&gt;&#x27; + item + &#x27;&lt;/&#x27; + wrapper + &#x27;&gt;&#x27;
    }, //node


    /**
     * Lead numbers below 10 with a zero.
     */
    lead: function( number ) {
        return ( number &lt; 10 ? &#x27;0&#x27;: &#x27;&#x27; ) + number
    },


    /**
     * Trigger a function otherwise return the value.
     */
    trigger: function( callback, scope, args ) {
        return typeof callback == &#x27;function&#x27; ? callback.apply( scope, args || [] ) : callback
    },


    /**
     * If the second character is a digit, length is 2 otherwise 1.
     */
    digits: function( string ) {
        return ( /\d/ ).test( string[ 1 ] ) ? 2 : 1
    },


    /**
     * Tell if something is a date object.
     */
    isDate: function( value ) {
        return {}.toString.call( value ).indexOf( &#x27;Date&#x27; ) &gt; -1 &amp;&amp; this.isInteger( value.getDate() )
    },


    /**
     * Tell if something is an integer.
     */
    isInteger: function( value ) {
        return {}.toString.call( value ).indexOf( &#x27;Number&#x27; ) &gt; -1 &amp;&amp; value % 1 === 0
    },


    /**
     * Create ARIA attribute strings.
     */
    ariaAttr: ariaAttr
} //PickerConstructor._



/**
 * Extend the picker with a component and defaults.
 */
PickerConstructor.extend = function( name, Component ) {

    // Extend jQuery.
    $.fn[ name ] = function( options, action ) {

        // Grab the component data.
        var componentData = this.data( name )

        // If the picker is requested, return the data object.
        if ( options == &#x27;picker&#x27; ) {
            return componentData
        }

        // If the component data exists and &#x60;options&#x60; is a string, carry out the action.
        if ( componentData &amp;&amp; typeof options == &#x27;string&#x27; ) {
            return PickerConstructor._.trigger( componentData[ options ], componentData, [ action ] )
        }

        // Otherwise go through each matched element and if the component
        // doesn’t exist, create a new picker using &#x60;this&#x60; element
        // and merging the defaults and options with a deep copy.
        return this.each( function() {
            var $this = $( this )
            if ( !$this.data( name ) ) {
                new PickerConstructor( this, name, Component, options )
            }
        })
    }

    // Set the defaults.
    $.fn[ name ].defaults = Component.defaults
} //PickerConstructor.extend



function aria(element, attribute, value) {
    if ( $.isPlainObject(attribute) ) {
        for ( var key in attribute ) {
            ariaSet(element, key, attribute[key])
        }
    }
    else {
        ariaSet(element, attribute, value)
    }
}
function ariaSet(element, attribute, value) {
    element.setAttribute(
        (attribute == &#x27;role&#x27; ? &#x27;&#x27; : &#x27;aria-&#x27;) + attribute,
        value
    )
}
function ariaAttr(attribute, data) {
    if ( !$.isPlainObject(attribute) ) {
        attribute = { attribute: data }
    }
    data = &#x27;&#x27;
    for ( var key in attribute ) {
        var attr = (key == &#x27;role&#x27; ? &#x27;&#x27; : &#x27;aria-&#x27;) + key,
            attrVal = attribute[key]
        data += attrVal == null ? &#x27;&#x27; : attr + &#x27;=&quot;&#x27; + attribute[key] + &#x27;&quot;&#x27;
    }
    return data
}

// IE8 bug throws an error for activeElements within iframes.
function getActiveElement() {
    try {
        return document.activeElement
    } catch ( err ) { }
}



// Expose the picker constructor.
return PickerConstructor


}));


;/*!
 * Date picker for pickadate.js v3.5.0
 * http://amsul.github.io/pickadate.js/date.htm
 */

(function ( factory ) {

    // AMD.
    if ( typeof define == &#x27;function&#x27; &amp;&amp; define.amd )
        define( [&#x27;picker&#x27;, &#x27;jquery&#x27;], factory )

    // Node.js/browserify.
    else if ( typeof exports == &#x27;object&#x27; )
        module.exports = factory( require(&#x27;./picker.js&#x27;), require(&#x27;jquery&#x27;) )

    // Browser globals.
    else factory( Picker, jQuery )

}(function( Picker, $ ) {


/**
 * Globals and constants
 */
var DAYS_IN_WEEK = 7,
    WEEKS_IN_CALENDAR = 6,
    _ = Picker._



/**
 * The date picker constructor
 */
function DatePicker( picker, settings ) {

    var calendar = this,
        element = picker.$node[ 0 ],
        elementValue = element.value,
        elementDataValue = picker.$node.data( &#x27;value&#x27; ),
        valueString = elementDataValue || elementValue,
        formatString = elementDataValue ? settings.formatSubmit : settings.format,
        isRTL = function() {

            return element.currentStyle ?

                // For IE.
                element.currentStyle.direction == &#x27;rtl&#x27; :

                // For normal browsers.
                getComputedStyle( picker.$root[0] ).direction == &#x27;rtl&#x27;
        }

    calendar.settings = settings
    calendar.$node = picker.$node

    // The queue of methods that will be used to build item objects.
    calendar.queue = {
        min: &#x27;measure create&#x27;,
        max: &#x27;measure create&#x27;,
        now: &#x27;now create&#x27;,
        select: &#x27;parse create validate&#x27;,
        highlight: &#x27;parse navigate create validate&#x27;,
        view: &#x27;parse create validate viewset&#x27;,
        disable: &#x27;deactivate&#x27;,
        enable: &#x27;activate&#x27;
    }

    // The component&#x27;s item object.
    calendar.item = {}

    calendar.item.clear = null
    calendar.item.disable = ( settings.disable || [] ).slice( 0 )
    calendar.item.enable = -(function( collectionDisabled ) {
        return collectionDisabled[ 0 ] === true ? collectionDisabled.shift() : -1
    })( calendar.item.disable )

    calendar.
        set( &#x27;min&#x27;, settings.min ).
        set( &#x27;max&#x27;, settings.max ).
        set( &#x27;now&#x27; )

    // When there’s a value, set the &#x60;select&#x60;, which in turn
    // also sets the &#x60;highlight&#x60; and &#x60;view&#x60;.
    if ( valueString ) {
        calendar.set( &#x27;select&#x27;, valueString, { format: formatString })
    }

    // If there’s no value, default to highlighting “today”.
    else {
        calendar.
            set( &#x27;select&#x27;, null ).
            set( &#x27;highlight&#x27;, calendar.item.now )
    }


    // The keycode to movement mapping.
    calendar.key = {
        40: 7, // Down
        38: -7, // Up
        39: function() { return isRTL() ? -1 : 1 }, // Right
        37: function() { return isRTL() ? 1 : -1 }, // Left
        go: function( timeChange ) {
            var highlightedObject = calendar.item.highlight,
                targetDate = new Date( highlightedObject.year, highlightedObject.month, highlightedObject.date + timeChange )
            calendar.set(
                &#x27;highlight&#x27;,
                targetDate,
                { interval: timeChange }
            )
            this.render()
        }
    }


    // Bind some picker events.
    picker.
        on( &#x27;render&#x27;, function() {
            picker.$root.find( &#x27;.&#x27; + settings.klass.selectMonth ).on( &#x27;change&#x27;, function() {
                var value = this.value
                if ( value ) {
                    picker.set( &#x27;highlight&#x27;, [ picker.get( &#x27;view&#x27; ).year, value, picker.get( &#x27;highlight&#x27; ).date ] )
                    picker.$root.find( &#x27;.&#x27; + settings.klass.selectMonth ).trigger( &#x27;focus&#x27; )
                }
            })
            picker.$root.find( &#x27;.&#x27; + settings.klass.selectYear ).on( &#x27;change&#x27;, function() {
                var value = this.value
                if ( value ) {
                    picker.set( &#x27;highlight&#x27;, [ value, picker.get( &#x27;view&#x27; ).month, picker.get( &#x27;highlight&#x27; ).date ] )
                    picker.$root.find( &#x27;.&#x27; + settings.klass.selectYear ).trigger( &#x27;focus&#x27; )
                }
            })
        }, 1 ).
        on( &#x27;open&#x27;, function() {
            var includeToday = &#x27;&#x27;
            if ( calendar.disabled( calendar.get(&#x27;now&#x27;) ) ) {
                includeToday = &#x27;:not(.&#x27; + settings.klass.buttonToday + &#x27;)&#x27;
            }
            picker.$root.find( &#x27;button&#x27; + includeToday + &#x27;, select&#x27; ).attr( &#x27;disabled&#x27;, false )
        }, 1 ).
        on( &#x27;close&#x27;, function() {
            picker.$root.find( &#x27;button, select&#x27; ).attr( &#x27;disabled&#x27;, true )
        }, 1 )

} //DatePicker


/**
 * Set a datepicker item object.
 */
DatePicker.prototype.set = function( type, value, options ) {

    var calendar = this,
        calendarItem = calendar.item

    // If the value is &#x60;null&#x60; just set it immediately.
    if ( value === null ) {
        if ( type == &#x27;clear&#x27; ) type = &#x27;select&#x27;
        calendarItem[ type ] = value
        return calendar
    }

    // Otherwise go through the queue of methods, and invoke the functions.
    // Update this as the time unit, and set the final value as this item.
    // * In the case of &#x60;enable&#x60;, keep the queue but set &#x60;disable&#x60; instead.
    //   And in the case of &#x60;flip&#x60;, keep the queue but set &#x60;enable&#x60; instead.
    calendarItem[ ( type == &#x27;enable&#x27; ? &#x27;disable&#x27; : type == &#x27;flip&#x27; ? &#x27;enable&#x27; : type ) ] = calendar.queue[ type ].split( &#x27; &#x27; ).map( function( method ) {
        value = calendar[ method ]( type, value, options )
        return value
    }).pop()

    // Check if we need to cascade through more updates.
    if ( type == &#x27;select&#x27; ) {
        calendar.set( &#x27;highlight&#x27;, calendarItem.select, options )
    }
    else if ( type == &#x27;highlight&#x27; ) {
        calendar.set( &#x27;view&#x27;, calendarItem.highlight, options )
    }
    else if ( type.match( /^(flip|min|max|disable|enable)$/ ) ) {
        if ( calendarItem.select &amp;&amp; calendar.disabled( calendarItem.select ) ) {
            calendar.set( &#x27;select&#x27;, calendarItem.select, options )
        }
        if ( calendarItem.highlight &amp;&amp; calendar.disabled( calendarItem.highlight ) ) {
            calendar.set( &#x27;highlight&#x27;, calendarItem.highlight, options )
        }
    }

    return calendar
} //DatePicker.prototype.set


/**
 * Get a datepicker item object.
 */
DatePicker.prototype.get = function( type ) {
    return this.item[ type ]
} //DatePicker.prototype.get


/**
 * Create a picker date object.
 */
DatePicker.prototype.create = function( type, value, options ) {

    var isInfiniteValue,
        calendar = this

    // If there’s no value, use the type as the value.
    value = value === undefined ? type : value


    // If it’s infinity, update the value.
    if ( value == -Infinity || value == Infinity ) {
        isInfiniteValue = value
    }

    // If it’s an object, use the native date object.
    else if ( $.isPlainObject( value ) &amp;&amp; _.isInteger( value.pick ) ) {
        value = value.obj
    }

    // If it’s an array, convert it into a date and make sure
    // that it’s a valid date – otherwise default to today.
    else if ( $.isArray( value ) ) {
        value = new Date( value[ 0 ], value[ 1 ], value[ 2 ] )
        value = _.isDate( value ) ? value : calendar.create().obj
    }

    // If it’s a number or date object, make a normalized date.
    else if ( _.isInteger( value ) || _.isDate( value ) ) {
        value = calendar.normalize( new Date( value ), options )
    }

    // If it’s a literal true or any other case, set it to now.
    else /*if ( value === true )*/ {
        value = calendar.now( type, value, options )
    }

    // Return the compiled object.
    return {
        year: isInfiniteValue || value.getFullYear(),
        month: isInfiniteValue || value.getMonth(),
        date: isInfiniteValue || value.getDate(),
        day: isInfiniteValue || value.getDay(),
        obj: isInfiniteValue || value,
        pick: isInfiniteValue || value.getTime()
    }
} //DatePicker.prototype.create


/**
 * Create a range limit object using an array, date object,
 * literal “true”, or integer relative to another time.
 */
DatePicker.prototype.createRange = function( from, to ) {

    var calendar = this,
        createDate = function( date ) {
            if ( date === true || $.isArray( date ) || _.isDate( date ) ) {
                return calendar.create( date )
            }
            return date
        }

    // Create objects if possible.
    if ( !_.isInteger( from ) ) {
        from = createDate( from )
    }
    if ( !_.isInteger( to ) ) {
        to = createDate( to )
    }

    // Create relative dates.
    if ( _.isInteger( from ) &amp;&amp; $.isPlainObject( to ) ) {
        from = [ to.year, to.month, to.date + from ];
    }
    else if ( _.isInteger( to ) &amp;&amp; $.isPlainObject( from ) ) {
        to = [ from.year, from.month, from.date + to ];
    }

    return {
        from: createDate( from ),
        to: createDate( to )
    }
} //DatePicker.prototype.createRange


/**
 * Check if a date unit falls within a date range object.
 */
DatePicker.prototype.withinRange = function( range, dateUnit ) {
    range = this.createRange(range.from, range.to)
    return dateUnit.pick &gt;= range.from.pick &amp;&amp; dateUnit.pick &lt;= range.to.pick
}


/**
 * Check if two date range objects overlap.
 */
DatePicker.prototype.overlapRanges = function( one, two ) {

    var calendar = this

    // Convert the ranges into comparable dates.
    one = calendar.createRange( one.from, one.to )
    two = calendar.createRange( two.from, two.to )

    return calendar.withinRange( one, two.from ) || calendar.withinRange( one, two.to ) ||
        calendar.withinRange( two, one.from ) || calendar.withinRange( two, one.to )
}


/**
 * Get the date today.
 */
DatePicker.prototype.now = function( type, value, options ) {
    value = new Date()
    if ( options &amp;&amp; options.rel ) {
        value.setDate( value.getDate() + options.rel )
    }
    return this.normalize( value, options )
}


/**
 * Navigate to next/prev month.
 */
DatePicker.prototype.navigate = function( type, value, options ) {

    var targetDateObject,
        targetYear,
        targetMonth,
        targetDate,
        isTargetArray = $.isArray( value ),
        isTargetObject = $.isPlainObject( value ),
        viewsetObject = this.item.view/*,
        safety = 100*/


    if ( isTargetArray || isTargetObject ) {

        if ( isTargetObject ) {
            targetYear = value.year
            targetMonth = value.month
            targetDate = value.date
        }
        else {
            targetYear = +value[0]
            targetMonth = +value[1]
            targetDate = +value[2]
        }

        // If we’re navigating months but the view is in a different
        // month, navigate to the view’s year and month.
        if ( options &amp;&amp; options.nav &amp;&amp; viewsetObject &amp;&amp; viewsetObject.month !== targetMonth ) {
            targetYear = viewsetObject.year
            targetMonth = viewsetObject.month
        }

        // Figure out the expected target year and month.
        targetDateObject = new Date( targetYear, targetMonth + ( options &amp;&amp; options.nav ? options.nav : 0 ), 1 )
        targetYear = targetDateObject.getFullYear()
        targetMonth = targetDateObject.getMonth()

        // If the month we’re going to doesn’t have enough days,
        // keep decreasing the date until we reach the month’s last date.
        while ( /*safety &amp;&amp;*/ new Date( targetYear, targetMonth, targetDate ).getMonth() !== targetMonth ) {
            targetDate -= 1
            /*safety -= 1
            if ( !safety ) {
                throw &#x27;Fell into an infinite loop while navigating to &#x27; + new Date( targetYear, targetMonth, targetDate ) + &#x27;.&#x27;
            }*/
        }

        value = [ targetYear, targetMonth, targetDate ]
    }

    return value
} //DatePicker.prototype.navigate


/**
 * Normalize a date by setting the hours to midnight.
 */
DatePicker.prototype.normalize = function( value/*, options*/ ) {
    value.setHours( 0, 0, 0, 0 )
    return value
}


/**
 * Measure the range of dates.
 */
DatePicker.prototype.measure = function( type, value/*, options*/ ) {

    var calendar = this

    // If it’s anything false-y, remove the limits.
    if ( !value ) {
        value = type == &#x27;min&#x27; ? -Infinity : Infinity
    }

    // If it’s a string, parse it.
    else if ( typeof value == &#x27;string&#x27; ) {
        value = calendar.parse( type, value )
    }

    // If it&#x27;s an integer, get a date relative to today.
    else if ( _.isInteger( value ) ) {
        value = calendar.now( type, value, { rel: value } )
    }

    return value
} ///DatePicker.prototype.measure


/**
 * Create a viewset object based on navigation.
 */
DatePicker.prototype.viewset = function( type, dateObject/*, options*/ ) {
    return this.create([ dateObject.year, dateObject.month, 1 ])
}


/**
 * Validate a date as enabled and shift if needed.
 */
DatePicker.prototype.validate = function( type, dateObject, options ) {

    var calendar = this,

        // Keep a reference to the original date.
        originalDateObject = dateObject,

        // Make sure we have an interval.
        interval = options &amp;&amp; options.interval ? options.interval : 1,

        // Check if the calendar enabled dates are inverted.
        isFlippedBase = calendar.item.enable === -1,

        // Check if we have any enabled dates after/before now.
        hasEnabledBeforeTarget, hasEnabledAfterTarget,

        // The min &amp; max limits.
        minLimitObject = calendar.item.min,
        maxLimitObject = calendar.item.max,

        // Check if we’ve reached the limit during shifting.
        reachedMin, reachedMax,

        // Check if the calendar is inverted and at least one weekday is enabled.
        hasEnabledWeekdays = isFlippedBase &amp;&amp; calendar.item.disable.filter( function( value ) {

            // If there’s a date, check where it is relative to the target.
            if ( $.isArray( value ) ) {
                var dateTime = calendar.create( value ).pick
                if ( dateTime &lt; dateObject.pick ) hasEnabledBeforeTarget = true
                else if ( dateTime &gt; dateObject.pick ) hasEnabledAfterTarget = true
            }

            // Return only integers for enabled weekdays.
            return _.isInteger( value )
        }).length/*,

        safety = 100*/



    // Cases to validate for:
    // [1] Not inverted and date disabled.
    // [2] Inverted and some dates enabled.
    // [3] Not inverted and out of range.
    //
    // Cases to **not** validate for:
    // • Navigating months.
    // • Not inverted and date enabled.
    // • Inverted and all dates disabled.
    // • ..and anything else.
    if ( !options || !options.nav ) if (
        /* 1 */ ( !isFlippedBase &amp;&amp; calendar.disabled( dateObject ) ) ||
        /* 2 */ ( isFlippedBase &amp;&amp; calendar.disabled( dateObject ) &amp;&amp; ( hasEnabledWeekdays || hasEnabledBeforeTarget || hasEnabledAfterTarget ) ) ||
        /* 3 */ ( !isFlippedBase &amp;&amp; (dateObject.pick &lt;= minLimitObject.pick || dateObject.pick &gt;= maxLimitObject.pick) )
    ) {


        // When inverted, flip the direction if there aren’t any enabled weekdays
        // and there are no enabled dates in the direction of the interval.
        if ( isFlippedBase &amp;&amp; !hasEnabledWeekdays &amp;&amp; ( ( !hasEnabledAfterTarget &amp;&amp; interval &gt; 0 ) || ( !hasEnabledBeforeTarget &amp;&amp; interval &lt; 0 ) ) ) {
            interval *= -1
        }


        // Keep looping until we reach an enabled date.
        while ( /*safety &amp;&amp;*/ calendar.disabled( dateObject ) ) {

            /*safety -= 1
            if ( !safety ) {
                throw &#x27;Fell into an infinite loop while validating &#x27; + dateObject.obj + &#x27;.&#x27;
            }*/


            // If we’ve looped into the next/prev month with a large interval, return to the original date and flatten the interval.
            if ( Math.abs( interval ) &gt; 1 &amp;&amp; ( dateObject.month &lt; originalDateObject.month || dateObject.month &gt; originalDateObject.month ) ) {
                dateObject = originalDateObject
                interval = interval &gt; 0 ? 1 : -1
            }


            // If we’ve reached the min/max limit, reverse the direction, flatten the interval and set it to the limit.
            if ( dateObject.pick &lt;= minLimitObject.pick ) {
                reachedMin = true
                interval = 1
                dateObject = calendar.create([
                    minLimitObject.year,
                    minLimitObject.month,
                    minLimitObject.date + (dateObject.pick === minLimitObject.pick ? 0 : -1)
                ])
            }
            else if ( dateObject.pick &gt;= maxLimitObject.pick ) {
                reachedMax = true
                interval = -1
                dateObject = calendar.create([
                    maxLimitObject.year,
                    maxLimitObject.month,
                    maxLimitObject.date + (dateObject.pick === maxLimitObject.pick ? 0 : 1)
                ])
            }


            // If we’ve reached both limits, just break out of the loop.
            if ( reachedMin &amp;&amp; reachedMax ) {
                break
            }


            // Finally, create the shifted date using the interval and keep looping.
            dateObject = calendar.create([ dateObject.year, dateObject.month, dateObject.date + interval ])
        }

    } //endif


    // Return the date object settled on.
    return dateObject
} //DatePicker.prototype.validate


/**
 * Check if a date is disabled.
 */
DatePicker.prototype.disabled = function( dateToVerify ) {

    var
        calendar = this,

        // Filter through the disabled dates to check if this is one.
        isDisabledMatch = calendar.item.disable.filter( function( dateToDisable ) {

            // If the date is a number, match the weekday with 0index and &#x60;firstDay&#x60; check.
            if ( _.isInteger( dateToDisable ) ) {
                return dateToVerify.day === ( calendar.settings.firstDay ? dateToDisable : dateToDisable - 1 ) % 7
            }

            // If it’s an array or a native JS date, create and match the exact date.
            if ( $.isArray( dateToDisable ) || _.isDate( dateToDisable ) ) {
                return dateToVerify.pick === calendar.create( dateToDisable ).pick
            }

            // If it’s an object, match a date within the “from” and “to” range.
            if ( $.isPlainObject( dateToDisable ) ) {
                return calendar.withinRange( dateToDisable, dateToVerify )
            }
        })

    // If this date matches a disabled date, confirm it’s not inverted.
    isDisabledMatch = isDisabledMatch.length &amp;&amp; !isDisabledMatch.filter(function( dateToDisable ) {
        return $.isArray( dateToDisable ) &amp;&amp; dateToDisable[3] == &#x27;inverted&#x27; ||
            $.isPlainObject( dateToDisable ) &amp;&amp; dateToDisable.inverted
    }).length

    // Check the calendar “enabled” flag and respectively flip the
    // disabled state. Then also check if it’s beyond the min/max limits.
    return calendar.item.enable === -1 ? !isDisabledMatch : isDisabledMatch ||
        dateToVerify.pick &lt; calendar.item.min.pick ||
        dateToVerify.pick &gt; calendar.item.max.pick

} //DatePicker.prototype.disabled


/**
 * Parse a string into a usable type.
 */
DatePicker.prototype.parse = function( type, value, options ) {

    var calendar = this,
        parsingObject = {}

    // If it’s already parsed, we’re good.
    if ( !value || typeof value != &#x27;string&#x27; ) {
        return value
    }

    // We need a &#x60;.format&#x60; to parse the value with.
    if ( !( options &amp;&amp; options.format ) ) {
        options = options || {}
        options.format = calendar.settings.format
    }

    // Convert the format into an array and then map through it.
    calendar.formats.toArray( options.format ).map( function( label ) {

        var
            // Grab the formatting label.
            formattingLabel = calendar.formats[ label ],

            // The format length is from the formatting label function or the
            // label length without the escaping exclamation (!) mark.
            formatLength = formattingLabel ? _.trigger( formattingLabel, calendar, [ value, parsingObject ] ) : label.replace( /^!/, &#x27;&#x27; ).length

        // If there&#x27;s a format label, split the value up to the format length.
        // Then add it to the parsing object with appropriate label.
        if ( formattingLabel ) {
            parsingObject[ label ] = value.substr( 0, formatLength )
        }

        // Update the value as the substring from format length to end.
        value = value.substr( formatLength )
    })

    // Compensate for month 0index.
    return [
        parsingObject.yyyy || parsingObject.yy,
        +( parsingObject.mm || parsingObject.m ) - 1,
        parsingObject.dd || parsingObject.d
    ]
} //DatePicker.prototype.parse


/**
 * Various formats to display the object in.
 */
DatePicker.prototype.formats = (function() {

    // Return the length of the first word in a collection.
    function getWordLengthFromCollection( string, collection, dateObject ) {

        // Grab the first word from the string.
        var word = string.match( /\w+/ )[ 0 ]

        // If there&#x27;s no month index, add it to the date object
        if ( !dateObject.mm &amp;&amp; !dateObject.m ) {
            dateObject.m = collection.indexOf( word ) + 1
        }

        // Return the length of the word.
        return word.length
    }

    // Get the length of the first word in a string.
    function getFirstWordLength( string ) {
        return string.match( /\w+/ )[ 0 ].length
    }

    return {

        d: function( string, dateObject ) {

            // If there&#x27;s string, then get the digits length.
            // Otherwise return the selected date.
            return string ? _.digits( string ) : dateObject.date
        },
        dd: function( string, dateObject ) {

            // If there&#x27;s a string, then the length is always 2.
            // Otherwise return the selected date with a leading zero.
            return string ? 2 : _.lead( dateObject.date )
        },
        ddd: function( string, dateObject ) {

            // If there&#x27;s a string, then get the length of the first word.
            // Otherwise return the short selected weekday.
            return string ? getFirstWordLength( string ) : this.settings.weekdaysShort[ dateObject.day ]
        },
        dddd: function( string, dateObject ) {

            // If there&#x27;s a string, then get the length of the first word.
            // Otherwise return the full selected weekday.
            return string ? getFirstWordLength( string ) : this.settings.weekdaysFull[ dateObject.day ]
        },
        m: function( string, dateObject ) {

            // If there&#x27;s a string, then get the length of the digits
            // Otherwise return the selected month with 0index compensation.
            return string ? _.digits( string ) : dateObject.month + 1
        },
        mm: function( string, dateObject ) {

            // If there&#x27;s a string, then the length is always 2.
            // Otherwise return the selected month with 0index and leading zero.
            return string ? 2 : _.lead( dateObject.month + 1 )
        },
        mmm: function( string, dateObject ) {

            var collection = this.settings.monthsShort

            // If there&#x27;s a string, get length of the relevant month from the short
            // months collection. Otherwise return the selected month from that collection.
            return string ? getWordLengthFromCollection( string, collection, dateObject ) : collection[ dateObject.month ]
        },
        mmmm: function( string, dateObject ) {

            var collection = this.settings.monthsFull

            // If there&#x27;s a string, get length of the relevant month from the full
            // months collection. Otherwise return the selected month from that collection.
            return string ? getWordLengthFromCollection( string, collection, dateObject ) : collection[ dateObject.month ]
        },
        yy: function( string, dateObject ) {

            // If there&#x27;s a string, then the length is always 2.
            // Otherwise return the selected year by slicing out the first 2 digits.
            return string ? 2 : ( &#x27;&#x27; + dateObject.year ).slice( 2 )
        },
        yyyy: function( string, dateObject ) {

            // If there&#x27;s a string, then the length is always 4.
            // Otherwise return the selected year.
            return string ? 4 : dateObject.year
        },

        // Create an array by splitting the formatting string passed.
        toArray: function( formatString ) { return formatString.split( /(d{1,4}|m{1,4}|y{4}|yy|!.)/g ) },

        // Format an object into a string using the formatting options.
        toString: function ( formatString, itemObject ) {
            var calendar = this
            return calendar.formats.toArray( formatString ).map( function( label ) {
                return _.trigger( calendar.formats[ label ], calendar, [ 0, itemObject ] ) || label.replace( /^!/, &#x27;&#x27; )
            }).join( &#x27;&#x27; )
        }
    }
})() //DatePicker.prototype.formats




/**
 * Check if two date units are the exact.
 */
DatePicker.prototype.isDateExact = function( one, two ) {

    var calendar = this

    // When we’re working with weekdays, do a direct comparison.
    if (
        ( _.isInteger( one ) &amp;&amp; _.isInteger( two ) ) ||
        ( typeof one == &#x27;boolean&#x27; &amp;&amp; typeof two == &#x27;boolean&#x27; )
     ) {
        return one === two
    }

    // When we’re working with date representations, compare the “pick” value.
    if (
        ( _.isDate( one ) || $.isArray( one ) ) &amp;&amp;
        ( _.isDate( two ) || $.isArray( two ) )
    ) {
        return calendar.create( one ).pick === calendar.create( two ).pick
    }

    // When we’re working with range objects, compare the “from” and “to”.
    if ( $.isPlainObject( one ) &amp;&amp; $.isPlainObject( two ) ) {
        return calendar.isDateExact( one.from, two.from ) &amp;&amp; calendar.isDateExact( one.to, two.to )
    }

    return false
}


/**
 * Check if two date units overlap.
 */
DatePicker.prototype.isDateOverlap = function( one, two ) {

    var calendar = this,
        firstDay = calendar.settings.firstDay ? 1 : 0

    // When we’re working with a weekday index, compare the days.
    if ( _.isInteger( one ) &amp;&amp; ( _.isDate( two ) || $.isArray( two ) ) ) {
        one = one % 7 + firstDay
        return one === calendar.create( two ).day + 1
    }
    if ( _.isInteger( two ) &amp;&amp; ( _.isDate( one ) || $.isArray( one ) ) ) {
        two = two % 7 + firstDay
        return two === calendar.create( one ).day + 1
    }

    // When we’re working with range objects, check if the ranges overlap.
    if ( $.isPlainObject( one ) &amp;&amp; $.isPlainObject( two ) ) {
        return calendar.overlapRanges( one, two )
    }

    return false
}


/**
 * Flip the “enabled” state.
 */
DatePicker.prototype.flipEnable = function(val) {
    var itemObject = this.item
    itemObject.enable = val || (itemObject.enable == -1 ? 1 : -1)
}


/**
 * Mark a collection of dates as “disabled”.
 */
DatePicker.prototype.deactivate = function( type, datesToDisable ) {

    var calendar = this,
        disabledItems = calendar.item.disable.slice(0)


    // If we’re flipping, that’s all we need to do.
    if ( datesToDisable == &#x27;flip&#x27; ) {
        calendar.flipEnable()
    }

    else if ( datesToDisable === false ) {
        calendar.flipEnable(1)
        disabledItems = []
    }

    else if ( datesToDisable === true ) {
        calendar.flipEnable(-1)
        disabledItems = []
    }

    // Otherwise go through the dates to disable.
    else {

        datesToDisable.map(function( unitToDisable ) {

            var matchFound

            // When we have disabled items, check for matches.
            // If something is matched, immediately break out.
            for ( var index = 0; index &lt; disabledItems.length; index += 1 ) {
                if ( calendar.isDateExact( unitToDisable, disabledItems[index] ) ) {
                    matchFound = true
                    break
                }
            }

            // If nothing was found, add the validated unit to the collection.
            if ( !matchFound ) {
                if (
                    _.isInteger( unitToDisable ) ||
                    _.isDate( unitToDisable ) ||
                    $.isArray( unitToDisable ) ||
                    ( $.isPlainObject( unitToDisable ) &amp;&amp; unitToDisable.from &amp;&amp; unitToDisable.to )
                ) {
                    disabledItems.push( unitToDisable )
                }
            }
        })
    }

    // Return the updated collection.
    return disabledItems
} //DatePicker.prototype.deactivate


/**
 * Mark a collection of dates as “enabled”.
 */
DatePicker.prototype.activate = function( type, datesToEnable ) {

    var calendar = this,
        disabledItems = calendar.item.disable,
        disabledItemsCount = disabledItems.length

    // If we’re flipping, that’s all we need to do.
    if ( datesToEnable == &#x27;flip&#x27; ) {
        calendar.flipEnable()
    }

    else if ( datesToEnable === true ) {
        calendar.flipEnable(1)
        disabledItems = []
    }

    else if ( datesToEnable === false ) {
        calendar.flipEnable(-1)
        disabledItems = []
    }

    // Otherwise go through the disabled dates.
    else {

        datesToEnable.map(function( unitToEnable ) {

            var matchFound,
                disabledUnit,
                index,
                isExactRange

            // Go through the disabled items and try to find a match.
            for ( index = 0; index &lt; disabledItemsCount; index += 1 ) {

                disabledUnit = disabledItems[index]

                // When an exact match is found, remove it from the collection.
                if ( calendar.isDateExact( disabledUnit, unitToEnable ) ) {
                    matchFound = disabledItems[index] = null
                    isExactRange = true
                    break
                }

                // When an overlapped match is found, add the “inverted” state to it.
                else if ( calendar.isDateOverlap( disabledUnit, unitToEnable ) ) {
                    if ( $.isPlainObject( unitToEnable ) ) {
                        unitToEnable.inverted = true
                        matchFound = unitToEnable
                    }
                    else if ( $.isArray( unitToEnable ) ) {
                        matchFound = unitToEnable
                        if ( !matchFound[3] ) matchFound.push( &#x27;inverted&#x27; )
                    }
                    else if ( _.isDate( unitToEnable ) ) {
                        matchFound = [ unitToEnable.getFullYear(), unitToEnable.getMonth(), unitToEnable.getDate(), &#x27;inverted&#x27; ]
                    }
                    break
                }
            }

            // If a match was found, remove a previous duplicate entry.
            if ( matchFound ) for ( index = 0; index &lt; disabledItemsCount; index += 1 ) {
                if ( calendar.isDateExact( disabledItems[index], unitToEnable ) ) {
                    disabledItems[index] = null
                    break
                }
            }

            // In the event that we’re dealing with an exact range of dates,
            // make sure there are no “inverted” dates because of it.
            if ( isExactRange ) for ( index = 0; index &lt; disabledItemsCount; index += 1 ) {
                if ( calendar.isDateOverlap( disabledItems[index], unitToEnable ) ) {
                    disabledItems[index] = null
                    break
                }
            }

            // If something is still matched, add it into the collection.
            if ( matchFound ) {
                disabledItems.push( matchFound )
            }
        })
    }

    // Return the updated collection.
    return disabledItems.filter(function( val ) { return val != null })
} //DatePicker.prototype.activate


/**
 * Create a string for the nodes in the picker.
 */
DatePicker.prototype.nodes = function( isOpen ) {

    var
        calendar = this,
        settings = calendar.settings,
        calendarItem = calendar.item,
        nowObject = calendarItem.now,
        selectedObject = calendarItem.select,
        highlightedObject = calendarItem.highlight,
        viewsetObject = calendarItem.view,
        disabledCollection = calendarItem.disable,
        minLimitObject = calendarItem.min,
        maxLimitObject = calendarItem.max,


        // Create the calendar table head using a copy of weekday labels collection.
        // * We do a copy so we don&#x27;t mutate the original array.
        tableHead = (function( collection, fullCollection ) {

            // If the first day should be Monday, move Sunday to the end.
            if ( settings.firstDay ) {
                collection.push( collection.shift() )
                fullCollection.push( fullCollection.shift() )
            }

            // Create and return the table head group.
            return _.node(
                &#x27;thead&#x27;,
                _.node(
                    &#x27;tr&#x27;,
                    _.group({
                        min: 0,
                        max: DAYS_IN_WEEK - 1,
                        i: 1,
                        node: &#x27;th&#x27;,
                        item: function( counter ) {
                            return [
                                collection[ counter ],
                                settings.klass.weekdays,
                                &#x27;scope=col title=&quot;&#x27; + fullCollection[ counter ] + &#x27;&quot;&#x27;
                            ]
                        }
                    })
                )
            ) //endreturn

        // Materialize modified
        })( ( settings.showWeekdaysFull ? settings.weekdaysFull : settings.weekdaysLetter ).slice( 0 ), settings.weekdaysFull.slice( 0 ) ), //tableHead


        // Create the nav for next/prev month.
        createMonthNav = function( next ) {

            // Otherwise, return the created month tag.
            return _.node(
                &#x27;div&#x27;,
                &#x27; &#x27;,
                settings.klass[ &#x27;nav&#x27; + ( next ? &#x27;Next&#x27; : &#x27;Prev&#x27; ) ] + (

                    // If the focused month is outside the range, disabled the button.
                    ( next &amp;&amp; viewsetObject.year &gt;= maxLimitObject.year &amp;&amp; viewsetObject.month &gt;= maxLimitObject.month ) ||
                    ( !next &amp;&amp; viewsetObject.year &lt;= minLimitObject.year &amp;&amp; viewsetObject.month &lt;= minLimitObject.month ) ?
                    &#x27; &#x27; + settings.klass.navDisabled : &#x27;&#x27;
                ),
                &#x27;data-nav=&#x27; + ( next || -1 ) + &#x27; &#x27; +
                _.ariaAttr({
                    role: &#x27;button&#x27;,
                    controls: calendar.$node[0].id + &#x27;_table&#x27;
                }) + &#x27; &#x27; +
                &#x27;title=&quot;&#x27; + (next ? settings.labelMonthNext : settings.labelMonthPrev ) + &#x27;&quot;&#x27;
            ) //endreturn
        }, //createMonthNav


        // Create the month label.
        //Materialize modified
        createMonthLabel = function(override) {

            var monthsCollection = settings.showMonthsShort ? settings.monthsShort : settings.monthsFull

             // Materialize modified
            if (override == &quot;short_months&quot;) {
              monthsCollection = settings.monthsShort;
            }

            // If there are months to select, add a dropdown menu.
            if ( settings.selectMonths  &amp;&amp; override == undefined) {

                return _.node( &#x27;select&#x27;,
                    _.group({
                        min: 0,
                        max: 11,
                        i: 1,
                        node: &#x27;option&#x27;,
                        item: function( loopedMonth ) {

                            return [

                                // The looped month and no classes.
                                monthsCollection[ loopedMonth ], 0,

                                // Set the value and selected index.
                                &#x27;value=&#x27; + loopedMonth +
                                ( viewsetObject.month == loopedMonth ? &#x27; selected&#x27; : &#x27;&#x27; ) +
                                (
                                    (
                                        ( viewsetObject.year == minLimitObject.year &amp;&amp; loopedMonth &lt; minLimitObject.month ) ||
                                        ( viewsetObject.year == maxLimitObject.year &amp;&amp; loopedMonth &gt; maxLimitObject.month )
                                    ) ?
                                    &#x27; disabled&#x27; : &#x27;&#x27;
                                )
                            ]
                        }
                    }),
                    settings.klass.selectMonth + &#x27; browser-default&#x27;,
                    ( isOpen ? &#x27;&#x27; : &#x27;disabled&#x27; ) + &#x27; &#x27; +
                    _.ariaAttr({ controls: calendar.$node[0].id + &#x27;_table&#x27; }) + &#x27; &#x27; +
                    &#x27;title=&quot;&#x27; + settings.labelMonthSelect + &#x27;&quot;&#x27;
                )
            }

            // Materialize modified
            if (override == &quot;short_months&quot;)
                if (selectedObject != null)
                return _.node( &#x27;div&#x27;, monthsCollection[ selectedObject.month ] );
                else return _.node( &#x27;div&#x27;, monthsCollection[ viewsetObject.month ] );

            // If there&#x27;s a need for a month selector
            return _.node( &#x27;div&#x27;, monthsCollection[ viewsetObject.month ], settings.klass.month )
        }, //createMonthLabel


        // Create the year label.
        // Materialize modified
        createYearLabel = function(override) {

            var focusedYear = viewsetObject.year,

            // If years selector is set to a literal &quot;true&quot;, set it to 5. Otherwise
            // divide in half to get half before and half after focused year.
            numberYears = settings.selectYears === true ? 5 : ~~( settings.selectYears / 2 )

            // If there are years to select, add a dropdown menu.
            if ( numberYears ) {

                var
                    minYear = minLimitObject.year,
                    maxYear = maxLimitObject.year,
                    lowestYear = focusedYear - numberYears,
                    highestYear = focusedYear + numberYears

                // If the min year is greater than the lowest year, increase the highest year
                // by the difference and set the lowest year to the min year.
                if ( minYear &gt; lowestYear ) {
                    highestYear += minYear - lowestYear
                    lowestYear = minYear
                }

                // If the max year is less than the highest year, decrease the lowest year
                // by the lower of the two: available and needed years. Then set the
                // highest year to the max year.
                if ( maxYear &lt; highestYear ) {

                    var availableYears = lowestYear - minYear,
                        neededYears = highestYear - maxYear

                    lowestYear -= availableYears &gt; neededYears ? neededYears : availableYears
                    highestYear = maxYear
                }

                if ( settings.selectYears  &amp;&amp; override == undefined ) {
                    return _.node( &#x27;select&#x27;,
                        _.group({
                            min: lowestYear,
                            max: highestYear,
                            i: 1,
                            node: &#x27;option&#x27;,
                            item: function( loopedYear ) {
                                return [

                                    // The looped year and no classes.
                                    loopedYear, 0,

                                    // Set the value and selected index.
                                    &#x27;value=&#x27; + loopedYear + ( focusedYear == loopedYear ? &#x27; selected&#x27; : &#x27;&#x27; )
                                ]
                            }
                        }),
                        settings.klass.selectYear + &#x27; browser-default&#x27;,
                        ( isOpen ? &#x27;&#x27; : &#x27;disabled&#x27; ) + &#x27; &#x27; + _.ariaAttr({ controls: calendar.$node[0].id + &#x27;_table&#x27; }) + &#x27; &#x27; +
                        &#x27;title=&quot;&#x27; + settings.labelYearSelect + &#x27;&quot;&#x27;
                    )
                }
            }

            // Materialize modified
            if (override == &quot;raw&quot;)
                return _.node( &#x27;div&#x27;, focusedYear )

            // Otherwise just return the year focused
            return _.node( &#x27;div&#x27;, focusedYear, settings.klass.year )
        } //createYearLabel


        // Materialize modified
        createDayLabel = function() {
                if (selectedObject != null)
                    return _.node( &#x27;div&#x27;, selectedObject.date)
                else return _.node( &#x27;div&#x27;, nowObject.date)
            }
        createWeekdayLabel = function() {
            var display_day;

            if (selectedObject != null)
                display_day = selectedObject.day;
            else
                display_day = nowObject.day;
            var weekday = settings.weekdaysFull[ display_day ]
            return weekday
        }


    // Create and return the entire calendar.
return _.node(
        // Date presentation View
        &#x27;div&#x27;,
            _.node(
                &#x27;div&#x27;,
                createWeekdayLabel(),
                &quot;picker__weekday-display&quot;
            )+
            _.node(
                // Div for short Month
                &#x27;div&#x27;,
                createMonthLabel(&quot;short_months&quot;),
                settings.klass.month_display
            )+
            _.node(
                // Div for Day
                &#x27;div&#x27;,
                createDayLabel() ,
                settings.klass.day_display
            )+
            _.node(
                // Div for Year
                &#x27;div&#x27;,
                createYearLabel(&quot;raw&quot;) ,
                settings.klass.year_display
            ),
        settings.klass.date_display
    )+
    // Calendar container
    _.node(&#x27;div&#x27;,
        _.node(&#x27;div&#x27;,
        ( settings.selectYears ?  createMonthLabel() + createYearLabel() : createMonthLabel() + createYearLabel() ) +
        createMonthNav() + createMonthNav( 1 ),
        settings.klass.header
    ) + _.node(
        &#x27;table&#x27;,
        tableHead +
        _.node(
            &#x27;tbody&#x27;,
            _.group({
                min: 0,
                max: WEEKS_IN_CALENDAR - 1,
                i: 1,
                node: &#x27;tr&#x27;,
                item: function( rowCounter ) {

                    // If Monday is the first day and the month starts on Sunday, shift the date back a week.
                    var shiftDateBy = settings.firstDay &amp;&amp; calendar.create([ viewsetObject.year, viewsetObject.month, 1 ]).day === 0 ? -7 : 0

                    return [
                        _.group({
                            min: DAYS_IN_WEEK * rowCounter - viewsetObject.day + shiftDateBy + 1, // Add 1 for weekday 0index
                            max: function() {
                                return this.min + DAYS_IN_WEEK - 1
                            },
                            i: 1,
                            node: &#x27;td&#x27;,
                            item: function( targetDate ) {

                                // Convert the time date from a relative date to a target date.
                                targetDate = calendar.create([ viewsetObject.year, viewsetObject.month, targetDate + ( settings.firstDay ? 1 : 0 ) ])

                                var isSelected = selectedObject &amp;&amp; selectedObject.pick == targetDate.pick,
                                    isHighlighted = highlightedObject &amp;&amp; highlightedObject.pick == targetDate.pick,
                                    isDisabled = disabledCollection &amp;&amp; calendar.disabled( targetDate ) || targetDate.pick &lt; minLimitObject.pick || targetDate.pick &gt; maxLimitObject.pick,
                                    formattedDate = _.trigger( calendar.formats.toString, calendar, [ settings.format, targetDate ] )

                                return [
                                    _.node(
                                        &#x27;div&#x27;,
                                        targetDate.date,
                                        (function( klasses ) {

                                            // Add the &#x60;infocus&#x60; or &#x60;outfocus&#x60; classes based on month in view.
                                            klasses.push( viewsetObject.month == targetDate.month ? settings.klass.infocus : settings.klass.outfocus )

                                            // Add the &#x60;today&#x60; class if needed.
                                            if ( nowObject.pick == targetDate.pick ) {
                                                klasses.push( settings.klass.now )
                                            }

                                            // Add the &#x60;selected&#x60; class if something&#x27;s selected and the time matches.
                                            if ( isSelected ) {
                                                klasses.push( settings.klass.selected )
                                            }

                                            // Add the &#x60;highlighted&#x60; class if something&#x27;s highlighted and the time matches.
                                            if ( isHighlighted ) {
                                                klasses.push( settings.klass.highlighted )
                                            }

                                            // Add the &#x60;disabled&#x60; class if something&#x27;s disabled and the object matches.
                                            if ( isDisabled ) {
                                                klasses.push( settings.klass.disabled )
                                            }

                                            return klasses.join( &#x27; &#x27; )
                                        })([ settings.klass.day ]),
                                        &#x27;data-pick=&#x27; + targetDate.pick + &#x27; &#x27; + _.ariaAttr({
                                            role: &#x27;gridcell&#x27;,
                                            label: formattedDate,
                                            selected: isSelected &amp;&amp; calendar.$node.val() === formattedDate ? true : null,
                                            activedescendant: isHighlighted ? true : null,
                                            disabled: isDisabled ? true : null
                                        })
                                    ),
                                    &#x27;&#x27;,
                                    _.ariaAttr({ role: &#x27;presentation&#x27; })
                                ] //endreturn
                            }
                        })
                    ] //endreturn
                }
            })
        ),
        settings.klass.table,
        &#x27;id=&quot;&#x27; + calendar.$node[0].id + &#x27;_table&#x27; + &#x27;&quot; &#x27; + _.ariaAttr({
            role: &#x27;grid&#x27;,
            controls: calendar.$node[0].id,
            readonly: true
        })
    )
    , settings.klass.calendar_container) // end calendar

     +

    // * For Firefox forms to submit, make sure to set the buttons’ &#x60;type&#x60; attributes as “button”.
    _.node(
        &#x27;div&#x27;,
        _.node( &#x27;button&#x27;, settings.today, &quot;btn-flat picker__today&quot;,
            &#x27;type=button data-pick=&#x27; + nowObject.pick +
            ( isOpen &amp;&amp; !calendar.disabled(nowObject) ? &#x27;&#x27; : &#x27; disabled&#x27; ) + &#x27; &#x27; +
            _.ariaAttr({ controls: calendar.$node[0].id }) ) +
        _.node( &#x27;button&#x27;, settings.clear, &quot;btn-flat picker__clear&quot;,
            &#x27;type=button data-clear=1&#x27; +
            ( isOpen ? &#x27;&#x27; : &#x27; disabled&#x27; ) + &#x27; &#x27; +
            _.ariaAttr({ controls: calendar.$node[0].id }) ) +
        _.node(&#x27;button&#x27;, settings.close, &quot;btn-flat picker__close&quot;,
            &#x27;type=button data-close=true &#x27; +
            ( isOpen ? &#x27;&#x27; : &#x27; disabled&#x27; ) + &#x27; &#x27; +
            _.ariaAttr({ controls: calendar.$node[0].id }) ),
        settings.klass.footer
    ) //endreturn
} //DatePicker.prototype.nodes




/**
 * The date picker defaults.
 */
DatePicker.defaults = (function( prefix ) {

    return {

        // The title label to use for the month nav buttons
        labelMonthNext: &#x27;Next month&#x27;,
        labelMonthPrev: &#x27;Previous month&#x27;,

        // The title label to use for the dropdown selectors
        labelMonthSelect: &#x27;Select a month&#x27;,
        labelYearSelect: &#x27;Select a year&#x27;,

        // Months and weekdays
        monthsFull: [ &#x27;January&#x27;, &#x27;February&#x27;, &#x27;March&#x27;, &#x27;April&#x27;, &#x27;May&#x27;, &#x27;June&#x27;, &#x27;July&#x27;, &#x27;August&#x27;, &#x27;September&#x27;, &#x27;October&#x27;, &#x27;November&#x27;, &#x27;December&#x27; ],
        monthsShort: [ &#x27;Jan&#x27;, &#x27;Feb&#x27;, &#x27;Mar&#x27;, &#x27;Apr&#x27;, &#x27;May&#x27;, &#x27;Jun&#x27;, &#x27;Jul&#x27;, &#x27;Aug&#x27;, &#x27;Sep&#x27;, &#x27;Oct&#x27;, &#x27;Nov&#x27;, &#x27;Dec&#x27; ],
        weekdaysFull: [ &#x27;Sunday&#x27;, &#x27;Monday&#x27;, &#x27;Tuesday&#x27;, &#x27;Wednesday&#x27;, &#x27;Thursday&#x27;, &#x27;Friday&#x27;, &#x27;Saturday&#x27; ],
        weekdaysShort: [ &#x27;Sun&#x27;, &#x27;Mon&#x27;, &#x27;Tue&#x27;, &#x27;Wed&#x27;, &#x27;Thu&#x27;, &#x27;Fri&#x27;, &#x27;Sat&#x27; ],

        // Materialize modified
        weekdaysLetter: [ &#x27;S&#x27;, &#x27;M&#x27;, &#x27;T&#x27;, &#x27;W&#x27;, &#x27;T&#x27;, &#x27;F&#x27;, &#x27;S&#x27; ],

        // Today and clear
        today: &#x27;Today&#x27;,
        clear: &#x27;Clear&#x27;,
        close: &#x27;Close&#x27;,

        // The format to show on the &#x60;input&#x60; element
        format: &#x27;d mmmm, yyyy&#x27;,

        // Classes
        klass: {

            table: prefix + &#x27;table&#x27;,

            header: prefix + &#x27;header&#x27;,


            // Materialize Added klasses
            date_display: prefix + &#x27;date-display&#x27;,
            day_display: prefix + &#x27;day-display&#x27;,
            month_display: prefix + &#x27;month-display&#x27;,
            year_display: prefix + &#x27;year-display&#x27;,
            calendar_container: prefix + &#x27;calendar-container&#x27;,
            // end



            navPrev: prefix + &#x27;nav--prev&#x27;,
            navNext: prefix + &#x27;nav--next&#x27;,
            navDisabled: prefix + &#x27;nav--disabled&#x27;,

            month: prefix + &#x27;month&#x27;,
            year: prefix + &#x27;year&#x27;,

            selectMonth: prefix + &#x27;select--month&#x27;,
            selectYear: prefix + &#x27;select--year&#x27;,

            weekdays: prefix + &#x27;weekday&#x27;,

            day: prefix + &#x27;day&#x27;,
            disabled: prefix + &#x27;day--disabled&#x27;,
            selected: prefix + &#x27;day--selected&#x27;,
            highlighted: prefix + &#x27;day--highlighted&#x27;,
            now: prefix + &#x27;day--today&#x27;,
            infocus: prefix + &#x27;day--infocus&#x27;,
            outfocus: prefix + &#x27;day--outfocus&#x27;,

            footer: prefix + &#x27;footer&#x27;,

            buttonClear: prefix + &#x27;button--clear&#x27;,
            buttonToday: prefix + &#x27;button--today&#x27;,
            buttonClose: prefix + &#x27;button--close&#x27;
        }
    }
})( Picker.klasses().picker + &#x27;__&#x27; )





/**
 * Extend the picker to add the date picker.
 */
Picker.extend( &#x27;pickadate&#x27;, DatePicker )


}));


;(function ($) {

  $.fn.characterCounter = function(){
    return this.each(function(){
      var $input = $(this);
      var $counterElement = $input.parent().find(&#x27;span[class=&quot;character-counter&quot;]&#x27;);

      // character counter has already been added appended to the parent container
      if ($counterElement.length) {
        return;
      }

      var itHasLengthAttribute = $input.attr(&#x27;data-length&#x27;) !== undefined;

      if(itHasLengthAttribute){
        $input.on(&#x27;input&#x27;, updateCounter);
        $input.on(&#x27;focus&#x27;, updateCounter);
        $input.on(&#x27;blur&#x27;, removeCounterElement);

        addCounterElement($input);
      }

    });
  };

  function updateCounter(){
    var maxLength     = +$(this).attr(&#x27;data-length&#x27;),
    actualLength      = +$(this).val().length,
    isValidLength     = actualLength &lt;= maxLength;

    $(this).parent().find(&#x27;span[class=&quot;character-counter&quot;]&#x27;)
                    .html( actualLength + &#x27;/&#x27; + maxLength);

    addInputStyle(isValidLength, $(this));
  }

  function addCounterElement($input) {
    var $counterElement = $input.parent().find(&#x27;span[class=&quot;character-counter&quot;]&#x27;);

    if ($counterElement.length) {
      return;
    }

    $counterElement = $(&#x27;&lt;span/&gt;&#x27;)
                        .addClass(&#x27;character-counter&#x27;)
                        .css(&#x27;float&#x27;,&#x27;right&#x27;)
                        .css(&#x27;font-size&#x27;,&#x27;12px&#x27;)
                        .css(&#x27;height&#x27;, 1);

    $input.parent().append($counterElement);
  }

  function removeCounterElement(){
    $(this).parent().find(&#x27;span[class=&quot;character-counter&quot;]&#x27;).html(&#x27;&#x27;);
  }

  function addInputStyle(isValidLength, $input){
    var inputHasInvalidClass = $input.hasClass(&#x27;invalid&#x27;);
    if (isValidLength &amp;&amp; inputHasInvalidClass) {
      $input.removeClass(&#x27;invalid&#x27;);
    }
    else if(!isValidLength &amp;&amp; !inputHasInvalidClass){
      $input.removeClass(&#x27;valid&#x27;);
      $input.addClass(&#x27;invalid&#x27;);
    }
  }

  $(document).ready(function(){
    $(&#x27;input, textarea&#x27;).characterCounter();
  });

}( jQuery ));
;(function ($) {

  var methods = {

    init : function(options) {
      var defaults = {
        duration: 200, // ms
        dist: -100, // zoom scale TODO: make this more intuitive as an option
        shift: 0, // spacing for center image
        padding: 0, // Padding between non center items
        fullWidth: false, // Change to full width styles
        indicators: false, // Toggle indicators
        noWrap: false, // Don&#x27;t wrap around and cycle through items.
        onCycleTo: null // Callback for when a new slide is cycled to.
      };
      options = $.extend(defaults, options);

      return this.each(function() {

        var images, item_width, item_height, offset, center, pressed, dim, count,
            reference, referenceY, amplitude, target, velocity,
            xform, frame, timestamp, ticker, dragged, vertical_dragged;
        var $indicators = $(&#x27;&lt;ul class=&quot;indicators&quot;&gt;&lt;/ul&gt;&#x27;);


        // Initialize
        var view = $(this);
        var showIndicators = view.attr(&#x27;data-indicators&#x27;) || options.indicators;

        // Don&#x27;t double initialize.
        if (view.hasClass(&#x27;initialized&#x27;)) {
          // Redraw carousel.
          $(this).trigger(&#x27;carouselNext&#x27;, [0.000001]);
          return true;
        }


        // Options
        if (options.fullWidth) {
          options.dist = 0;
          var firstImage = view.find(&#x27;.carousel-item img&#x27;).first();
          if (firstImage.length) {
            imageHeight = firstImage.on(&#x27;load&#x27;, function(){
              view.css(&#x27;height&#x27;, $(this).height());
            });
          } else {
            imageHeight = view.find(&#x27;.carousel-item&#x27;).first().height();
            view.css(&#x27;height&#x27;, imageHeight);
          }

          // Offset fixed items when indicators.
          if (showIndicators) {
            view.find(&#x27;.carousel-fixed-item&#x27;).addClass(&#x27;with-indicators&#x27;);
          }
        }


        view.addClass(&#x27;initialized&#x27;);
        pressed = false;
        offset = target = 0;
        images = [];
        item_width = view.find(&#x27;.carousel-item&#x27;).first().innerWidth();
        item_height = view.find(&#x27;.carousel-item&#x27;).first().innerHeight();
        dim = item_width * 2 + options.padding;

        view.find(&#x27;.carousel-item&#x27;).each(function (i) {
          images.push($(this)[0]);
          if (showIndicators) {
            var $indicator = $(&#x27;&lt;li class=&quot;indicator-item&quot;&gt;&lt;/li&gt;&#x27;);

            // Add active to first by default.
            if (i === 0) {
              $indicator.addClass(&#x27;active&#x27;);
            }

            // Handle clicks on indicators.
            $indicator.click(function (e) {
              e.stopPropagation();

              var index = $(this).index();
              cycleTo(index);
            });
            $indicators.append($indicator);
          }
        });

        if (showIndicators) {
          view.append($indicators);
        }
        count = images.length;


        function setupEvents() {
          if (typeof window.ontouchstart !== &#x27;undefined&#x27;) {
            view[0].addEventListener(&#x27;touchstart&#x27;, tap);
            view[0].addEventListener(&#x27;touchmove&#x27;, drag);
            view[0].addEventListener(&#x27;touchend&#x27;, release);
          }
          view[0].addEventListener(&#x27;mousedown&#x27;, tap);
          view[0].addEventListener(&#x27;mousemove&#x27;, drag);
          view[0].addEventListener(&#x27;mouseup&#x27;, release);
          view[0].addEventListener(&#x27;mouseleave&#x27;, release);
          view[0].addEventListener(&#x27;click&#x27;, click);
        }

        function xpos(e) {
          // touch event
          if (e.targetTouches &amp;&amp; (e.targetTouches.length &gt;= 1)) {
            return e.targetTouches[0].clientX;
          }

          // mouse event
          return e.clientX;
        }

        function ypos(e) {
          // touch event
          if (e.targetTouches &amp;&amp; (e.targetTouches.length &gt;= 1)) {
            return e.targetTouches[0].clientY;
          }

          // mouse event
          return e.clientY;
        }

        function wrap(x) {
          return (x &gt;= count) ? (x % count) : (x &lt; 0) ? wrap(count + (x % count)) : x;
        }

        function scroll(x) {
          var i, half, delta, dir, tween, el, alignment, xTranslation;
          var lastCenter = center;

          offset = (typeof x === &#x27;number&#x27;) ? x : offset;
          center = Math.floor((offset + dim / 2) / dim);
          delta = offset - center * dim;
          dir = (delta &lt; 0) ? 1 : -1;
          tween = -dir * delta * 2 / dim;
          half = count &gt;&gt; 1;

          if (!options.fullWidth) {
            alignment = &#x27;translateX(&#x27; + (view[0].clientWidth - item_width) / 2 + &#x27;px) &#x27;;
            alignment += &#x27;translateY(&#x27; + (view[0].clientHeight - item_height) / 2 + &#x27;px)&#x27;;
          } else {
            alignment = &#x27;translateX(0)&#x27;;
          }

          // Set indicator active
          if (showIndicators) {
            var diff = (center % count);
            var activeIndicator = $indicators.find(&#x27;.indicator-item.active&#x27;);
            if (activeIndicator.index() !== diff) {
              activeIndicator.removeClass(&#x27;active&#x27;);
              $indicators.find(&#x27;.indicator-item&#x27;).eq(diff).addClass(&#x27;active&#x27;);
            }
          }

          // center
          // Don&#x27;t show wrapped items.
          if (!options.noWrap || (center &gt;= 0 &amp;&amp; center &lt; count)) {
            el = images[wrap(center)];

            // Add active class to center item.
            if (!$(el).hasClass(&#x27;active&#x27;)) {
              view.find(&#x27;.carousel-item&#x27;).removeClass(&#x27;active&#x27;);
              $(el).addClass(&#x27;active&#x27;);
            }
            el.style[xform] = alignment +
              &#x27; translateX(&#x27; + (-delta / 2) + &#x27;px)&#x27; +
              &#x27; translateX(&#x27; + (dir * options.shift * tween * i) + &#x27;px)&#x27; +
              &#x27; translateZ(&#x27; + (options.dist * tween) + &#x27;px)&#x27;;
            el.style.zIndex = 0;
            if (options.fullWidth) { tweenedOpacity = 1; }
            else { tweenedOpacity = 1 - 0.2 * tween; }
            el.style.opacity = tweenedOpacity;
            el.style.display = &#x27;block&#x27;;
          }

          for (i = 1; i &lt;= half; ++i) {
            // right side
            if (options.fullWidth) {
              zTranslation = options.dist;
              tweenedOpacity = (i === half &amp;&amp; delta &lt; 0) ? 1 - tween : 1;
            } else {
              zTranslation = options.dist * (i * 2 + tween * dir);
              tweenedOpacity = 1 - 0.2 * (i * 2 + tween * dir);
            }
            // Don&#x27;t show wrapped items.
            if (!options.noWrap || center + i &lt; count) {
              el = images[wrap(center + i)];
              el.style[xform] = alignment +
                &#x27; translateX(&#x27; + (options.shift + (dim * i - delta) / 2) + &#x27;px)&#x27; +
                &#x27; translateZ(&#x27; + zTranslation + &#x27;px)&#x27;;
              el.style.zIndex = -i;
              el.style.opacity = tweenedOpacity;
              el.style.display = &#x27;block&#x27;;
            }


            // left side
            if (options.fullWidth) {
              zTranslation = options.dist;
              tweenedOpacity = (i === half &amp;&amp; delta &gt; 0) ? 1 - tween : 1;
            } else {
              zTranslation = options.dist * (i * 2 - tween * dir);
              tweenedOpacity = 1 - 0.2 * (i * 2 - tween * dir);
            }
            // Don&#x27;t show wrapped items.
            if (!options.noWrap || center - i &gt;= 0) {
              el = images[wrap(center - i)];
              el.style[xform] = alignment +
                &#x27; translateX(&#x27; + (-options.shift + (-dim * i - delta) / 2) + &#x27;px)&#x27; +
                &#x27; translateZ(&#x27; + zTranslation + &#x27;px)&#x27;;
              el.style.zIndex = -i;
              el.style.opacity = tweenedOpacity;
              el.style.display = &#x27;block&#x27;;
            }
          }

          // center
          // Don&#x27;t show wrapped items.
          if (!options.noWrap || (center &gt;= 0 &amp;&amp; center &lt; count)) {
            el = images[wrap(center)];
            el.style[xform] = alignment +
              &#x27; translateX(&#x27; + (-delta / 2) + &#x27;px)&#x27; +
              &#x27; translateX(&#x27; + (dir * options.shift * tween) + &#x27;px)&#x27; +
              &#x27; translateZ(&#x27; + (options.dist * tween) + &#x27;px)&#x27;;
            el.style.zIndex = 0;
            if (options.fullWidth) { tweenedOpacity = 1; }
            else { tweenedOpacity = 1 - 0.2 * tween; }
            el.style.opacity = tweenedOpacity;
            el.style.display = &#x27;block&#x27;;
          }

          // onCycleTo callback
          if (lastCenter !== center &amp;&amp;
              typeof(options.onCycleTo) === &quot;function&quot;) {
            var $curr_item = view.find(&#x27;.carousel-item&#x27;).eq(wrap(center));
            options.onCycleTo.call(this, $curr_item, dragged);
          }
        }

        function track() {
          var now, elapsed, delta, v;

          now = Date.now();
          elapsed = now - timestamp;
          timestamp = now;
          delta = offset - frame;
          frame = offset;

          v = 1000 * delta / (1 + elapsed);
          velocity = 0.8 * v + 0.2 * velocity;
        }

        function autoScroll() {
          var elapsed, delta;

          if (amplitude) {
            elapsed = Date.now() - timestamp;
            delta = amplitude * Math.exp(-elapsed / options.duration);
            if (delta &gt; 2 || delta &lt; -2) {
                scroll(target - delta);
                requestAnimationFrame(autoScroll);
            } else {
                scroll(target);
            }
          }
        }

        function click(e) {
          // Disable clicks if carousel was dragged.
          if (dragged) {
            e.preventDefault();
            e.stopPropagation();
            return false;

          } else if (!options.fullWidth) {
            var clickedIndex = $(e.target).closest(&#x27;.carousel-item&#x27;).index();
            var diff = (center % count) - clickedIndex;

            // Disable clicks if carousel was shifted by click
            if (diff !== 0) {
              e.preventDefault();
              e.stopPropagation();
            }
            cycleTo(clickedIndex);
          }
        }

        function cycleTo(n) {
          var diff = (center % count) - n;

          // Account for wraparound.
          if (!options.noWrap) {
            if (diff &lt; 0) {
              if (Math.abs(diff + count) &lt; Math.abs(diff)) { diff += count; }

            } else if (diff &gt; 0) {
              if (Math.abs(diff - count) &lt; diff) { diff -= count; }
            }
          }

          // Call prev or next accordingly.
          if (diff &lt; 0) {
            view.trigger(&#x27;carouselNext&#x27;, [Math.abs(diff)]);

          } else if (diff &gt; 0) {
            view.trigger(&#x27;carouselPrev&#x27;, [diff]);
          }
        }

        function tap(e) {
          pressed = true;
          dragged = false;
          vertical_dragged = false;
          reference = xpos(e);
          referenceY = ypos(e);

          velocity = amplitude = 0;
          frame = offset;
          timestamp = Date.now();
          clearInterval(ticker);
          ticker = setInterval(track, 100);

        }

        function drag(e) {
          var x, delta, deltaY;
          if (pressed) {
            x = xpos(e);
            y = ypos(e);
            delta = reference - x;
            deltaY = Math.abs(referenceY - y);
            if (deltaY &lt; 30 &amp;&amp; !vertical_dragged) {
              // If vertical scrolling don&#x27;t allow dragging.
              if (delta &gt; 2 || delta &lt; -2) {
                dragged = true;
                reference = x;
                scroll(offset + delta);
              }

            } else if (dragged) {
              // If dragging don&#x27;t allow vertical scroll.
              e.preventDefault();
              e.stopPropagation();
              return false;

            } else {
              // Vertical scrolling.
              vertical_dragged = true;
            }
          }

          if (dragged) {
            // If dragging don&#x27;t allow vertical scroll.
            e.preventDefault();
            e.stopPropagation();
            return false;
          }
        }

        function release(e) {
          if (pressed) {
            pressed = false;
          } else {
            return;
          }

          clearInterval(ticker);
          target = offset;
          if (velocity &gt; 10 || velocity &lt; -10) {
            amplitude = 0.9 * velocity;
            target = offset + amplitude;
          }
          target = Math.round(target / dim) * dim;

          // No wrap of items.
          if (options.noWrap) {
            if (target &gt;= dim * (count - 1)) {
              target = dim * (count - 1);
            } else if (target &lt; 0) {
              target = 0;
            }
          }
          amplitude = target - offset;
          timestamp = Date.now();
          requestAnimationFrame(autoScroll);

          if (dragged) {
            e.preventDefault();
            e.stopPropagation();
          }
          return false;
        }

        xform = &#x27;transform&#x27;;
        [&#x27;webkit&#x27;, &#x27;Moz&#x27;, &#x27;O&#x27;, &#x27;ms&#x27;].every(function (prefix) {
          var e = prefix + &#x27;Transform&#x27;;
          if (typeof document.body.style[e] !== &#x27;undefined&#x27;) {
            xform = e;
            return false;
          }
          return true;
        });


        $(window).on(&#x27;resize.carousel&#x27;, function() {
          if (options.fullWidth) {
            item_width = view.find(&#x27;.carousel-item&#x27;).first().innerWidth();
            item_height = view.find(&#x27;.carousel-item&#x27;).first().innerHeight();
            dim = item_width * 2 + options.padding;
            offset = center * 2 * item_width;
            target = offset;
          } else {
            scroll();
          }
        });

        setupEvents();
        scroll(offset);

        $(this).on(&#x27;carouselNext&#x27;, function(e, n) {
          if (n === undefined) {
            n = 1;
          }
          target = (dim * Math.round(offset / dim)) + (dim * n);
          if (offset !== target) {
            amplitude = target - offset;
            timestamp = Date.now();
            requestAnimationFrame(autoScroll);
          }
        });

        $(this).on(&#x27;carouselPrev&#x27;, function(e, n) {
          if (n === undefined) {
            n = 1;
          }
          target = (dim * Math.round(offset / dim)) - (dim * n);
          if (offset !== target) {
            amplitude = target - offset;
            timestamp = Date.now();
            requestAnimationFrame(autoScroll);
          }
        });

        $(this).on(&#x27;carouselSet&#x27;, function(e, n) {
          if (n === undefined) {
            n = 0;
          }
          cycleTo(n);
        });

      });



    },
    next : function(n) {
      $(this).trigger(&#x27;carouselNext&#x27;, [n]);
    },
    prev : function(n) {
      $(this).trigger(&#x27;carouselPrev&#x27;, [n]);
    },
    set : function(n) {
      $(this).trigger(&#x27;carouselSet&#x27;, [n]);
    }
  };


    $.fn.carousel = function(methodOrOptions) {
      if ( methods[methodOrOptions] ) {
        return methods[ methodOrOptions ].apply( this, Array.prototype.slice.call( arguments, 1 ));
      } else if ( typeof methodOrOptions === &#x27;object&#x27; || ! methodOrOptions ) {
        // Default to &quot;init&quot;
        return methods.init.apply( this, arguments );
      } else {
        $.error( &#x27;Method &#x27; +  methodOrOptions + &#x27; does not exist on jQuery.carousel&#x27; );
      }
    }; // Plugin end
}( jQuery ));
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
